import java.io.*;

abstract class Abst
{
	int n;
 	public Abst()
	{
	}
	abstract void face();
	public void print()
	{
		System.out.println("print");
	}
}

class myclass extends Abst
{
	void face()
	{
		System.out.println("face");
	}
}


class Abstract
{
	public static void main(String args[])
	{
		myclass a = new myclass();
		a.face();
		a.print();
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Add 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		int[] Arr1={9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
		int[] Arr2={9, 7};
		int[] Arr = new int[3];
		Arr = Add(Arr1, Arr2);
		for(int i=0; i<Arr1.length; i++)
			System.out.print(Arr1[i]+" ");
		System.out.println();

		for(int i=0; i<Arr2.length; i++)
			System.out.print(Arr2[i]+" ");
		System.out.println();

		for(int i=0; i<Arr.length; i++)
			System.out.print(Arr[i]+" ");
		System.out.println();
	}
	public static int[] Multiple(int[] Arr1, int[] Arr2)
	{

		return null;
	}
	public static int[] Add(int[] Arr1, int[] Arr2)
	{
		int[] Arr = null;
		int mod=0; int c=0;
		if(Arr1 != null && Arr1 != null)
		{
			int len1 = Arr1.length;
			int len2 = Arr2.length;
			Arr = new int[len1>len2?len1+1:len2+1];
			if(len1 > 0 && len2 > 0 && len1 >= len2)
			{
				for(int i=0; i<len1; i++)
				{
					if(len2-1-i >= 0)
					{
						mod = (c + Arr1[len1-1-i] + Arr2[len2-1-i])%10;
						c = (c + Arr1[len1-1-i] + Arr2[len2-1-i])/10;
					}
					else
					{
						mod = (c + Arr1[len1-1-i])%10;
						c = (c + Arr1[len1-1-i])/10;
					}
					Arr[len1+1-1-i]=mod;
				}
				if(c>0)
					Arr[0]=c;
			}
			else if(len1 > 0 && len2 > 0 && len2 > len1)
			{
				for(int i=0; i<len2; i++)
				{
					if(len1-1-i >= 0)
					{
						mod = (c + Arr1[len1-1-i] + Arr2[len2-1-i])%10;
						c = (c + Arr1[len1-1-i] + Arr2[len2-1-i])/10;
					}
					else
					{
						mod = (c + Arr1[len2-1-i])%10;
						c = (c + Arr1[len2-1-i])/10;
					}
					Arr[len2+1-1-i]=mod;
				}
				if(c>0)
					Arr[0]=c;
			}
		}
		if(c == 0)
		{
			int[] A = new int[Arr.length-1];
			for(int i=1; i<Arr.length; i++)
				A[i-1]=Arr[i];
			Arr=null;
			Arr = new int[A.length];
			for(int i=0; i<A.length; i++)
				Arr[i]=A[i];
		}
		return Arr;
	}
}
public class AddMultiString 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        System.out.println("9+98");
        System.out.println(Add("0", "1"));
    }
    public static String Add(String s1, String s2)
    {
        String ret = "0";
        if(s1 != null && s2 != null)
        {
            if(s1 == "0" && s2 == "0")
                return ret; 

            int len1 = s1.length();
            int len2 = s2.length();
            int maxlen = len1 > len2 ? len1 : len2;
            int[] A1 = new int[maxlen];
            int[] A2 = new int[maxlen];

            for(int i=0; i<maxlen; i++)
                A1[i] = A2[i] = 0;

            int index1 = 0, index2 = 0;
            while(index1 < len1)
            {
                A1[(maxlen-len1)+index1] = s1.charAt(index1)-'0';
                index1++;
            }

            while(index2 < len2)
            {
                A2[(maxlen-len2)+index2] = s2.charAt(index2)-'0';
                index2++;
            }

            int[] sum = new int[maxlen+1];
            int s=0, carry = 0, i=0;
            for(i=maxlen-1; i >= 0; i--)
            {
                s = A1[i] + A2[i] + carry;    
                sum[i+1] = s % 10;
                carry = s / 10;
            }
            if(carry > 0)
            {
                sum[0] = carry;
            }
            
            for(int j=0; j<maxlen+1; j++)
            {
                if((j == 0 && sum[j] > 0) || j > 0)
                    ret += sum[j] + "";
            }
        }
        return ret;
    }
}
import java.util.*;

class AddRemoveRandomClass
{
   Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
   int lastIndex;
   int max;
   int[] array;
   public AddRemoveRandomClass(int max)
   {
       lastIndex= 0;
       this.max = max;
       array = new int[max];
   }
   public void add(Integer num)
   {
       if(!map.containsKey(num) && lastIndex < max)
       {
           map.put(num, lastIndex);
           array[lastIndex] = num;
           lastIndex++;
       }
   }
   public void remove(int num)
   {
       Integer value = null;
       if((value = map.get(num)) != null)
       {
            map.remove(num);
            map.put(array[lastIndex], value);
            array[value] = array[lastIndex];
            lastIndex--;
       }
   } 
   public Integer getRandom()
   {
       if(lastIndex > 0)
       {
           Random ran = new Random(); 
           int index = ran.nextInt(lastIndex);
           return array[index];
       }
       else 
       {
           return -1;
       }
   }
   public void print()
   {
       for(int i=0; i < lastIndex; i++)
       {
            System.out.println("["+i+"]=["+array[i]+"]");
       }
   }
}

public class AddRemoveRandom 
{
				public static void main(String[] args)
				{
                    AddRemoveRandomClass stuff = new AddRemoveRandomClass(100);
                    stuff.add(20);
                    stuff.add(40);
                    stuff.add(2);
                    stuff.add(0);
                    stuff.print();
                    stuff.remove(40);
                    stuff.remove(2);
                    stuff.remove(0);
                    stuff.remove(20);
                    System.out.println();
                    stuff.print();
                    System.out.println("random=" + stuff.getRandom());
				}
}
public class AdjacentMatrix 
{
    public static void main(String[] args)
    {
        System.out.println("AdjacentMatrix");
        int array[][] = new int[][]{
        { 0, 2, 3, 4, 5 },
        { 0, 0, 1, 2, 9 },
        { 0, 0, 0, 6, 5 },
        { 0, 0, 0, 0, 7 },
        { 0, 0, 0, 0, 0 }
        };
        int row = 0;
        int max = findMinPath(array, row);
        System.out.println("max=" + max);
    }
    static int findMinPath(int[][] array, int row)
    {
        int max = 0;
        if(array != null)
        {
            int height = array.length;
            int width  = array[0] != null ? array[0].length : 0;
            //System.out.println("height=" + height);
            //System.out.println("width=" + width);

            if(row < height)
            {
                int currMax = 0;
                for(int col=0; col < width; col++)
                {
                    if(array[row][col] != 0)
                    {
                        System.out.println("("+row+")"+array[row][col]+"->("+col+")");
                        int subMax = findMinPath(array, col) + array[row][col];
                        if(subMax > currMax) 
                            currMax = subMax;
                    }
                }
                //System.out.println("max=" + currMax);
                max = currMax;
            }
        }
        return max;
    }
}
public class AllSquareNumber 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        SquareNumber(10);
    }
    //(X-1)^2 = X^2 -2X + 1
    //=>   X^2= (X-1)^2 + 2X + 1
    //=>   X^2= (X-1)^2 + (X-1) + X 
    static void SquareNumber(int n)
    {
        int prev = 0;
        int prevSquare = 0;   
        for(int curr=1; curr<=n; curr++)
        {
            prevSquare = prevSquare + prev + curr;
            System.out.println("["+prevSquare+"]");
            prev = curr;
        }
    }
}
import java.util.*;

public class AllUniqueSubPalindrome 
{
    public static void main(String[] args)
    {
        System.out.println("Palindrome With Space");
        int count = allUniqueSubPalindrome("aabaa");
        System.out.println("------------------------------------------------");
        System.out.println("count=" + count);
        count = allUniqueSubPalindrome("a");
        System.out.println("------------------------------------------------");
        System.out.println("count=" + count);
        count = allUniqueSubPalindrome("aa");
        System.out.println("------------------------------------------------");
        System.out.println("count=" + count);

        System.out.println("count=" + count);
        boolean b = isPalindrome("abc");
        System.out.println("abc=" + b);
         b = isPalindrome("aba");
        System.out.println("aba=" + b);
        b = isPalindrome("a");
        System.out.println("a=" + b);
        b = isPalindrome("ab");
        System.out.println("ab=" + b);
        b = isPalindrome("aabbccee");
        System.out.println("aabbccee=" + b);
        System.out.println("================================================");

        List<String> list = allSubString("abcdefg");
        for(String str:list){
            System.out.println(str);
        }
        System.out.println("================================================");
        List<String> list1 = mySubstring("helloworld", "world");
        for(String str:list1){
            System.out.println(str);
        }

    } 
    public static boolean isPalindrome(String str) {
        boolean ret = true; 
        if( str != null){
            int len = str.length();
            for(int i=0; i<len/2 && ret; i++){
                if(str.charAt(i) != str.charAt(len-1-i)){
                    ret = false; 
                }
            }
        }
        return ret;
    }

    public static List<String> mySubstring(String str1, String str2) {
        List<String> list = new ArrayList<String>();
        int len1 = str1.length();
        int len2 = str2.length();
        for(int i=0; i<len1 - len2 + 1; i++){
            String str = str1.substring(i, i+len2);
            list.add(str);
        }
        return list;
    }
    public static List<String> allSubString(String str) {
        List<String> list = new ArrayList<String>(); 
        int len = str.length();
        for(int i=0; i<len; i++){
            for(int j=i; j<len; j++){
                String substr = str.substring(i, j+1);
                list.add(substr);
            }
        }
        return list;
    }
    public static int allUniqueSubPalindrome(String str) {
        Set<String> set = new HashSet<String>();
        if(str != null){
            int len = str.length();
            for(int i=0; i<len; i++){
                for(int j=i; j<len; j++){
                    String substr = str.substring(i, j+1);
                    if(!set.contains(substr) && isPalindrome(substr)){
                        set.add(substr);
                    }
                }
            }
        }
        return set.size();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.List;

public class AmazonLocker{
    public static void main(String[] args) {
        System.out.println("Hello World!");
        test();
    }

    static int countOp(long n){
        List<Long> list = new ArrayList<Long>();
        if(n == 0)
            list.add((long)0);
        else if(n > 0){
            while(n > 0){
                long r = n % 2;
                list.add(r);
                n = n/2;
            }
        }

        int sum = 0;
        for(int i=0; i<list.size(); i++){
            if(list.get(i) == 1)
                sum += i+1;
        }
        return sum;
    }
    static void test(){
        System.out.println(countOp(5));
        System.out.println(countOp(3));
        System.out.println(countOp(6));
    }

    
    // amazon locker, locker, problem, manhattan problem,
    static int[][] getLockerDistanceGrid(int cityLength, int cityWidth, int[] lockerXCoordinates, int[] lockerYCoordinates) {
        int[][] gridArray = new int[cityLength][cityWidth];
        
        for (int i = 0; i < cityLength; i++) {
            for (int j = 0; j < cityWidth; j++) {
                for (int k = 0; k < lockerXCoordinates.length; k++) {
                    int distance1 = Math.abs(lockerXCoordinates[k] - i + 1 );
                    int distance2 = Math.abs(lockerYCoordinates[k] - j + 1 );
                    int sumDistance = distance1 + distance2;
                    
                    if (k == 0) {
                        gridArray[i][j] = sumDistance;
                    } else {
                        if (sumDistance < gridArray[i][j]) {
                            gridArray[i][j] = sumDistance;
                        }
                    }
                }
            }
        }
        return gridArray;
    }
}
import java.util.*;
import java.math.BigInteger;


final class Sortkey{
    //[ file=sortkeyanagram.html title=""
    //================================================================================ 
    // java anagram 
    // Use sort technic to solve anagrams problem 
    // Use sorted str as key
    // {dog, god}
    // dgo->{dog, god}
    // -------------------------------------------------------------------------------- 
    static String sortStr(String s) {
        char[] clist = s.toCharArray();
        Arrays.sort(clist);
        return String.valueOf(clist);
    }
    static List<String> anagrams(List<String> list, String input) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();

        if(list != null && input != null) {

            for(String str : list) {
                String key = sortStr(str);
                List<String> l = map.get(key);
                if(l != null) {
                    l.add(str);
                    map.put(key, l);
                } else {
                    List<String> ll = new ArrayList<String>();
                    ll.add(str);
                    map.put(key, ll);
                }
            }
        }
        return map.get(sortStr(input));
    }
    //]
}

final class Better {
    public  static List<Integer> genePrima(int count) {
        List<Integer> list = new LinkedList<Integer>();
        list.add(2);
        Integer prime=3;
        int c=0;
        while(c < count) {
            boolean isPrime = true;
            for(Integer p : list) {
                if(prime % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime) {
                list.add(prime);
                c++;
            }
            prime = prime + 1;
        }
        return list;
    }
    public  static Map<Character, BigInteger> generate() {
        Map<Character, BigInteger> map = new HashMap<Character, BigInteger>();
        List<Integer> plist = genePrima(25);

        char ch = 'a';
        for(int i=0; i<26; i++) {
            Character chara = new Character(ch);
            BigInteger big = BigInteger.valueOf((plist.get(i).intValue()));
            map.put(chara, big);
            ch = (char)(ch + 1);
        }
        return map;
    }
    public  static Map<BigInteger, List<String>> anagram(List<String> list) {
        Map<Character, BigInteger> map = generate();
        Map<BigInteger, List<String>> wordMap = new HashMap<BigInteger, List<String>>();
        for(String word:list) {
            BigInteger product = BigInteger.valueOf(1);
            for(int i=0; i<word.length(); i++) {
                char ch = word.charAt(i);
                if(map.containsKey(ch))
                    product = product.multiply(map.get(ch));
            }
            if(wordMap.containsKey(product)) {
                List<String> wordList = wordMap.get(product);
                wordList.add(word);
                wordMap.put(product, wordList);
            } else {
                List<String> wordList = new ArrayList<String>();
                wordList.add(word);
                wordMap.put(product, wordList);
            }
            product = BigInteger.valueOf(1);
        }
        return wordMap;
    }
}

final class Basic {
    public static List<Integer> getPrime(int n) {
        int k = 0;
        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        int num = 3;
        while(k < n) {
            boolean isPrime = true;
            for(Integer p : list) {
                if( num % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime) {
                list.add(num);
                k++;
            }
            num++;
        }
        return list;
    }

    //[ file=anagrambasic.html title=""
    public static Map<String, Integer> primeMap() {
        List<Integer> list = getPrime(26);
        Map<String, Integer> map = new HashMap<String, Integer>();
        char ch = 'a';
        for(Integer p : list) {
            map.put(ch + "", p);
            ch += 1;
        }
        return map;
    }

    public static Integer getProduct(String str) {
        Map<String, Integer> map = primeMap();
        int p = 1;
        for(int i=0; i<str.length(); i++) {
            p *= map.get((str.charAt(i) + "").toLowerCase());
        }
        return p;
    }

    public static List<String> anagrams(List<String> list, String str) {
        Map<Integer, List<String> > map = new HashMap<Integer, List<String>>();

        for(String s : list) {
            List<String> l = map.get(getProduct(s));
            if(l != null) {
                l.add(s);
                map.put(getProduct(s), l);
            } else {
                List<String> ll = new ArrayList<String>();
                ll.add(s);
                map.put(getProduct(s), ll);
            }
        }
        return map.get(getProduct(str));
    }
    //]
}

public class Anagram {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        test0();
        test1();
        test2();
        test3();
    }

    public static void test0() {
        System.out.println("test1()");
        List<String> list = new ArrayList<String>() {
            {
                add("dog");
                add("god");
                add("nice");
                add("debitcard");
                add("badcredit");
            }
        };
        Map<BigInteger, List<String>> wordMap = Better.anagram(list);
        for(BigInteger big: wordMap.keySet()) {
            List<String> wordlist = wordMap.get(big);
            System.out.println(big);
            for(String word: wordlist) {
                System.out.println(word);
            }
            System.out.println();
        }
    }

    public static void test1(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        words.add("God");
        words.add("Barack");
        words.add("Obama");
        List<String> list = Basic.anagrams(words, "dog");
        for(String s : list){
            System.out.println(s);
        }
    }

    public static void test2(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        List<String> list = Basic.anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }

    public static void test3(){
        List<String> words = new ArrayList<String>();
        words.add("");
        List<String> list = Basic.anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }
}
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Anagrams2{

    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    static void test0(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        words.add("God");
        words.add("Barack");
        words.add("Obama");
        List<String> list = anagrams(words, "dog");
        for(String s : list){
            System.out.println(s);
        }
    }

    static void test1(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        List<String> list = anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }

    static void test2(){
        List<String> words = new ArrayList<String>();
        words.add("");
        List<String> list = anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }


    //[file=anagram2.html title=""
    static List<Integer> getPrime(int n){
        int k = 0;
        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        int num = 3;
        while(k < n){
            boolean isPrime = true;
            for(Integer p : list){
                if( num % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime){
                list.add(num);
                k++;
            }
            num++;
        }
        return list;
    }

    static Map<String, Integer> primeMap(){
        List<Integer> list = getPrime(26);
        Map<String, Integer> map = new HashMap<String, Integer>();
        char ch = 'a';
        for(Integer p : list){
            map.put(ch + "", p);
            ch += 1;
        }
        return map;
    }

    static Integer getProduct(String str){
        Map<String, Integer> map = primeMap();
        int p = 1;
        for(int i=0; i<str.length(); i++){
            p *= map.get((str.charAt(i) + "").toLowerCase());
        }
        return p;
    }

    static List<String> anagrams(List<String> list, String str){
        Map<Integer, List<String> > map = new HashMap<Integer, List<String>>();

        for(String s : list){
            List<String> l = map.get(getProduct(s));
            if(l != null){
                l.add(s);
                map.put(getProduct(s), l);
            }else{
                List<String> ll = new ArrayList<String>();
                ll.add(s);
                map.put(getProduct(s), ll);
            }
        }
        return map.get(getProduct(str));
    }
    //]
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

// amazon test anagram amazontest amazon_test
public class AnagramIndex{
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();

        String haystack = "abdcghbaabcdij";
        String needle = "bcda";
        List<Integer> list = getAnagramIndices1(haystack, needle);
        Print.pbl(list);
        Aron.end();
    }

    static void test1(){
        Aron.beg();

        String haystack = "bbbababaaabbbb";
        String needle = "ab";
        List<Integer> list = getAnagramIndices1(haystack, needle);
        Print.pbl(list);

        Aron.end();
    }

    public static List<Integer> getAnagramIndices1(String haystack, String needle) {
        List<Integer> list = new ArrayList<Integer>(); 
        int len = needle.length();
        int hlen = haystack.length();
        String sortNeedle = Aron.sortStr(needle);
        for(int i=0; i<hlen; i++){
            if(len  + i <= hlen){
                String subStr = haystack.substring(i, len + i); 
                String s1 = Aron.sortStr(subStr);
                if(s1.equals(sortNeedle)){
                    list.add(i);
                }
                Print.pbl(subStr);
            }
        }
        return list;
    }
} 


import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

class MyNode{
    String data;
    int count;
    public MyNode(String data, int count){
        this.data = data;
        this.count = count;
    }
}

class TextMap{

    public TextMap(){
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }
}

public class AnimalLogic{
    public static void main(String[] args) {
//        test0();
//        test1();
        //test2();
//        test3();
//        test4();
//        test5();
//        test00();
//        test11();
//        test12();
        test13();
    }

    static void test00(){
        Aron.beg();
        
        int n = random(1);
        Print.pbl("n=" + n);

        for(int i=0; i<10; i++){
            int n1 = random(2);
            Print.pbl("n1=" + n1);
        }

        Aron.end();
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public static void test12(){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }

    public static void test13(){
        Aron.beg();

        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        Map<Map<String, String>, Map<Integer, String>> revMap = createBiMap(map);

        String seedFirst = "one";
        String seedSecond = "two";
        int numWords = 10;
        List<String> wordList = generateText(numWords, seedFirst, seedSecond, map, revMap);
        Aron.printList(wordList);
    }

    public static List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }

//    public static Map<String, String> newKeyMap(Map<String, String> map, String newWord){
//        map.get
//    }

    public static Map<Map<String, String>, Map<Integer, String>> createBiMap(Map<Map<String, String>, Map<String, Integer>> map){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 
        return revMap;
    }

    public static void test11(){
        Aron.beg();
        String[] arr = {"dog", 
                        "cat", 
                        "cow", 
                        "dog", 
                        "cat", 
                        "cow", 
                        "rat", 
                        "pig"}; 

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();

        List<String> list = getWords("./text/animal_logic.txt"); 
        //Map<Map<String, String>, Map<String, Integer>> map = createMap(arr); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }


    public static Map<Map<String, String>, Map<String, Integer>> createMap(List<String> list){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        for(int i=0; i<list.size() - 2; i++){
            Map<String, String> key = new HashMap<String, String>(); 
            Map<String, Integer> value = new HashMap<String, Integer>(); 
            key.put(list.get(i), list.get(i+1)); 
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key); 
            if(v == null){
                map.put(key, value);
            }else{
                Integer n = v.get(list.get(i+2));
                if(n == null){
                    v.put(list.get(i+2), 1);
                }else{
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    public static Map<Map<String, String>, Map<String, Integer>> createMap(String[] arr){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        List<String> list = Arrays.asList(arr); 
        map = createMap(list);
        return map;
    }
    public static void test0(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");

        String fileName = "text/myfile.txt";
        List<String> list = getWords(fileName); 

        for(String s : list){
            List<String> pairList = pair(s); 
            for(String k : pairList){
                if(map.containsKey(k)){
                    int count = map.get(k);
                    count++;
                    map.put(k, count);
                }else{
                    map.put(k, 1);
                }
            }
        }
        
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " , " + entry.getValue() + "]");
        } 
        
        Aron.printList(list);

        Aron.end();
    }
    public static List<String> pair(String s){
        List<String> list = new ArrayList<String>(); 
        if(s.length() > 1){
            for(int k=0; k < s.length(); k++){
                for(int i=0; i < s.length()-(1 + k); i++){
                    list.add(s.substring(i, i+(2 + k)));
                }
            }
        }
        return list;
    }

    // read a text file capture all words
    // word: non-whitespace char 
    public static List<String> getWordsNonWhiteSpace(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)\\S+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // read a text file and capture all words
    // word: a-z char
    public static List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }
    public static void test1(){
        Aron.beg();
        
        String[] arr = {
            "dog",
            "cat",
            "key-value"
        };
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");
        for(String s : arr){
            Matcher matcher = pattern.matcher(s);
            if(matcher.find()){
                Print.pbl("match word=" + matcher.group());
            }
        }

        Aron.end();
    }

    public static void test2(){
        Aron.beg();
                
        String fileName = "text/textfile.txt";
        List<String> list = getWordsNonWhiteSpace(fileName);
        Aron.printList(list);

        Aron.end();
    }

    public static void test3(){
        Aron.beg();
        String s = "abc";                
        int len = s.length();

            // "abc" [ "" -> "abc"]
            //       [ "a" -> "bc"]
            //       [ "ab"-> "c" ]
            for(int j=0; j<len-1; j++){
                    String prefix = s.substring(0, j);
                    String suffix = s.substring(j, len);
                    Print.pbl("prefix=" + prefix);
                    Print.pbl("suffix=" + suffix);
            }

        Aron.end();
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public static Map<Integer, String> inverseMap(Map<String, Integer> map){

        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        return revMap;
    }
    public static void test5(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        Map<Integer, String> revMap = inverseMap(map); 

        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        Aron.end();
    }

    public static void test4(){
        Aron.beg();
        String s = "abc";                
        
        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        
        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        // 1 -> k1
        // 2 -> k2
        // 3 -> k2

        Aron.end();
    }
} 

import java.io.File;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextAreaBuilder;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBoxBuilder;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Dialog;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;


// Markov chain algorithm, markov chain generate text, random text, rand text, 
// random markov chain text
//
// java javafx, javaui, java ui, java ui api, javafx ui, javafx api
// javafx textarea textfield, javafx messagebox, javafx control, javavx vbox hbox, javafx button
// animal logic task, animal logic project, animallogic, animal_logic task
final class TextMap {
    String fileName;
    Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
    Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
    public TextMap() { }
    public TextMap(String fileName) {
        this.fileName = fileName;
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords() {
        //Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");

        List<String> wordList = new ArrayList<String>();
        List<String> list = readFile(fileName);
        for(String s : list) {
            String[] arr = s.split("\\s+");
            for(String str : arr) {
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()) {
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // read file line by line to list
    public List<String> readFile(String fileName) {
        List<String> list = new ArrayList<String>();
        try {
            BufferedReader in = new BufferedReader(new FileReader(fileName));
            String str;
            while((str = in.readLine()) != null) {
                list.add(str.trim());
            }
            in.close();
        } catch(IOException io) {
            io.printStackTrace();
        }
        return list;
    }


    // generate map from prefix -> suffix, e.g.  <my, dog> -> <is, 1>
    public Map<Map<String, String>, Map<String, Integer>> prefixSuffixMap(List<String> list) {
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
        for(int i=0; i<list.size() - 2; i++) {
            Map<String, String> key = new HashMap<String, String>();
            Map<String, Integer> value = new HashMap<String, Integer>();
            key.put(list.get(i), list.get(i+1));
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key);
            if(v == null) {
                map.put(key, value);
            } else {
                Integer n = v.get(list.get(i+2));
                if(n == null) {
                    v.put(list.get(i+2), 1);
                } else {
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    // generate number [1...n]
    public int random(int n) {
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    // generate list of words from prefix, suffix
    public List<String> generateText(int numWords, String prefix, String suffix, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> reverseFreMap) {
        List<String> list = new ArrayList<String>();

        // clean up prefix and suffix, e.g. trim white-space
        String[] arr = prefix.split("\\s+");
        List<String> inputList = new ArrayList<String>();
        for(String s : arr) {
            if(s.trim().length() > 0)
                inputList.add(s);
        }

        String inputSuffix = suffix.trim();
        if(inputList.size() == 2) {
            String firstPrefix = inputList.get(0);
            String secondPrefix = inputList.get(1);
            list.add(firstPrefix);
            list.add(secondPrefix);
            list.add(inputSuffix);

            firstPrefix = secondPrefix;
            secondPrefix = inputSuffix;
              while(true){
                Map<String, String> key = new  HashMap<String, String>();
                key.put(firstPrefix, secondPrefix);

                Map<String, Integer> value = map.get(key);

                if(value != null) {
                    Map<Integer, String> revValueMap = reverseFreMap.get(key);
                    if(revValueMap != null) {
                        int ranKey = random(revValueMap.size());
                        String newSuffix = revValueMap.get(ranKey);
                        firstPrefix = secondPrefix;
                        secondPrefix= newSuffix;
                        list.add(newSuffix);

                        if(list.size() >= numWords){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }
        return list;
    }

    // generate map: <prefix, suffix> -> <frequency, word>
    public Map<Map<String, String>, Map<Integer, String>>  reverseFrequencyMap(Map<Map<String, String>, Map<String, Integer>> map) {
        Map<Map<String, String>, Map<Integer, String>> tableMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Map<Integer, String> rmap = inverseMap(value);
                tableMap.put(key, rmap);
            }
        }
        return tableMap;
    }

    public List<String> textGeneMap() {
        List<String> list = getWords();
        map = prefixSuffixMap(list);

        List<String> retList = new ArrayList<String>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            String str = "";
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                str += keyEntry.getKey() + " " + keyEntry.getValue() + " => ";

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    str += valueEntry.getKey()  + "[" + valueEntry.getValue() + "] ";
                }
                str += "\n";
            }
            retList.add(str);
        }
        return retList;
    }

    // generate list of words from user inputs: maximum number of words, prefix, and suffix
    public List<String> processFile(int maxWords, String prefix, String suffix) {
        revMap = reverseFrequencyMap(map);
        List<String> listWords= generateText(maxWords, prefix, suffix, map, revMap);
        return listWords;
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public Map<Integer, String> inverseMap(Map<String, Integer> map) {

        Map<Integer, String> rMap = new HashMap<Integer, String>();
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            Integer n = entry.getValue();

            int init = k;
            while(k < init + n) {
                rMap.put(k, entry.getKey());
                k++;
            }
        }
        return rMap;
    }
}

public class AnimalLogicTask  extends Application {
    String fileName = null;
    TextMap textMap = new TextMap();
    final int numCharLine = 10;
    public static void main(String[] args) {
        launch(args);
    }

    public boolean isNumeric(String str) {
        return str.matches("[1-9][0-9]*|0");
    }
    @Override
    public void start(final Stage primaryStage) {
        Group root = new Group();

        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("Error");
        TextArea textArea = new TextArea();
        TextArea textTable = new TextArea();
        textArea.setMinSize(500,500);
        textTable.setMinSize(500,500);

        TextField selectedFileTF = new TextField();
        selectedFileTF.setEditable(false);
        selectedFileTF.setPrefWidth(200);
        Button buttonLoad = new Button("Select File");
        Button buttonGeneText= new Button("Generate Text");

        HBox hboxField = new HBox();
        hboxField.setAlignment(Pos.CENTER);
        hboxField.setPadding(new Insets(1, 1, 1, 1));
        hboxField.getChildren().add(textTable);
        hboxField.getChildren().add(textArea);

        VBox box = new VBox();
        box.setAlignment(Pos.TOP_CENTER);
        box.setSpacing(5);
        box.getChildren().add(hboxField);

        HBox hboxTextField1 = new HBox();
        HBox hboxtextField2 = new HBox();
        hboxTextField1.setAlignment(Pos.CENTER);
        hboxTextField1.setSpacing(20);

        Label prefixLable = new Label("Prefix:");
        Label suffixLable = new Label("Suffix:");
        Label maxWordsLable = new Label("Maximum Words:");

        TextField prefixTF = new TextField ();
        TextField suffixTF = new TextField ();
        TextField maxWordsTF = new TextField ();


        buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                FileChooser fileChooser = new FileChooser();
                FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("TXT files (*.txt)", "*.txt");
                fileChooser.getExtensionFilters().add(extFilter);

                File file = fileChooser.showOpenDialog(primaryStage);

                if(file != null) {
                    fileName = file.getAbsolutePath();

                    if(fileName != null) {
                        textMap = new TextMap(fileName);
                        selectedFileTF.setText(file.getName());

                        List<String> textList = textMap.textGeneMap();
                        textTable.clear();
                        for(String s : textList) {
                            textTable.appendText(s + " ");
                        }
                    }
                } 
            }
        });

        buttonGeneText.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                if(fileName != null) {

                    String[] prefixArr = prefixTF.getText().trim().split("\\s+");
                    String[] suffixArr = suffixTF.getText().trim().split("\\s+");
                    if(prefixArr.length == 2 && suffixArr.length == 1) {
                        if(isNumeric(maxWordsTF.getText().trim())) {
                            Integer maxWords = Integer.valueOf(maxWordsTF.getText().trim());
                            List<String> wlist = textMap.processFile(maxWords, prefixTF.getText(), suffixTF.getText());

                            textArea.clear();

                            int count = 0;
                            for(String s : wlist) {
                                if((count % numCharLine)  + 1 == numCharLine)
                                    textArea.appendText(s + "\n");
                                else
                                    textArea.appendText(s + " ");

                                count++;
                            }
                        } else {
                            alert.setHeaderText("Maximum Words: invalid input");
                            alert.setContentText("Maximum Words field must be an integer.");
                            alert.showAndWait();
                        }
                    }else{
                        alert.setHeaderText("Invalid Prefix or Suffix");
                        alert.setContentText("Prefix must be two words\n Suffix must be one word");
                        alert.showAndWait();
                    }
                }else{
                    alert.setHeaderText("Invalid file");
                    alert.setContentText("Please select a valid text file.");
                    alert.showAndWait();
                }

            }
        });

        HBox lbtTFBox1 = new HBox();
        HBox lbtTFBox2 = new HBox();
        HBox lbtTFBox3 = new HBox();

        lbtTFBox1.getChildren().addAll(prefixLable, prefixTF);
        lbtTFBox1.setSpacing(2);
        lbtTFBox1.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox1.setStyle("-fx-background-color: #EEEEEE;");


        lbtTFBox2.getChildren().addAll(suffixLable, suffixTF);
        lbtTFBox2.setSpacing(2);
        lbtTFBox2.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox2.setStyle("-fx-background-color: #EEEEEE;");

        lbtTFBox3.getChildren().addAll(maxWordsLable, maxWordsTF);
        lbtTFBox3.setSpacing(2);
        lbtTFBox3.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox3.setStyle("-fx-background-color: #EEEEEE;");

        hboxTextField1.getChildren().addAll(lbtTFBox1);
        hboxTextField1.getChildren().addAll(lbtTFBox2);
        hboxTextField1.getChildren().addAll(lbtTFBox3);

        box.getChildren().addAll(hboxTextField1);

        HBox fileBox = new HBox();
        fileBox.setAlignment(Pos.CENTER);
        fileBox.setSpacing(2);
        fileBox.getChildren().addAll(buttonLoad, selectedFileTF);
        box.getChildren().add(fileBox);

        box.getChildren().add(buttonGeneText);
        primaryStage.setScene(new Scene(box, 1000, 800));
        primaryStage.show();
    }
}
import java.util.*;
import java.io.*;
import java.util.List;
import java.util.function.Predicate;
import java.util.ArrayList;

import classfile.*;

class Employee {
    public int id;
    public String name;
    public int sal;
    public Employee(int id,String name,int sal  ) {
        this.id = id;
        this.name = name;
        this.sal = sal;
    }
    public static List<Employee> getEmpList() {
        List<Employee> list = new ArrayList<>();
        list.add(new Employee(1, "A", 2000));
        list.add(new Employee(2, "B", 3000));
        list.add(new Employee(3, "C", 4000));
        list.add(new Employee(4, "D", 5000));
        return list;
    }
}

public class AnyMatch {
    public static void main(String[] args) {
        Predicate<Employee> p1 = e -> e.id < 10 && e.name.startsWith("A");
        Predicate<Employee> p2 = e -> e.sal < 10000;
        List<Employee> list = Employee.getEmpList();
        //using allMatch
        boolean b1 = list.stream().allMatch(p1);
        System.out.println(b1);
        boolean b2 = list.stream().allMatch(p2);
        System.out.println(b2);
        //using anyMatch
        boolean b3 = list.stream().anyMatch(p1);
        System.out.println(b3);
        boolean b4 = list.stream().anyMatch(p2);
        System.out.println(b4);
        //using noneMatch
        boolean b5 = list.stream().noneMatch(p1);
        System.out.println(b5);
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class AutoComplete{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        List<String> list = Arrays.asList("cat", "cow"); 
        Map<String, List<String>> map = autocomplete(list);
        Aron.printMap(map);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        List<String> list = Arrays.asList("cat", "cow", "ban", "ball", "banana", "b"); 
        Map<String, List<String>> map = autocomplete(list);
        Aron.printMap(map);

        Aron.end();
    }

    //[ file=autocomplete.html title=""
    // auto complete, autocomplete
    // 1:01 - 1:34
    //-------------------------------------------------------------------------------- 
    // cat
    // cow
    // c -> [at, ow]
    // ca ->[t]
    // co ->[w] 
    public static Map<String, List<String>> autocomplete(List<String> list){
        Map<String, List<String>> map = new HashMap<>();
        for(String s : list){
            int len = s.length();
            for(int i=0; i<len; i++){
                String prefix = s.substring(0, i);
                String suffix = s.substring(i, len);

                if(prefix.length() > 0){
                    List<String> l = map.get(prefix);
                    if( l != null){
                        l.add(suffix);
                        map.put(prefix, l);
                    }else{
                        List<String> ll = new ArrayList<>();
                        ll.add(suffix);
                        map.put(prefix, ll);
                    }
                }
            }
        }
        return map;
    }
    //]


}

import java.util.*;
import classfile.*;

class BSTDict{
    public Node root;
    public BSTDict() {
        root = null;
    }

    public void insert(int n) {
        if(root == null) {
            root = new Node(n);
        } else {
            Node curr = root;
            boolean end = false;
            while(curr != null && !end) {
                if(n < curr.data) {
                    if(curr.left == null) {
                        curr.left = new Node(n);
                        end = true;
                    } else
                        curr = curr.left;
                } else {
                    if(curr.right == null) {
                        curr.right = new Node(n);
                        end = true;
                    } else
                        curr = curr.right;
                }
            }
        }
    }
    public void OneQueue(Node curr) {
        if(curr != null) {
            Queue<Node> q = new LinkedList<Node>();
        }
    }
    public void inorder(Node curr) {
        if(curr != null) {
            inorder(curr.left);
            System.out.println("[" + curr.data + "]");
            inorder(curr.right);
        }
    }
    public boolean findNode(int n) {
        Node curr = root;
        boolean ret = false;
        if(curr != null) {
            if(n < curr.data)
                curr = curr.left;
            else if(n > curr.data)
                curr = curr.right;
            else
                ret = true;
        }
        return ret;
    }
    public boolean findSum(Node r, int n) {
        boolean ret = false;
        if(r == null) {
            if(n == 0)
                ret = true;
        } else if(r != null) {
            boolean bl = findSum(r.left, n - r.data);
            boolean br = findSum(r.right, n - r.data);
            ret = (bl || br);
        }
        return ret;
    }
}

public class BSTDictionary{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();

        String str1 = "tenny";
        String str2 = "tea";
        String str3 = "ten";
        String str4 = "tee";
        Print.p(str1.hashCode());
        Print.p(str2.hashCode());
        Print.p(str3.hashCode());
        Print.p(str4.hashCode());

        BSTDict bst = new BSTDict();
        bst.insert(str1.hashCode());
        bst.insert(str2.hashCode());
        bst.insert(str3.hashCode());
        bst.insert(str4.hashCode());
        
        Aron.end();
    }
}

import java.io.*;
import java.lang.String;
import java.util.*;

// preorder to inorder
// convert preorder to inorder
class Node {
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST {
	Node root;
	public BST()
	{ root = null;};
	public void insert(int n) {
		if(root == null) { 
            root = new Node(n); 
        }
		else { 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end) {
				if(n < cur.data) { 
					if(cur.left == null) { 
                        cur.left = new Node(n);  
                        break;
                    }
                    else 
                        cur = cur.left;
				}else {
					if(cur.right == null) { 
                        cur.right = new Node(n); 
                        break;
                    }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur) {
		if(cur != null) {
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public boolean Find(int n) {
		Node cur = root;
		boolean ret = false;
		if(cur != null) {
			if(n < cur.data)
				cur = cur.left;
			else if(n > cur.data)
				cur = cur.right;
			else
				ret = true;
		}
		return ret;
	}
	public boolean findSum(Node r, int n) {
		boolean ret = false;
		if(r == null) { 
			if(n == 0)
				ret = true;
		}
		else if(r != null) {
			boolean bl = findSum(r.left, n - r.data);
			boolean br = findSum(r.right, n - r.data);
			ret = (bl || br);
		}
		return ret;
	}
	
	public void LevelOrder() {
		Node cur = root;
		Queue<Node> Q1 = new LinkedList<Node>();
		Queue<Node> Q2 = new LinkedList<Node>();
		Q1.offer(cur);
		while(Q1.peek() != null || Q2.peek() != null) {
			while(Q1.peek() != null) {
				Node top = Q1.poll();
				System.out.print(top.data + " ");
				if(top.left != null)
					Q2.offer(top.left);
				if(top.right != null)
					Q2.offer(top.right);
			}
			System.out.println();
			while(Q2.peek() != null) {
				Node top = Q2.poll();
				
				System.out.print(top.data + " ");
				if(top.left != null)
					Q1.offer(top.left);
				if(top.right != null)
					Q1.offer(top.right);
			}
			System.out.println();
		}
	}
	public Node getRoot() { 
        return root;
    }
}
class BSTfromPreOrderInOrder {
	public static void main(String args[]) {
		int[] pArr = {10, 5, 1, 7, 15, 12, 20};
		int[] iArr = {1, 5, 7, 10, 12, 15, 20};
		
		ArrayList<Node> preArr = new ArrayList<Node>();
		ArrayList<Node> inArr = new ArrayList<Node>();
		for(int i=0; i<pArr.length; i++) {
			preArr.add(new Node(pArr[i]));
			inArr.add(new Node(iArr[i]));
		}
		Node root = buildBST(preArr, inArr);
		Inorder(root);

	}
	public static void split(ArrayList<Node> preArr, ArrayList<Node> inArr, ArrayList<Node> preL_tree,ArrayList<Node> preR_tree,ArrayList<Node> inL_tree, ArrayList<Node> inR_tree) {
	if(preArr != null && inArr != null && preL_tree != null && preR_tree != null && inL_tree != null && inR_tree != null) {
			int prelen = preArr.size(), inlen = inArr.size();	
			if(prelen > 0) {
				boolean L = true;
				Node root = preArr.get(0);
				for(int i=0; i<inlen; i++) {
					if(L == true && inArr.get(i).data != root.data)
						inL_tree.add(inArr.get(i));
					else if(inArr.get(i).data == root.data)
						L = false;
					else if(L == false && inArr.get(i).data != root.data) {
						inR_tree.add(inArr.get(i));
					}
				}
				for(int i=1; i<prelen; i++) {
					if(i < (inL_tree.size() + 1))
						preL_tree.add(preArr.get(i));	
					else
						preR_tree.add(preArr.get(i));	
				}
			}
		}
	}	

	public static Node buildBST(ArrayList<Node> preArr, ArrayList<Node> inArr) {
		Node parent = null;
		if( preArr != null && inArr != null) {
			int prelen = preArr.size(), inlen= inArr.size();
			if(prelen > 0) {
				parent = new Node(preArr.get(0).data);
				ArrayList<Node> preL_tree = new ArrayList<Node>();
				ArrayList<Node> preR_tree = new ArrayList<Node>();

				ArrayList<Node> inL_tree = new ArrayList<Node>();
				ArrayList<Node> inR_tree = new ArrayList<Node>();
				split(preArr, inArr, preL_tree, preR_tree, inL_tree, inR_tree);
				parent.left 	= buildBST(preL_tree, inL_tree);
				parent.right 	= buildBST(preR_tree, inR_tree);
			}
		}
		return parent;
	}	

	public static void Inorder(Node root) {
		if(root != null) {
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

// select dep.name from Department where id = 100 
// select dep.id   from Department where name = "David"
class Department{
    Map<Integer, String> map;
    public Department(Map<Integer, String> map){
        this.map = map;
    }
}

class DB{

}

public class BaiduDatabase{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;

public class BalanceBracket 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        String s = "[12(3)4[5)]";
        char prev = 'a';
        int[] arr = new int[1];
        arr[0] = 0;
        boolean ret = balanceBracket(s);
        System.out.println("ret="+ret);
    }
    public static boolean balanceBracket(String s)
    {
        boolean ret = true;
        Stack<Character> stack = new Stack<Character>();        
        if(s != null)
        {
            for(int i=0; i<s.length(); i++)
            {
                char ch = s.charAt(i);
                if(ch == '[' || ch == '(')
                {
                    stack.push(ch);
                }
                else if(ch == ']' || ch == ')')
                {
                    Character left = stack.pop();
                    if(!(left == '[' && ch == ']' || left == '(' && ch == ')'))
                        ret = false;
                }
                else if(!('0' <= ch && ch <= '9'))
                {
                    ret = false;
                }

            }
            if(!stack.empty())
                ret = false;
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class BinDeleteNode{
    static Node prevNode = null;
    public static void main(String[] args) {
//        test9();
//        test10();
//        test11();
//        test12();
//        test13();
        test14();
    }
    
    static void test9(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 15;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test10(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 10;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test11(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        int n = 7;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test12(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 10;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test13(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 12;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test14(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 10;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test15(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 13;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }


    public static Node findMin(Node r){
        Node curr = r;
        while(r != null && curr.left != null){
            curr = curr.left;
        }
        return curr;
    }

    // gf http://quiz.geeksforgeeks.org/binary-search-tree-set-2-delete/
    public static Node delete(Node r, int n){
        if(r != null){
            if(n < r.data)
                r.left = delete(r.left, n);
            else if(n > r.data)
                r.right = delete(r.right, n);
            else{
                if(r.left == null)
                    return r.right;
                else if(r.right == null)
                    return r.left;
                else{
                    Node min = findMin(r.right);
                    r.data = min.data;
                    r.right = delete(r.right, min.data);
                }

            }
            return r;
        }
        return null;
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class BinDict{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    static void test0(){
        Aron.beg();
        BST bst = new BST();

        // read dictionary file
        List<String> list = Aron.readFile("text/words.txt"); 

        // add dictionary file to list
        int count = 0;
        while(count < list.size()){
            Random ran = new Random();
            int index = ran.nextInt(list.size());
            //Print.p("index=[" + index + " " + list.size());
            bst.insert(list.indexOf(index));
            list.remove(index);
            //Print.p(list.indexOf(index));
        }

          Aron.inorder(bst.root);
//        Test.t(bst.contains("cat".hashCode()));
//
//        Print.pl("level=" + Aron.level(bst.root));

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(1);
        bst.insert(2);
        bst.insert(3);

        Test.t(Aron.height(bst.root) == 2);
        Test.t(Aron.level(bst.root) == 3);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        
        Aron.end();
    } 
} 
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

//[ file=binite.html title=""
// binary iterator
class BinaryIterator {
    Node curr;
    Stack<Node> stack;
    public BinaryIterator(Node root) {
        curr = root;
        stack = new Stack<Node>();
    }

    public boolean hasNext() {
        return (curr != null || stack.isEmpty() == false);
    }

    public Node next() {
        while(hasNext()) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.pop();
                curr = node.right;
                return node;
            }
        }
        return null;
    }
}
//]

public class BinIterator {
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    
    static void test0() {
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);

        BinaryIterator bi = new BinaryIterator(bst.root);
        System.out.println("\n---------------------------------");
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------");
        while(bi.hasNext()) {
            System.out.println("[" + bi.next().data + "]");
        }
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);

        BinaryIterator bi = new BinaryIterator(bst.root);
        System.out.println("\n---------------------------------");
        Aron.inorder(bst.root);
        System.out.println();
        while(bi.hasNext()) {
            System.out.println("[" + bi.next().data + "]");
        }
        Aron.end();
    }
    static void test2() {
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(20);
        bst.insert(18);

        BinaryIterator bi = new BinaryIterator(bst.root);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------");
        while(bi.hasNext()) {
            System.out.println("[" + bi.next().data + "]");
        }
        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class BinToCircularDll 
{

	public static void main(String args[])
	{
		BST b1 = new BST();


		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);

		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
        
		Node r = b1.getRoot();
		//Node t = BinToDLL(r);
        Inorder(r);
        System.out.println("");
        BinToCircularDll(r);
        int k=0;
        if(head != null)
        {
            Node curr = head;
            Node right = head.right;
            if(curr == right) //one node
                System.out.print(curr.data + " ");
            else
            {
                System.out.print(head.data + " ");
                while(head != right)
                {
                    System.out.print(right.data + " ");
                    right = right.right;
                }
            }
        }
	}

    static Node head = null;
    static Node prev = null;
    public static void BinToCircularDll(Node curr)
    {
        if(curr != null)
        {
            BinToCircularDll(curr.left);
            if(prev == null)
                head = curr;
            else
            {
                prev.right = curr;
                curr.left = prev;
            }
            prev = curr;
            Node right = curr.right;
            if(head != null)
            {
                head.left = curr;
                curr.right = head;
            }
            BinToCircularDll(right);
        }
    }


    public static void Inorder(Node r)
    {
        if(r != null)
        {
            Inorder(r.left);
            System.out.print("["+r.data+"]");
            Inorder(r.right);
        }
    }
	public static Node BinToDLL(Node r)
	{
		Node h=null, t=null, cur=null;
		Queue<Node> queue = new LinkedList<Node>();
		if(r != null)
		{
			queue.offer(r);
			while(queue.peek() != null)
			{
				Node no = queue.remove();
				if(no != null && no.left != null)
				{queue.offer(no.left); no.left=null;}

				if(no != null && no.right!= null)
				{queue.offer(no.right); no.right=null;}

				if(h == null)
				{ h = cur = no; }
				else 
				{ no.left = cur;
					cur.right = no;
					cur = cur.right;
				}
			}
			t = cur;
		}
		return t;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	
	
	public Node getRoot()
	{ return root;}
}
class BinToDLLRecur 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(1);
		b1.Insert(2);
		b1.Insert(3);
		b1.Insert(4);
		b1.Insert(5);
		b1.Insert(6);
		b1.Insert(7);
		b1.Insert(8);
		b1.Inorder(b1.getRoot());

		Node r = BinToDLL(b1.getRoot());
		boolean bool = isCircularList(r);
		System.out.println("bool=" + bool);
        Node first = r;
        Node left = r.left;
        while( first != left)
        {
		    System.out.println("left=" + left.data);
            left = left.left;
        }

	}
	public static boolean isCircularList(Node r)
	{
		boolean ret = false;
		if(r != null)
		{
			Node cur = r;
			Node next = cur.right;

			while(next != null && cur != next)
			{
				System.out.print("cur="+cur.data + " ");
				if(cur != null)
				cur = cur.right;
				
				next = next.right;
				if(next != null)
					next = next.right;
			}
			if(cur == next)
			{
				System.out.print("cur="+cur.data + " ");
				ret = true;
			}
		}
		return ret;
	}
    
    //convert bst to double
	static Node prev=null;
	static Node head=null;
	public static Node BinToDLL(Node r)
	{
		if(r != null)
		{
			BinToDLL(r.left);
			
			if(prev != null)
			{ 
                prev.right= r;
            }
			else
				head = r;
			r.left = prev;
            prev = r;
			Node right = r.right;

            if(head != null)
                head.left = r;
			r.right = head;

			BinToDLL(right);
		}
		return head;
	}
	public static boolean isBST(Node r)
	{

		if(r == null)
			return true;
		else
		{
			if(!isBST(r.left))
				return false;
			if(prev != null && prev.data >= r.data)
				return false;
			prev = r;
			if(!isBST(r.right))
				return false;
		}
		return true;
	}
	public static boolean equalBinaryTree(Node r1, Node r2)
	{
		if(r1==null && r2==null)
			return true;
		else if(r1 != null && r2 != null)
		{
			if(r1.data != r2.data)
					return false;
			if(!equalBinaryTree(r1.left, r2.left)) 
					return false;
			if(!equalBinaryTree(r1.right, r2.right))
					return false;
		}
		else 
			return false;
		return true;
	}
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class Pair {
    Queue<Integer> queue = new LinkedList<Integer>();
    int index;
    public Pair() {
        index = -1;
    }
}

class BinarySearch {
    public static void main(String args[]) {
        Test1();
        Test2();
        Test3();
        Test4();
        test5();
        test6();
    }
    static void test5(){
        Aron.beg();

        int[] arr = {0, 2, 3, 5};
        int lo = 0;
        int hi = arr.length - 1;
        int key = 6;
        List<Integer> list = new ArrayList<Integer>(); 

        BinSearchBetween(arr, lo, hi, key, list);
        Aron.printList(list);

        Aron.end();
    } 
    static void test6(){
        Aron.beg();

        int[] arr = {-Integer.MAX_VALUE, 0, 2, 3, 5, Integer.MAX_VALUE};
        int lo = 0;
        int hi = arr.length - 1;
        int key = -1;
        List<Integer> list = new ArrayList<Integer>(); 

        BinSearchBetween(arr, lo, hi, key, list);
        Aron.printList(list);

        Aron.end();
    } 

    public static void BinSearchIndex(int[] arr, int left, int right, int key, Pair pair) {
        if(arr != null && left <= right) {
            int middle = (left + right)/2;
            if(key < arr[middle]) {
                if(pair.queue.size() >= 2)
                    pair.queue.remove();
                pair.queue.add(middle-1);

                BinSearchIndex(arr, left, middle - 1, key, pair);
            } else if(key > arr[middle]) {
                if(pair.queue.size() >= 2)
                    pair.queue.remove();
                pair.queue.add(middle+1);

                BinSearchIndex(arr, middle + 1, right, key, pair);
            } else
                pair.index = middle;
        }
    }

    public static boolean BinSearch(int[] arr, int left, int right, int key) {
        boolean ret = false;
        if(arr != null && left <= right) {
            int middle = (left + right)/2;
            if(key < arr[middle]) {
                ret = BinSearch(arr, left, middle - 1, key);
            } else if(key > arr[middle]) {
                ret = BinSearch(arr, middle + 1, right, key);
            } else
                ret = true;
        }
        return ret;
    }
    public static boolean BinSearchBetween(int[] arr, int left, int right, int key, List<Integer> list) {
        boolean ret = false;
        if(arr != null && left <= right) {
            int middle = (left + right)/2;
            list.add(middle);

            if(key < arr[middle]) {
                ret = BinSearchBetween(arr, left, middle - 1, key, list);
            } else if(key > arr[middle]) {
                ret = BinSearchBetween(arr, middle + 1, right, key, list);
            } else
                ret = true;
        }
        return ret;
    }


    public static void Test1() {
        int[] arr = {1, 2, 3, 5};
        int left = 0;
        int right = arr.length - 1;
        int key = 1;
        boolean ret = BinSearch(arr, left, right, key);
        System.out.println(ret);
    }

    public static void Test2() {
        int[] arr = {1};
        int left = 0;
        int right = arr.length - 1;
        int key = 1;
        boolean ret = BinSearch(arr, left, right, key);
        System.out.println(ret);
    }

    public static void Test3() {
        int[] arr = {2};
        int left = 0;
        int right = arr.length - 1;
        int key = 1;
        boolean ret = BinSearch(arr, left, right, key);
        System.out.println(ret);
    }

    public static void Test4() {
        int[] arr = {0, 2, 3, 5};
        int left = 0;
        int right = arr.length - 1;
        int key = 6;
        Pair pair = new Pair();

        BinSearchIndex(arr, left, right, key, pair);
        for(Integer p:pair.queue) {
            System.out.println("p="+p);
        }
        System.out.println("index="+pair.index);
    }
}

//Binary search in two dimension is based on one dimension search
public class BinarySearch2D 
{
    public static void main(String[] args)
    {
        Test1();
        Test2();
    }

    public static void printArray(int[][] array, int height, int width)
    {
        for(int col=0; col<=height; col++)
        {
            for(int row=0; row<=width; row++)
            {
                System.out.print("["+array[col][row]+"]");
            }
            System.out.println();
        }
    }
    public static void Test1()
    {
        System.out.println("Binary search in two dimension");
        int[][] array = {{1,  100, 200, 201},
                         {5,  105, 205, 1000},
                         {11, 107, 300, 1001},
                         {13, 108, 302, 1002},
                         {104,301, 305, 1003}};
        int key = 201;
        int rlo = 0;
        int rhi = array[0].length-1;
        int clo = 0;
        int chi = array.length-1;
        printArray(array, chi, rhi);

        boolean ret2 = BinSearch2D(array, clo, rlo, chi, rhi, key);
        System.out.println("ret2="+ret2);

        boolean ret3 = binSearchMN(array, clo, rlo, chi, rhi, key);
        System.out.println("ret3="+ret3);
    }

    public static void Test2()
    {
        System.out.println("Binary search in two dimension");
        int[][] array = {{203}};
        int key = 203;
        int rlo = 0;
        int rhi = array[0].length-1;
        int clo = 0;
        int chi = array.length-1;
        printArray(array, chi, rhi);

        boolean ret2 = BinSearch2D(array, clo, rlo, chi, rhi, key);
        System.out.println("ret2="+ret2);

        boolean ret3 = binSearchMN(array, clo, rlo, chi, rhi, key);
        System.out.println("ret3="+ret3);
    }

    //Binary search from top right corder, eliminate row/column algorithm 
    //Complexity O(m+n)
    public static boolean binSearchMN(int[][] array, int collo, int rowlo, 
                                                     int colhi, int rowhi, int key)
    {
        int width = rowhi - rowlo + 1;
        int height = colhi - collo + 1;
        int col = collo;
        int row = rowhi;
        for(int i=0; i<width+height; i++)
        {
            if(key < array[col][row])
            {
                if(row > rowlo)
                    row--;
            }
            else if(key > array[col][row])
            {
                if(col < colhi)
                    col++;
            }
            else 
                return true;
        }
        return false;
    }
    
    //Binary search: eliminate one quandrant in each step
    //Complexity O(lg(m)+lg(n))
    public static boolean BinSearch2D(int[][] array, int collo, int rowlo, 
                                                     int colhi, int rowhi, int key)
    {
        boolean ret = false;
        if(array != null)
        {
            int colm = (collo + colhi)/2;
            int rowm = (rowlo + rowhi)/2;
            if(collo <= colhi && rowlo <= rowhi)
            {
                if(key < array[colm][rowm])
                {
                    boolean b1 = BinSearch2D(array, collo, rowlo,
                                                  colm-1, rowm-1, key);
                    boolean b2 = BinSearch2D(array, collo, rowm,
                                                  colm-1,rowhi, key);
                    boolean b3 = BinSearch2D(array, colm, rowlo,
                                                  colhi, rowm-1, key);
                    ret = b1 || b2 || b3;
                }
                else if(key > array[colm][rowm])
                {
                    boolean b1 = BinSearch2D(array, colm+1, rowm+1,
                                                  colhi,  rowhi, key);
                    boolean b2 = BinSearch2D(array, collo, rowm+1,
                                                  colm,  rowhi, key);
                    boolean b3 = BinSearch2D(array, colm+1, rowlo,
                                                  colhi,  rowm, key);
                    ret = b1 || b2 || b3;
                }
                else
                    ret = true;
            }
        }
        return ret;
    } 
}
    //Binary search: eliminate one quandrant in each step
    //Complexity O(lg(m)+lg(n))
    public static boolean BinSearch2D(int[][] array, int collo, int rowlo, 
                                                     int colhi, int rowhi, int key)
    {
        if(array != null)
        {
            int colm = (collo + colhi)/2;
            int rowm = (rowlo + rowhi)/2;
            if(collo <= colhi && rowlo <= rowhi)
            {
                if(key < array[colm][rowm])
                {
                    boolean b1 = false, b2 = false, b3 = false;
                    b1 = BinSearch2D(array, collo, rowlo,
                                                  colm-1, rowm-1, key);

                    b2 = BinSearch2D(array, collo, rowm,
                                                  colm-1,rowhi, key);
                    b3 = BinSearch2D(array, colm, rowlo,
                                                  colhi, rowm-1, key);
                    return b1 || b2 || b3;
                }
                else if(key > array[colm][rowm])
                {
                    boolean b1 = false, b2 = false, b3 = false;
                    b1 = BinSearch2D(array, colm+1, rowm+1,
                                                  colhi,  rowhi, key);
                    b2 = BinSearch2D(array, collo, rowm+1,
                                                  colm,  rowhi, key);
                    b3 = BinSearch2D(array, colm+1, rowlo,
                                                  colhi,  rowm, key);
                    return b1 || b2 || b3;
                }
                else
                    return true;
            }
        }
        return false;
    } 
import java.io.*;
import java.lang.String;
import java.util.*;
class BinarySearchIteration 
{
	public static void main(String args[])
	{
		int[] Arr = {1, 2, 3, 5};
		int left = 0;
		int right = Arr.length - 1;
		int key = 5;
		int ret = BinSearch(Arr, left, right, key);
		System.out.println(ret);
	}
	public static int BinSearch(int[] Arr, int left, int right, int key)
	{
        int ret = -1;
        while(left <= right && ret == -1)
        {
            //int mid = (left + right)/2;
            int mid = left + (right - left)/2;
            if(Arr[mid] == key)
                ret = mid; 
            else if(Arr[mid] < key)
                left = mid + 1;
            else 
                right = mid -1; 
        }
		return ret;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import Lib.*;

class BinarySearchTree {
	public static Node prev = null;
	public static void main(String args[]) {
		BST b1 = new BST();

		b1.insert(15);
		b1.insert(12);
		
		b1.insert(14);
		b1.insert(17);
		b1.insert(19);
		b1.insert(130);
		b1.insert(16);
		b1.insert(10);
		
		int[] Arr = new int[100];
		int len=0;
		Node r = b1.getRoot();

		b1.LevelOrder();

		System.out.println(contain(r, 15));

        test1();
        test2();
        test3();
        test4();
        test5();
	}

    public static void kdistance(Node r, int k){
        if(r != null){
            if(k == 0)
                System.out.println(r.data);
            else{
                kdistance(r.left, k-1);
                kdistance(r.right, k-1);
            }
        }
    }

	public static boolean isBST(Node r) {
		if(r == null)
			return true;
		else {
			if(!isBST(r.left))
				return false;
			if(prev != null && prev.data >= r.data)
				return false;
			prev = r;
			if(!isBST(r.right))
				return false;
		}
		return true;
	}
	//init len = 0
	public static void printAllPath(Node r, int[] Arr, int len) {
		if( r != null && Arr != null) {
			Arr[len] = r.data;
			if( r.left == null && r.right == null) {
				for(int i=0; i<len+1; i++)
					System.out.print(Arr[i]+" ");
				System.out.println();
			}
			else {
				printAllPath(r.left, Arr, len+1);
				printAllPath(r.right, Arr, len+1);
			}
		}
	}
	public static int MaxDepth(Node r) {
		if( r != null) {
			int nl = MaxDepth(r.left);
			int nr = MaxDepth(r.right);

			return (nl>nr?nl:nr)+1;
		}
		return 0;
	}
	public static boolean equalBinaryTree(Node r1, Node r2)
	{
		if(r1==null && r2==null)
			return true;
		else if(r1 != null && r2 != null) {
			if(r1.data != r2.data)
					return false;
			if(!equalBinaryTree(r1.left, r2.left)) 
					return false;
			if(!equalBinaryTree(r1.right, r2.right))
					return false;
		}
		else 
			return false;
		return true;
	}
	public static void Inorder(Node root) {
		if(root != null) {
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
	public static boolean contain(Node r, int value) {
		if( r != null) {
			if(contain(r.left, value))
				return true;
			if(r.data == value)
				return true;
			if(contain(r.right, value))
				return true;
		}
		return false;
	}
    // 10 5 1_ _ 6_ _ 14 11 _
    // 10 _ _
    // 10 5_ _ 12_ _
    // int[] k = new int[1];
	public static Node generateBinaryTree(Node r, String[] list, int[] k) {
        if(k[0] < list.length && list[k[0]] != "_"){
            if(r == null)
                r = new Node(Integer.parseInt(list[k[0]]));
            k[0]++;
            r.left = generateBinaryTree(r.left, list, k);
            k[0]++;
            r.right = generateBinaryTree(r.right, list, k);
            return r;
        }
        return null;
    }

    public static void test5() {
        System.out.println("test5"); 
        BST b1 = new BST();
        int k = 2;
		b1.insert(15);
		b1.insert(5);
		b1.insert(20);
		b1.insert(30);
		Node r = b1.getRoot();
        kdistance(r, k);
    } 
    public static void test4() {
        System.out.println("test4"); 
        BST b1 = new BST();
        int k = 1;
		b1.insert(15);
		b1.insert(5);
		b1.insert(20);
		Node r = b1.getRoot();
        kdistance(r, k);
    } 
    public static void test3() {
        System.out.println("test3"); 
        BST b1 = new BST();
        int k = 0;
		b1.insert(15);
		Node r = b1.getRoot();
        kdistance(r, k);
    } 

    public static void test2() {
        System.out.println("test2"); 
        String[] list = {
            "10",
            "8",
            "_",
            "_",
            "12",
            "_",
            "19"
        };
        Node r = null;
        int[] k= new int[1];
        k[0] = 0;
        Node root = generateBinaryTree(r, list, k);
        Inorder(root);
    } 
    public static void test1() {
        System.out.println("test1"); 
        String[] list = {
            "10",
            "_",
            "_"
        };
        Node r = null;
        int[] k= new int[1];
        k[0] = 0;
        Node root = generateBinaryTree(r, list, k);
        Inorder(root);
    } 
}
	public static boolean BinSearch(int[] arr, int left, int right, int key)
	{
		boolean ret = false;
		if(arr != null && left <= right)
		{
			int middle = (left + right)/2;
			if(key < arr[middle])
			{
                ret = BinSearch(arr, left, middle - 1, key);
			}
			else if(key > arr[middle])
			{
                ret = BinSearch(arr, middle + 1, right, key);
			}
			else 
				ret = true;
		}
		return ret;
	}
import java.util.*;
class Node{
        int data;
        Node left;
        Node right;
    public Node(int data){
        this.data = data;
        left = null;
        right = null;
    }
}

class BinaryTree{
    Node root;
    public BinaryTree(){
        root = null;
    }
    public void insert(int data){
        if(root == null){
            root = new Node(data);
        }else{
            Node current = root;
            boolean end = false;
            while(!end){
                if(data < current.data){
                   if(current.left == null){
                       current.left = new Node(data);
                       end = true;
                   }else{
                       current = current.left; 
                   }
                }
                else{
                    if(current.right== null){
                       current.right= new Node(data);
                        end = true;
                    }
                    else{
                       current = current.right;
                    }
                }
            }
        } 
    }
    public void preorder(Node root)
    {
        if(root != null){
            System.out.println("preorder["+root.data+"]");
            preorder(root.left);
            preorder(root.right);
        }
    }

}

public class BinaryToArray 
{
    public static void main(String[] args)
    {
        BinaryTree bin = new BinaryTree();
        bin.insert(10);
        bin.insert(15);
        bin.insert(12);
        bin.insert(20);
        bin.insert(30);
            
        bin.preorder(bin.root);

        int[] Array = new int[20];
        System.out.println("Hello World!");
    }
    public void int[] BinaryToArray(Node root){
        
        Queue<Node> queue1 = new LinkedList<Node>();
        Queue<Node> queue2 = new LinkedList<Node>();
        if(root != null)
            queue1.offer(root);
        while(queue1.peek()){
            Node no = queue1.remove();
            if(no.left != null){
                queue2.offer(no.left);
            }
        }

    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	boolean visited;
	public Node(int n)
	{ data = n; left = null; right = null; visited=false;}
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class BoundryBinaryTree 
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(50);
        
		b1.Insert(39);
		b1.Insert(18);
		b1.Insert(35);
		b1.Insert(36);
		b1.Insert(41);
		b1.Insert(43);
        
        b1.Insert(51);
		b1.Insert(91);
		b1.Insert(76);
		b1.Insert(60);
		b1.Insert(99);
		b1.Insert(59);
		b1.Insert(58);

		
        
        System.out.println();
        PrintBoundry(b1.getRoot());
        System.out.println();
        Node right = null;
        //InorderLeftLeafNode(b1.getRoot(), right); 
        System.out.println();
        PrintBoundryWithInorder(b1.getRoot());
	}
	
    //Initialize right = null
    static boolean leaf = false;
    public static void InorderLeftLeafNode(Node curr)
    {
        if(curr != null)
        {
            if(!leaf)
                System.out.print("{" + curr.data + "}");
            if(curr.left == null && curr.right == null)
            {
                if(leaf)
                    System.out.print("[" + curr.data + "]");
                leaf = true;
            }
            InorderLeftLeafNode(curr.left);
            InorderLeftLeafNode(curr.right);
        }
    }
    public static void PrintBoundryWithInorder(Node curr)
    {
        InorderLeftLeafNode(curr);
        if(curr != null)
        {
            Node right = curr.right;
            Stack<Node> stack = new Stack<Node>();
            while(right != null)
            {
                if(right.left != null || right.right != null)
                {
                    stack.push(right);
                    //System.out.print("[" + right.data + "]");
                }
                right = right.right;
            }
            while(!stack.empty())
            {
                System.out.print("[" + stack.pop().data + "]");
            }
        }
            

    }
    public static void PrintBoundry(Node curr)
    {
        Stack<Node> st = new Stack<Node>();
        Set<Integer> hashset = new HashSet<Integer>();
        boolean first = false;
        Node root = curr;
        while(curr != null || !st.empty())
        {
            if(curr != null)
            {
                if(!first)
                {
                    System.out.println("[" + curr.data + "]");
                    hashset.add(curr.data);
                }
                st.push(curr);
                curr = curr.left;
            }
            else
            {
                if(!first)
                    first = true;
                Node node = st.pop();
                if(node.left == null && node.right == null)
                {
                    if(!hashset.contains(node.data))
                    {
                        System.out.println("[" + node.data + "]");
                        hashset.add(node.data);
                    }
                }
                curr = node.right;
            }
        }
        //Print out the nodes in the right side of the tree
        if(root != null)
        {
            Stack<Node> stack = new Stack<Node>();
            Node right = root.right;
            while(right != null)
            {
                if(!hashset.contains(right.data))
                {
                    hashset.add(right.data);
                    stack.push(right);
                }
                right = right.right;
            }
            while(!stack.empty())
            {
                System.out.println("[" + stack.pop().data + "]");
            }
        }
    }

    public static void PostOrder(Node r)
    {
        if( r != null)
        {
            PostOrder(r.left);
            PostOrder(r.right);
            System.out.println("normal[" + r.data + "]");
        }
    }

    public static void PostorderSimple(Node root)
    {
        if(root != null)
        {
            Stack<List<Node>> st = new Stack<List<Node>>();
            
            while(root != null || !st.empty())
            {
                if(root != null)
                {
                    List<Node> list = new LinkedList<Node>();
                    list.add(0, root);
                    if(root.left != null)
                        list.add(1, root.left);
                    if(root.right != null)
                        list.add(2, root.right);

                    root = root.left;
                }
            }
        }
    }
        
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
public class BracketsMatch 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
    }
    public static int[] fun()
    {
        int[] array = {1, 2};
        return array;
    }
    public static void test1()
    {
        System.out.println("test1"); 
        String str = "()";
        int index = 0;
        System.out.println(match(str, index)); 
    } 
    public static void test2()
    {
        System.out.println("test2"); 
        String str = "(}";
        int index = 0;
        System.out.println(match(str, index)); 
    } 
    public static boolean match(String str, int index){
        if(str.charAt(index) == '('){
            match(str, index+1);
        }else{
            if(index-1 < 0)
                return false;
            if(str.charAt(str.length-1-index) == '(' &&  str.charAt(index) != ')')
                return false;
        }
        return true;
    }
}
import java.util.*;
import java.math.*;
import classfile.*;

public class CarmichaelNumber{
    public static void main(String[] args) {
        test1();
    }
    //[ file=carmichaelnumber.html title=""
    public static boolean CarmichaelNumber(int n){
        for(int b=2; b<n; b++){
            if(gcd(b, n) == 1){
                BigDecimal bg = new BigDecimal(b);
                BigDecimal big = bg.pow(n-1);
                BigDecimal bgremainder = big.remainder(new BigDecimal(n));
                if(Integer.parseInt(bgremainder.toString()) != 1)
                    return false;
            }
        }
        return true;
    }
    //]
    static void test0(){
        Aron.beg();
        System.out.println("3=[" + gcd(0, 3) + "]");
        System.out.println("1=[" + gcd(2, 3) + "]");
        System.out.println("1=[" + gcd(3, 2) + "]");
        System.out.println("3=[" + gcd(3, 3) + "]");
        System.out.println("2=[" + gcd(2, 4) + "]");
        System.out.println("2=[" + gcd(6, 4) + "]");
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        int carnum = 561;
        System.out.println("561 is Carmichael Number? [" + CarmichaelNumber(carnum) + "]");
        Aron.end();
    }
    public static int gcd(int a, int b){
        if(a == 0 && b > 0)
            return b;
        else if( a > 0 && b == 0){
            return a;
        }else{
            if(a >= b){
                return gcd(a-b, b);
            }else{
                return gcd(a, b-a);
            }
        }
    }
}
public class CofactorMatrix 
{
				public static void main(String[] args)
				{
								System.out.println("Hello World!");
								int[][] A = {
															{1, 2},
															{3, 4}
														};

								int[][] B = cofactor(A, 1, 1);
								for(int r = 0;  B != null && r < B.length; r++)
								{
									for(int c = 0; c < B.length; c++)
									{
										System.out.print("["+B[r][c]+"]");
									}
									System.out.println();
								}
				}
				public static int[][] cofactor(int[][] A, int row, int col)
				{
					int len = 0;
					int[][] B = null; 
					if(A != null && (len = A.length) > 0 && row < len && col < len)
					{
						B = new int[len-1][len-1];
						int r1 = 0;
						for(int r = 0; r < len; r++)
						{
							if(r != row)
							{
								int c1 = 0;
								for(int c = 0; c < len; c++)
								{
									if(c != col)
									{
										B[r1][c1] = A[r][c];
										c1++;
									}
								}
								r1++;
							}
						}
					}
					return B;
				}
}
import java.util.*;

import classfile.*;

public class CoinChange {
    public static void main(String[] args) {
        /*
        test1();
        test2();
        test3();
        test4();
        test5();
        test8();
        test8_new();
        test10();
        test11();
        test12();
        */
        //test13();

        /*
        test20();
        test7();
        test9();
        test20();
        test21();
        test22();
        */

        //test2();

        test14();
        test15();
        //test23();
    }


    //[file=dynamic.html   title=""
    public static int[][] miniCoinDynamic(int[] coin, int sum) {
        int len = coin.length;
        int[][] array = init(len, sum);

        for(int i=0; i<len; i++) {
            for(int s = 0; s <=sum; s++) {
                if( s - coin[i] >= 0) {
                    int min = Integer.MAX_VALUE;
                    for(int k=0; k <=i; k++)
                        min = Math.min(min, array[k][s-coin[i]]);
                    array[i][s] = min == Integer.MAX_VALUE ? min: min + 1;
                }
            }
        }

        // find the mini value on the most right column
        int min = Integer.MAX_VALUE;
        for(int k=0; k <len; k++)
            min = Math.min(min, array[k][sum]);
        array[len-1][sum] = min;

        return array;
    }

    public static int[][] init(int height, int width) {
        int[][] array = new int[height][width+1];
        for(int i=0; i<height; i++) {
            for(int j=0; j<width+1; j++) {
                if(j == 0)
                    array[i][j] = 0;
                else
                    array[i][j] = Integer.MAX_VALUE;
            }
        }
        return array;
    }
    //]

    //Given coins[k] = {2, 3, 4} and change s = 9
    //Count the number of way for coin change
    //coins[k] is in the each change
    //coins[k] is not in the each change
    //count(coins, k, s) = count(coins, k-1, s) + count(coins, k, s-coins[k])
    public static int count_debug(int[] coin, int s, int k) {
        if( s < 0) {
            System.out.print("<"+s+","+k+">\n");
            return 0;
        } else if( s == 0 ) {
            System.out.print("<"+s+","+k+">\n");
            return 1;
        } else if( s > 0 && k > 0) {
            System.out.print("<"+s+","+k+">->");
            int left = count(coin, s, k-1);

            System.out.print("<"+s+","+k+">->");
            int right= count(coin, s-coin[k-1], k);
            return left + right;
        } else {
            System.out.println();
            return 0;
        }
    }

    public static int miniCointWithPerm(int[] coin, int s) {
        if(s == 0)
            return 0;
        else {
            int min = 100;
            for(int i=0; i<coin.length; i++) {
                if(s - coin[i] >= 0)
                    min = Math.min(min, miniCointWithPerm(coin, s-coin[i]) + 1);
            }
            return min;
        }
    }

    // Given coins[k] = {2, 3, 4} and change s = 9
    // Count the number of way for coin change
    // coins[k] is in the each change
    // coins[k] is not in the each change
    // count(coins, k, s) = count(coins, k-1, s) + count(coins, k, s-coins[k])
    public static int count(int[] coin, int s, int k) {
        if( s < 0)
            return 0;
        else if( s == 0 )
            return 1;
        else if( s > 0 && k > 0) {
            int right= count(coin, s-coin[k-1], k);
            int left = count(coin, s, k-1);
            return left + right;
        } else
            return 0;
    }

    //Coin change algorithm using dynamic programming
    //Use table from bottom up to model the recursion tree
    public static int countdy(int[] coin, int s, int k) {
        int[][] table = new int[s+1][k];
        for(int i=0; i<k; i++)
            table[0][i] = 1;

        System.out.println();

        Aron.printTable(table);

        for(int ss=1; ss<s+1; ss++) {
            for(int kk=0; kk<k; kk++) {
                int left  = kk-1 >= 0? table[ss][kk-1]:0;

                if(kk-1 >= 0)
                    System.out.print("["+ss+"]["+(kk-1)+"]=["+left+"]\n");
                else
                    System.out.print("["+ss+"]["+(kk-1)+"]=["+0+"]\n");

                int right = ss-coin[kk] >= 0?  table[ss-coin[kk]][kk]:0;
                int col = ss-coin[kk];

                if(ss-coin[kk] >= 0)
                    System.out.print("["+col+"]["+kk+"]=["+right+"]\n");
                else
                    System.out.print("["+col+"]["+kk+"]=["+0+"]\n");

                System.out.println();

                table[ss][kk] = left + right;
            }
        }

        printTable(table);

        return table[s][k-1];
    }

    //Print out all the coins which adds up to s
    public static void permuCount(int[] coin, int[] arr, int d, int s, int sum) {
        for(int i=0; i<coin.length; i++) {
            if(sum + coin[i] == s) {
                sum += coin[i];
                arr[d] = coin[i];
                for(int j=0; j<=d; j++) {
                    System.out.print("["+arr[j]+"]");
                }
                System.out.println();
            } else if(sum + coin[i] < s) {
                arr[d] = coin[i];
                sum += coin[i];
                permuCount(coin, arr, d+1, s, sum);
                sum -= coin[i];
            }
        }
    }

    public static int minCount_debug(int[] coin, int s, int k) {
        if(s < 0)
            return 100;
        if(s == 0) {
            System.out.print("["+s+"]\n");
            return 0;
        } else if( s > 0 && k <= 0)
            return 100;
        else {
            int min=100;
            for(int i=0; i<k; i++) {
                if(s - coin[i] > 0)
                    System.out.print("["+s+"]->");
                min = Math.min(min, minCount_debug(coin, s-coin[i], k)+1);
            }
            return min;
        }
    }

    //[file=CoinChangeRecursive.html   title=""
    //CoinChange.java
    //Given coin{2, 3, 4} and s = 6
    //Find the minimum number of coins sums up to s
    public static int minCount(int[] coin, int s, int k) {
        int min = Integer.MAX_VALUE;
        if(s == 0)
            min = 0;
        else if(s > 0) {
            // min(s) = min(s-coin[k]) + 1
            for(int i=0; i<k; i++) {
                int childMin = minCount(coin, s-coin[i], k);
                if(childMin != Integer.MAX_VALUE)
                    min = Math.min(min, childMin + 1);
            }
        }
        return min;
    }
    //]


    public static int minCountAllPath(int[] coin, int s, int k, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(s == 0){
            Aron.printList(list);
            min = 0;
        }
        else if(s > 0) {
            for(int i=0; i<k; i++) {
                list.add(coin[i]);
                int childMin = minCountAllPath(coin, s-coin[i], k, list);
                if(childMin != Integer.MAX_VALUE)
                    min = Math.min(min, childMin + 1);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }

        }
        return min;
    }
    //[file=CoinChangeWithHashMap.html   title=""
    // CoinChange.java
    // Given coin{2, 3, 4} and s = 6
    // Find the minimum number of coins sums up to s
    public static int minCountWithDynamic(int[] coin, int s, int k, Map<Integer, Integer> map, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(s == 0){
            min = 0;
        }
        else if(s > 0) {
            for(int i=0; i<k; i++) {
                Integer value = map.get(s-coin[i]);
                if(value == null) {
                    value = minCountWithDynamic(coin, s-coin[i], k, map, list);
                    if(value < Integer.MAX_VALUE)
                        value += 1; 
                } 

                min = Math.min(min, value);

                if(s-coin[i] < 0)
                    map.put(s-coin[i], Integer.MAX_VALUE);
                else
                    map.put(s-coin[i], min);

            }
        }
        return min;
    }
    //]

    public static int minCount_Graph(int[] coin, int s, int k, int[] arr) {
        int min = Integer.MAX_VALUE;
        if(s == 0) {
            min = 0;
        } else if(s > 0) {
            // min(s) = min(s-coin[k]) + 1
            int parent = arr[0];
            for(int i=0; i<k; i++) {
                String parentLabel = parent + "[label="+ s +"];";
                System.out.println(parentLabel);

                arr[0] += 1 + i;
                int child = arr[0] ;


                String childLabel = "";
                if( s - coin[i] == 0)
                    childLabel = child + "[label="+ (s-coin[i]) +", style=filled, fillcolor=green]";
                else if(s - coin[i] < 0)
                    childLabel = child + "[label="+ (s-coin[i]) +", style=filled, fillcolor=red]";
                else
                    childLabel = child + "[label="+ (s-coin[i]) +"];";

                System.out.println(childLabel);

                System.out.println(parent + "->" + child + "[label="+ coin[i] +"];");

                int childMin = minCount_Graph(coin, s-coin[i], k, arr);
                if(childMin != Integer.MAX_VALUE) {
                    min = Math.min(min, childMin + 1);
                }
            }
        }
        return min;
    }


    public static void printTable(int[][] arr) {
        if(arr != null) {
            for(int c=0; c<arr.length; c++) {
                for(int r=0; r<arr[0].length; r++) {
                    System.out.print("["+arr[c][r]+"]");
                }
                System.out.println();
            }
        }
        System.out.println();
    }
    public static void test1() {
        System.out.println("test1()");
        int[] recoin = {1};
        int[] dycoin = {1};
        int k = recoin.length;
        int s = 0;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");

    }

    public static void test2() {
        System.out.println("test1()");
        int[] recoin = {1, 2};
        int[] dycoin = {1};
        int k = recoin.length;
        int s = 3;
        int c = count(recoin, s, k);
        System.out.println("recursion count=["+c+"]");
    }

    public static void test3() {
        System.out.println("test1()");
        int[] recoin = {1, 2};
        int[] dycoin = {1, 2};
        int k = recoin.length;
        int s = 3;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");

    }

    public static void test4() {
        System.out.println("test4()");
        int[] recoin = {1, 2, 3};
        int[] dycoin = {1, 2, 3};
        int k = recoin.length;
        int s = 4;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");

    }

    public static void test5() {
        System.out.println("test5()");
        int[] recoin = {2, 3, 4};
        int[] dycoin = {2, 3, 4};
        int k = recoin.length;
        int s = 10;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println();
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");
    }




    public static void test8() {
        System.out.println("test8()");
        int[] recoin = {2, 3, 4, 5, 6};
        int[] dycoin= {2, 3, 4, 5, 6};
        int k = recoin.length;
        int s = 15;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println();
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");
    }

    public static void test8_new() {
        System.out.println("test8_new()");
        int[] recoin = {2, 3, 4, 5, 6};
        int k = recoin.length;
        int s = 15;
        String count = " ";
        int min = miniCointWithPerm(recoin, s);
        System.out.println("min="+min);
        System.out.println();
    }

    public static void test9() {
        System.out.println("test9()");
        final int Num = 10;
        int[] coin = new int[Num];

        for(int i=0; i<Num; i++)
            coin[i] = 3+i;

        int s = 150;
        int[][] table = miniCoinDynamic(coin, s);
        int row = table.length;
        int col = table[0].length;
        System.out.println("min=" + table[row-1][col-1]);
    }

    public static void test10() {
        System.out.println("test10()");
        int[] coin = {1, 2};
        int s = 3;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        Aron.printTable(table);
    }
    public static void test11() {
        System.out.println("test11()");
        int[] coin = {1, 2, 4};
        int s = 5;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        Aron.printTable(table);
    }
    public static void test12() {
        System.out.println("test12()");
        int[] coin = {1, 2, 3, 16};
        int s = 17;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        Aron.printTable(table);
    }

    public static void test6() {
        System.out.println("test6()");
        int[] recoin = {2, 3, 4, 5, 6};
        int[] arr = new int[recoin.length+10];
        int d = 0;
        int s = 15;
        int sum = 0;
        permuCount(recoin, arr, d, s, sum);
        System.out.println();
    }

    public static void test13() {
        System.out.println("test13()");
        final int Num = 4;
        int[] coin = new int[Num];
        for(int i=1; i<Num; i++)
            coin[i] = 2*i;

        int s = 45;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        // Aron.printTable(table);
    }

    public static void test14() {
        Aron.beg();
        final int Num = 14;
        int[] coin = new int[Num];

        for(int i=0; i<Num; i++)
            coin[i] = 2+i;

        int s = 45;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>(); 
        int min = minCountWithDynamic(coin, s, Num, map, list);
        System.out.println("min[" + min + "]"); 

        Aron.end();
    }
    public static void test15() {
        Aron.beg();
        final int Num = 4;
        int[] coin = new int[Num];
        for(int i=0; i<Num; i++)
            coin[i] = 2+i;

        int s = 20;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>(); 
        int min = minCountAllPath(coin, s, Num, list);
        System.out.println("min[" + min + "]"); 

        Aron.end();
    }


    public static void test7() {
        System.out.println("test7()");
        int[] coin = {2, 3, 15, 18};
        int k = coin.length;
        int s = 19;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }


    public static void test20() {
        System.out.println("test20()");
        int[] coin = {2, 3, 15, 18};
        int k = coin.length;
        int s = 20;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }

    public static void test21() {
        System.out.println("test21()");
        int[] coin = {2};
        int k = coin.length;
        int s = 2;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }

    public static void test22() {
        System.out.println("test22()");
        int[] coin = {2, 3, 4, 5};
        int k = coin.length;
        int s = 10;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }
    public static void test23() {
        int[] coin = {1, 2};
        int k = coin.length;
        int s = 3;
        int[] arr = new int[1];
        arr[0] = 100;
        System.out.println("digraph G {\n");
        int min = minCount_Graph(coin, s, k, arr);
        System.out.println("}\n");

        System.out.println();
    }
}
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import classfile.*;

class CoinChange{
    Integer curr_total;
    Integer curr_bill;
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    List<Integer> list = new ArrayList<Integer>();;
    
    public CoinChange(){
        curr_total = 0;
        curr_bill = 0;
        list.add(25);
        list.add(10);
        list.add(5);
        list.add(1);

        map.put(25, 10);
        map.put(10, 10);
        map.put(5, 10);
        map.put(1, 10);
    }
    public void insertBill(Integer bill){
        if(bill > 25){
            curr_bill = bill;
        }
    }

    public Map<Integer, Integer> withDraw(){
        Map<Integer, Integer> retMap = new HashMap<Integer, Integer>();
                for(Integer coin : list){
                    if(curr_bill > 0){
                    int quotient = curr_bill / coin;
                    if(quotient > 0){
                        Integer numCoins = map.get(coin);
                        if(quotient <= numCoins){
                            curr_bill = curr_bill - quotient*coin;
                            retMap.put(coin, quotient);
                            map.put(coin, numCoins - quotient);
                        }
                    }
            }
        }
        if(curr_bill == 0)
            return retMap;
        else
            return null;
    }
}
public class CoinMachine{
    public static void main(String[] args){
        test0();
        test1();
        test2();
    }
    
    static void test0(){
        Aron.beg();
        CoinChange cc = new CoinChange();
        cc.insertBill(54);
        Map<Integer, Integer> map = cc.withDraw();
        if(map != null){

           for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
           }
        }
        Aron.end();
    }

    static void test1(){
        Aron.beg();
        CoinChange cc = new CoinChange();
        cc.insertBill(1);
        Map<Integer, Integer> map = cc.withDraw();
        if(map != null){

           for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
           }
        }
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        CoinChange cc = new CoinChange();
        cc.insertBill(103);
        Map<Integer, Integer> map = cc.withDraw();
        if(map != null){

           for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
           }
        }
        Aron.end();
    }
}
// print all combination 0 to n-1
public class Combination 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] path = new int[3];
        int row = 0;
        combination(path, row);
        test1();
        test2();
    }
    public static void combination(int[] path, int row)
    {
        if(path != null)
        {
            if(row == path.length)
            {
                for(int r = 0; r < path.length; r++)
                {
                    System.out.print("["+path[r]+"]");
                }
                System.out.println("");
            }
            for(int col=0; col<path.length && row < path.length; col++)
            {
                path[row] = col; 
                combination(path, row+1);
            }
        }
    }
    public static void test1()
    {
        System.out.println("=================================="); 
        int[] path = {1}; 
        int row = 0;
        int len = path.length;
        combination(path, row);
    }
    public static void test2()
    {
        System.out.println("=================================="); 
        int[] path = {1, 2}; 
        int row = 0;
        int len = path.length;
        combination(path, row);
    } 
}
import java.util.*;

// Comparable
class Contact implements Comparable<Contact> {
    String name;
    String addr;
    int    age;
    public Contact(String name, String addr, int age) {
        this.name = name;
        this.addr = addr;
        this.age = age;
    }

    //Minimum heap
    public int compareTo(Contact c) {
        return this.age - c.age;
        //Maximum heap
        //return -(this.age - c.age);
    }

    public String toString() {
        return "["+name+"]["+addr+"]["+age+"]";
    }
}

class Person {
    String name;
    int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }

}


// Comparator
class LexicographicComparator implements Comparator<Person> {
    public int compare(Person p1, Person p2) {
        return p1.getName().compareToIgnoreCase(p2.getName());
    }
}

class AgeComparator implements Comparator<Person> {
    public int compare(Person p1, Person p2) {
        return p1.getAge() - p2.getAge() == 0? 0 : p1.getAge() < p2.getAge() ? -1 : 1;
    }
}



public class CompareDemo {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        List<Person> listPerson = new ArrayList<Person>(
            Arrays.asList(
                new Person("David", 20),
                new Person("Ann", 19),
                new Person("Michael", 18),
                new Person("Sunny", 6)
            )
        );

        Collections.sort(listPerson, new LexicographicComparator());
        Collections.sort(listPerson, new AgeComparator());
        for(Person p: listPerson) {
            System.out.println(p.getName() + " " + p.getAge());
        }
        List<Contact> listContact = new ArrayList<Contact>(
            Arrays.asList(
                new Contact("David", "Mountain View", 20),
                new Contact("Ann", "Palo Alto", 19),
                new Contact("Michael", "RedWood City", 26)
            )
        );

        System.out.println();
        Collections.sort(listContact);
        for(Contact c: listContact) {
            System.out.println(c.name + " " + c.addr + " " + c.age);
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class Compress {
    public static void main(String args[]) {
        test0();        
        test00();        
        test1();        
        test2();        
        test3();        
        test4();        
        test5();        
        test6();        
        test7();        
        test8();        
        test9();        
        test10();        
        test11();        
    }
    //[ file=compressstr.html title=""
    public static String CompressStr(String str) {
        String ret="";
        if(str != null && str.length() > 0) {
            if(str.length() == 0 || str.length() == 1)
                ret = str;
            else {
                int c=1;
                int i=0;
                for(i=0; i<str.length()-1; i++) {
                    if(str.charAt(i) == str.charAt(i+1))
                        c++;
                    else{
                        if(c > 1) {
                            ret = ret + str.charAt(i) + c + "";
                            c=1;
                        }else{
                            ret = ret + str.charAt(i) + "";
                        }
                    } 
                }

                if(c > 1)
                    ret = ret + c	+ str.charAt(i) + "";
                else
                    ret = ret + str.charAt(i) + "";
            }
        }
        return ret;
    }

    public static String compress(String str) {
        int c = 1;
        String retStr = "";
        int i=0;
        for(; i<str.length()-1; i++) {
            if(str.charAt(i) == str.charAt(i+1)) {
                c++;
            } else {
                if(c == 1)
                    retStr += str.charAt(i) + "";
                else if(c > 1)
                    retStr += str.charAt(i) + "" + c;

                c = 1;
            }
        }

        if(c == 1)
            retStr += str.charAt(i) + "";
        else if(c > 1)
            retStr += str.charAt(i) + "" + c;

        return retStr;
    }

    public static String compress2(String str) {
        int c = 1;
        String retStr = "";
        str += "0";
        for(int i=0; i<str.length()-1; i++) {
            if(str.charAt(i) == str.charAt(i+1)) {
                c++;
            } else {
                if(c == 1)
                    retStr += str.charAt(i) + "";
                else if(c > 1)
                    retStr += str.charAt(i) + "" + c;

                c = 1;
            }
        }

        return retStr;
    }
    //]
    
    static void test0(){
        Aron.beg();
        String str="aabba";
        String ret = CompressStr(str);
        System.out.println("aabba[" + ret + "]"); 
        Aron.end();
    }

    static void test00(){
        Aron.beg();
        String str="a";
        String ret = CompressStr(str);
        System.out.println("a[" + ret + "]"); 
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        String str="aabba";
        String ret = compress(str);
        System.out.println("aabba[" + ret + "]"); 
        Aron.end();
    }

    static void test2(){
        Aron.beg();
        String str="a";
        String ret = compress(str);
        System.out.println("a[" + ret + "]"); 
        Aron.end();
    }

    static void test3(){
        Aron.beg();
        String str="aa";
        String ret = compress(str);
        System.out.println("aa[" + ret + "]"); 
        Aron.end();
    }

    static void test4(){
        Aron.beg();
        String str="ab";
        String ret = compress(str);
        System.out.println("ab[" + ret + "]"); 
        Aron.end();
    }
    static void test5(){
        Aron.beg();
        String str="aabbb";
        String ret = compress(str);
        System.out.println("aabbb[" + ret + "]"); 
        Aron.end();
    }
    static void test6(){
        Aron.beg();
        String str="aabbba";
        String ret = compress(str);
        System.out.println("aabbba[" + ret + "]"); 
        Aron.end();
    }

    static void test7(){
        Aron.beg();
        String str="a";
        String ret = compress2(str);
        System.out.println("compress2 a[" + ret + "]"); 
        Aron.end();
    }
    static void test8(){
        Aron.beg();
        String str="aa";
        String ret = compress2(str);
        System.out.println("compress2 aa[" + ret + "]"); 
        Aron.end();
    }
    static void test9(){
        Aron.beg();
        String str="abbb";
        String ret = compress2(str);
        System.out.println("compress2 abbb[" + ret + "]"); 
        Aron.end();
    }
    static void test10(){
        Aron.beg();
        String str="aabbbc";
        String ret = compress2(str);
        System.out.println("compress2 aabbbc[" + ret + "]"); 
        Aron.end();
    }

    static void test11(){
        Aron.beg();
        String str="";
        String ret = compress2(str);
        System.out.println("compress2 empty_str[" + ret + "]"); 
        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Compress2
{
	public static void main(String args[])
	{
		String str="aaaaa";
		String ret = Compress2(str);
		System.out.println("str=" + ret);
	}
	public static String Compress2(String str) 
	{
		String ret="";
		if(str != null)
		{
			int len=str.length();
			if(len > 0)
			{ int c=1; int i=0;
				for(i=0; i<len-1; i++)
				{ if(str.charAt(i) == str.charAt(i+1))
						c++;
					else 
					{
						if(c>1)
							ret = ret + c + str.charAt(i);
						else 
							ret = ret + str.charAt(i);
						c=1;
					}
				}
				if(c>1)
					ret = ret + c + str.charAt(i);
				else 
					ret = ret + str.charAt(i);
			}
		}
		return ret;
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

public class ConnectedIsland {
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        //test0_maxWords();
        test1_maxWords();
        test2_maxWords();
        test3_maxWords();
        test4_maxWords();
        test5_maxWords();

        test00_maxWords();
        test01_maxWords();
        test02_maxWords();
    }

    //[file=connectedisland.html title=""
    // 2:41 - 3:12
    //--------------------------------------------------------------------------------
    // [0, 1, 1, 0]
    // [0, 1, 0, 0]
    // [1, 0, 0, 1]
    // [1, 0, 1, 0]
    //
    //--------------------------------------------------------------------------------
    // w = 0, h = 0, width = 4, height = 4
    // arr[0][0] = 0
    // arr[0][1] = 1
    // arr[0][2] = 1
    // arr[0][3] ret
    // arr[0][1] = 2 ret
    // arr[-1][1] = ret
    // w = 0, h = 0
    public static int countConnection(int[][] arr, int w, int width, int h, int height) {
        if(arr != null) {
            if(arr[h][w] == 1) {
                arr[h][w] = 2;
                int right = 0, left = 0, up = 0, down = 0;
                if(w + 1 < width)
                    right =countConnection(arr, w+1, width, h, height);
                if(w - 1 >= 0)
                    left = countConnection(arr, w-1, width, h, height);
                if(h - 1 >= 0)
                    up =   countConnection(arr, w, width, h-1, height);
                if(h + 1 < height)
                    down = countConnection(arr, w, width, h+1, height);

                return right + left + up + down + 1;
            }
        }
        return 0;
    }
    public static int maxConnection(int[][] arr) {
        int max = 0;
        if(arr != null) {
            int height = arr.length;
            int width = arr[0].length;
            for(int h=0; h<height; h++) {
                for(int w=0; w<width; w++) {
                    int m = countConnection(arr, w, width, h, height);
                    if(m > max)
                        max = m;
                }
            }
        }
        return max;
    }
    //]
    public static void test0() {
        Aron.beg();

        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 1, 1, 0},
            {1, 0, 0, 0},
            {1, 1, 0, 0},
            {1, 1, 0, 1},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 5);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();

        int[][] arr2d = {
            {0}
        };
        int max = maxConnection(arr2d);
        Test.t(max, 0);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();

        int[][] arr2d = {
            {0, 0, 0, 0},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 0);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();

        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 1, 1, 0},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 4);

        Aron.end();
    }
    public static void test4() {
        Aron.beg();

        int[][] arr2d = {
            {1, 0, 0, 1},
            {1, 0, 0, 1},
            {1, 0, 0, 1},
            {1, 1, 1, 1},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 10);

        Aron.end();
    }

    public static boolean isWord(String s) {
        String[] arr = {
            "a",
            "b",
            "e",
            "ill",
            "ball",
            "app",
            "ban",
            "cat",
            "banana",
            "ancestor",
            "scene",
            "descend",
            "descended",
            "sibling",
            "dangling"
        };
        Set<String> set = new HashSet<>(Arrays.asList(arr));
        return set.contains(s);
    }
    public static void test0_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'a', 'n', 'a'},
            {'a', 'p', 'e', 'n'},
            {'a', 'p', 'p', 'a'},
            {'d', 'a', 'n', 'g'},
            {'a', 'p', 'k', 'k'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test1_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'a'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test2_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'a', 'b'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test3_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'a', 'p', 'p'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test4_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'a', 'n'},
            {'a', 'n', 'a'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test5_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'e', 'e'},
            {'a', 'l', 'i'},
            {'l', 'n', 'l'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test00_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b'},
            {'e'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        //int w = 0, h = 0;

        for(int h=0; h<height; h++){
            for(int w=0; w<width; w++){
                Set<String> set = new HashSet<>();
                maxWords(set, uniqueSet, word, arr, h, height, w, width);
                Aron.printSet(set);
            }
        }
        Aron.end();
    }
    public static void test01_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'i', 'e', 'f'},
            {'e', 'k', 'l', 'l'},
        };
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];

        for(int h=0; h<height; h++){
            for(int w=0; w<width; w++){
                Set<String> set = new HashSet<>();
                maxWords(set, uniqueSet, word, arr, h, height, w, width);
                Aron.printSet(set);
            }
        }

        Aron.end();
    }
    public static void test02_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'i', 'p', 'f'},
            {'e', 'k', 'p', 'l'},
            {'k', 'a', 'l', 'l'},
        };
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];

        for(int h=0; h<height; h++){
            for(int w=0; w<width; w++){
                Set<String> set = new HashSet<>();
                maxWords(set, uniqueSet, word, arr, h, height, w, width);
                Aron.printSet(set);
            }
        }

        Aron.end();
    }


    //
    // 3:23 4:49 5:19
    // word = "";
    public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int h, int height, int w, int width) {
        word.append(arr[h][w]);
        int index = h*width + w;
        if(!uniqueSet.contains(index)) {
            uniqueSet.add(index);

            if(isWord(word.toString()))
                set.add(word.toString());

            if(w + 1 < width) {
                maxWords(set, uniqueSet, word, arr, h, height, w + 1, width);
            }

            if(w - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h, height, w - 1, width);
            }

            if(h + 1 < height) {
                maxWords(set, uniqueSet, word, arr, h + 1, height, w, width);
            }

            if(h - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h - 1, height, w, width);
            }

            if(w + 1 < width && h + 1 < height) {
                maxWords(set, uniqueSet, word, arr, h + 1, height, w + 1, width);
            }

            if(w - 1 >= 0 && h - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h - 1, height, w - 1, width);
            }

            if(h + 1 < height && w - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h + 1, height, w - 1, width);
            }

            if(h - 1 >= 0 && w + 1 < width) {
                maxWords(set, uniqueSet, word, arr, h - 1, height, w + 1, width);
            }
            uniqueSet.remove(h*width + w);
        }
        if(word.length() > 0)
            word.deleteCharAt(word.length()-1);
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

public class ConnectedIslandNew{
    public static void main(String[] args) {
//        test0();
//        test1();
//        test2();
        test_count8_0();
        test_count8_1();
        test_count8_2();
        test_count8_3();
    }
    public static void test0(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   0,  1},
            { 1,   1,   0,  1},
            { 0,   1,   0,  1},
            { 0,   1,   1,  0},
        };
          
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count(arr2d, i, j, height, width);
                max = num > max ? num : max;
            }
        } 
        Print.pbl(max);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        for(int j=-1; j<=1; j++){
            for(int i=-1; i<=1; i++){
                Print.pbl(j + " " + i);
            } 
        }
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  0},
            { 0,   0,   0,  0},
            { 0,   0,   0,  0},
            { 1,   1,   0,  1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count(arr2d, i, j, height, width);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 2);
        Aron.end();
    }
    public static void test_count8_0(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  0},
            { 0,   0,   0,  0},
            { 0,   0,   0,  0},
            { 1,   1,   0,  1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 2);
        Aron.end();
    }
    public static void test_count8_1(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  0},
            { 1,   1,   0,  0},
            { 1,   1,   0,  0},
            { 1,   1,   0,  1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                Print.pbl(num);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 7);
        Aron.end();
    }
    public static void test_count8_2(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  1},
            { 0,   1,   0,  0},
            { 0,   0,   0,  1},
            { 1,   1,   0,  0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                Print.pbl(num);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 3);
        Aron.end();
    }
    public static void test_count8_3(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   0,   1,  1},
            { 0,   1,   0,  0},
            { 1,   0,   1,  1},
            { 0,   1,   0,  0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                Print.pbl(num);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 8);
        Aron.end();
    }

    // *connected_island* *island*
    public static int count(int[][] arr, int h, int w, int height, int width){
        if(arr[h][w] == 1){
            arr[h][w] = 2;
            int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
            if(h + 1 < height)
                n1 = count(arr, h+1, w, height, width);
            if(h - 1 >= 0)
                n2 = count(arr, h-1, w, height, width);
            if(w + 1 < width)
                n3 = count(arr, h, w+1, height, width);
            if(w - 1 >= 0)
                n4 = count(arr, h, w-1, height, width);

            return n1 + n2 + n3 + n4 + 1;
        }
        return 0;
    }

    //
    // east, west, north, south, east/noth, north/west, west/south, south/east
    // 8 direction *8direction* *9direction* *9direct* 
    public static int count8(int[][] arr, int h, int w, int height, int width){
        int s = 0;
        if(arr[h][w] == 1){
            arr[h][w] = 2;
            for(int hh=-1; hh<=1; hh++){
                for(int ww=-1; ww<=1; ww++){
                    if(hh != 0 || ww != 0){
                        if(
                            (h + hh >= 0 && h+hh < height) && 
                            (w + ww >= 0 && w+ww < width) 
                            ) 
                        s +=count8(arr, h+hh, w+ww, height, width); 
                    }
                }
            }
            s += 1;
        }
        return s;
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class Power 
{
	public static void main(String args[])

	  int[] A={2, 3, 3, 2,3,4};
		Co(A);
	}
	public static boolean  Co(int[] A)
	{
		int c=1;
		int max=1;
		int num=A[0];
		for(int i=0; i<A.length-1; i++)
		{
			if(A[i] == A[i+1])
			{
				c++;
				if(c > max)
				{
					max=c;
					num = A[i];
				} 
			}
			else
			{
				c--;
				if(c=0)
				{
					c=1;
				}
			}
		}
		System.out.println("max=" + max);
		System.out.println("num=" + num);
	}

}
import java.io.*;
import java.lang.String;
import java.util.*;
class CountNBit 
{
	public static void main(String args[])
	{
		CountNBit(32);
		System.out.println();
		int n = CountNBit(10);
		System.out.println("n=" + n);
	}

	public static int CountNBit(int n)
	{
		/*
		for(int i=0; i<n; i++)
		{
			String bin = Integer.toBinaryString(i);
			System.out.println(String.format("%5s", bin));
		}
		*/
		
		if(n==0)
			return 0;
		else if(n==1)
			return 1;
		else 
		{

			//a/2*x: half of column are 1
			//a is 2^floor(logn)
			//x = floor(logn)
			//
			//F(n-a): the number of 1 bit from 1 - 2^floor(logn)
			//
			//n-a+1 is the number of MSB from 2^floor(logn)-n
			//
			//F(n) = a/2*x + F(n-a) + n-a+1
			//
			int x = (int)Math.floor((double)Math.log(n)/(double)Math.log(2));
			int a = (int)Math.pow(2, x);
			return (a/2)*x + CountNBit(n-a) + (n-a+1);
		}
		
		
		
	}
}
public class CountOccurrences {
    public static void main(String[] args) {
        // write your code here
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    static void test0(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("a", "a");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    }
    static void test1(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aa", "a");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    }
    static void test2(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aaa", "aa");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    } 

    static void test3(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aacaaa", "aa");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    } 
    static void test4(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aaccacc", "ac");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    } 

    //[ file=countoccurrence.html title=""
    // count prefix occurrence
    static int countOccurrences(String str, String pattern){
        int count = 0;
        if(str == null || pattern == null)
            return 0;
        else if(str.length() == 0 || pattern.length() == 0)
            return 0;
        else {
            int start = 0;
            int k = 0;
            int len = pattern.length();
            int i = 0;
            while(i < str.length()){
                if(str.charAt(i) == pattern.charAt(k)){
                    if(k == 0)
                        start = i;
                    k++;
                    if(k == len){
                        count++;
                        k = 0;
                        i = start + 1;
                    }else{
                        i++;
                    }
                }else{
                    k = 0;
                    i = start + 1;
                    start++;
                }
            }
        }
        return count;
    }
    //]

}
import java.util.*;
import classfile.*;

public class Database {
  public static class Table {
    private final String name;
    private final String[] columnNames;
    private final List<List<Object>> data;

    public Table(String name, String[] columnNames, List<List<Object>> data) {
      this.name = name;
      this.columnNames = columnNames;
      this.data = data;
    }

    public void insert(Object[] row) {
      data.add(Arrays.asList(row));
    }

    public String getName() {
      return name;
    }

    public String[] getColumnNames() {
      return columnNames;
    }

    public List<List<Object>> getData() {
      return data;
    }

    public Table select(String[] projectedColumnNames) {
      // IMPLEMENT ME
      Aron.printList2d(data);
      for(List<Object> list : data){
        for(String cn : projectedColumnNames){
        }
      }
      return new Table("Select", null, null);
    }

    public Table where(String cName, Object value) {
      // IMPLEMENT ME
      int columnInx= 0;
      for(columnInx=0; columnInx<columnNames.length; columnInx++){
          if(columnNames[columnInx].equals(cName)){
              Print.p("columnInx=" + columnInx);
              break;
          }
      }

     Table tab = null;
     for(List<Object> ll : data){
         if(ll.get(columnInx).equals(value)){
             Print.p("columnInx.intValue()=" + value);

             List<List<Object>> rowList = new ArrayList<List<Object>>();
             rowList.add(ll);

             tab = new Table("dog", columnNames, rowList);
             break;
         }
     }

      // return new Table(getName(), null, null);
      return tab; 
    }

    @Override
    public String toString() {
      StringBuffer sb = new StringBuffer(String.join(", ", columnNames)).append("\n");
      for (List<Object> row : data) {
        if (row.size() != 0) {
          Object value = row.get(0);
          sb.append(value == null ? "" : value.toString());
          for (int i = 1; i < row.size(); i++) {
            value = row.get(i);
            sb.append(", ").append(value == null ? "" : value.toString());
          }
        }
        sb.append("\n");
      }
      return sb.toString();
    }
  }

  private final Map<String, Table> tableMap;

  public Database() {
    this.tableMap = new HashMap<String, Table>();
  }

  public void addTable(Table table) {
    this.tableMap.put(table.getName(), table);
  }

  public Table getTable(String tableName) {
    return tableMap.get(tableName);
  }

  public Table innerJoin(Table leftTable, String leftTableKeyName, Table rightTable, String rightTableKeyName) {
    // IMPLEMENT ME
    return new Table("InnerJoin", null, null);
  }

  public static void main(String[] args) {
    Table departmentTable = new Table("departments", new String[]{"id", "name"}, new ArrayList<List<Object>>());
    departmentTable.insert(new Object[] {0, "engineering"});
    departmentTable.insert(new Object[] {1, "finance"});

    Table userTable = new Table("users", new String[]{"id", "department_id", "name"}, new ArrayList<List<Object>>());
    userTable.insert(new Object[] {0, 0, "Ian"});
    userTable.insert(new Object[] {1, 0, "John"});
    userTable.insert(new Object[] {2, 1, "Eddie"});
    userTable.insert(new Object[] {3, 1, "Mark"});

    Table salaryTable = new Table("salaries", new String[]{"id", "user_id", "amount"}, new ArrayList<List<Object>>());
    salaryTable.insert(new Object[] {0, 0, 100});
    salaryTable.insert(new Object[] {1, 1, 150});
    salaryTable.insert(new Object[] {2, 1, 200});
    salaryTable.insert(new Object[] {3, 3, 200});
    salaryTable.insert(new Object[] {4, 3, 300});
    salaryTable.insert(new Object[] {5, 4, 400});

    Database db = new Database();
    db.addTable(departmentTable);
    db.addTable(userTable);
    db.addTable(salaryTable);

    // should print
    // id, department_id, name
    // 1, 0, John
    //
    // select id, department_id, name from users where id = 1
    //
    //System.out.println(db.getTable("users").where("id", 1).select(new String[] {"id", "department_id", "name"}));
    
    Table table = db.getTable("users");
    Print.p(table.getName());
    Table wtable = table.where("id", 1);
    Print.p(wtable.getName());
    Aron.printArray(wtable.columnNames);
    Aron.printList2d(wtable.data);
    wtable.select(new String[]{"name"});

    // should print
    // users.name, departments.name
    // Ian, engineering
    // John, engineering
//    System.out.println(
//        db.innerJoin(db.getTable("users"), "department_id", db.getTable("departments"), "id")
//            .where("departments.name", "engineering")
//            .select(new String[]{"users.name", "departments.name"}));
  }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Card
{
	String suits;
	int rank;
	public Card(int rank, String suits)
	{ this.suits = suits; this.rank = rank;}
}
class Deck
{
	final int SIZE=52;
	Card[] deck = null;
	public Deck()
	{
		int c=0;
		deck = new Card[52];
		if( deck != null)
		{
			for(int i=0; i<13; i++)
			{
				deck[c++] = new Card(i+1, "Diamonts");		
				deck[c++] = new Card(i+1, "Clubs");		
				deck[c++] = new Card(i+1, "Hearts");		
				deck[c++] = new Card(i+1, "Spades");		
			}
		}
		System.out.println("c="+c);
	}
	public void Shuttle()
	{
		Random ran = new Random();
		for(int i=0; i<SIZE; i++)
		{
			int r = ran.nextInt(SIZE);
			System.out.println("r="+r);
			Card tmp = deck[r];	
			deck[r] = deck[SIZE-1-i];
			deck[SIZE-1-i] = tmp;
		}
	}
	public void show()
	{
		for(int i=0; i<SIZE; i++)
		{
			System.out.print(deck[i].suits+" "+deck[i].rank+" ");
			if( (i+1)%4==0)
				System.out.println();
		}
	}

}
class DeckCard 
{
	public static void main(String args[])
	{
		Deck d = new Deck();
		d.Shuttle();
		d.show();
	}
}
public class DepthTree 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    public static int depth(Node r)
    {
        return 0;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;
public class Dequeue{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();

        Deque<Node> queue = new ArrayDeque<Node>();
        queue.add(new Node(1));
        queue.add(new Node(2));
        System.out.println("size[" + queue.size() + "]"); 
        queue.poll();
        System.out.println("size[" + queue.size() + "]"); 

        Aron.end();
    }
} 
public class DiagonalMatrix 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[][] Array = {
                        {1, 2, 3},
                        {4, 5, 6},
                        {7, 8, 9}
                        };
        for(int i=0; i<Array.length; i++)
        {
            for(int j=0; j<Array[0].length; j++)
            {
                System.out.print("["+Array[i][j]+"]");
            }
            System.out.println("");
        }
        System.out.println("");
        DiagonalMatrix(Array);
        System.out.println("");
        DiagonalMatrixAll(Array);
    }
    public static void DiagonalMatrix(int[][] matrix)
    {
        if(matrix != null)
        {
            int rowLen = matrix.length;
            if(matrix[0] != null)
            {
                int colLen = matrix[0].length;
                for(int i=0; i<rowLen; i++)
                {
                    for(int j=0; j<colLen; j++)
                    {
                        if(j-i >= 0)
                            System.out.print("["+matrix[j][j-i]+"]");
                        else
                            System.out.print("[ ]");
                    }
                    System.out.println("");
                }
            }
        }
    }
    public static void DiagonalMatrixAll(int[][] matrix)
    {
        if(matrix != null)
        {
            int rowLen = matrix.length;
            if(matrix[0] != null){
                int colLen = matrix[0].length;
                for(int i=0; i<rowLen; i++){
                    for(int j=0; j<colLen; j++){
                        if(j==j+i){
                            System.out.print("["+matrix[j][j+i]+"]");
                        }
                        else{
                            if(i%2 == 1){
                                if(j+i < colLen)
                                    System.out.print("["+matrix[j][j+i]+"]");
                                else
                                    System.out.print("[ ]");
                            }
                            else{
                                if(j-i >= 0)
                                    System.out.print("["+matrix[j][j-i]+"]");
                                else 
                                    System.out.print("[ ]");
                            }
                        }
                    }
                    System.out.println(" ");
                }
            }
        }
    }
}
import java.io.*;
import java.lang.String;
import classfile.*;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 

class DoubleLinkedList_test{
    public static void main(String args[]) {
        test0();
        test_addFirst();
        test_addNext();
        test_delete_first();
        test_delete_middle();
        test_delete_last();
        test_delete_one();
        test_delete_none();
    }
    
    static void test0(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);
        
        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.get(0).data, 3);
        Test.t(list.get(1).data, 4);
        Test.t(list.get(2).data, 5);

        Aron.end();
    }
    static void test_addFirst(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        dll.append(p1);
        dll.append(p2);

        Node firstNode  = new Node(9);
        dll.addFirst(firstNode);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.get(0).data, 9);
        Test.t(list.get(1).data, 3);
        Test.t(list.get(2).data, 4);

        Aron.end();
    }
    static void test_addNext(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        dll.append(p1);
        dll.append(p2);

        Node nextNode = new Node(9);
        dll.addNext(p1, nextNode);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.get(0).data, 3);
        Test.t(list.get(1).data, 9);
        Test.t(list.get(2).data, 4);

        Aron.end();
    }

    static void test_delete_last(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);

        dll.delete(p3);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 2);
        Test.t(list.get(0).data == 3);
        Test.t(list.get(1).data == 4);

        Aron.end();
    }
    static void test_delete_first(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);
        dll.delete(p1);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 2);
        Test.t(list.get(0).data == 4);
        Test.t(list.get(1).data == 5);

        Aron.end();
    } 
    static void test_delete_middle(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);
        dll.delete(p2);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 2);
        Test.t(list.get(0).data == 3);
        Test.t(list.get(1).data == 5);

        Aron.end();
    } 

    static void test_delete_one(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        dll.append(p1);
        dll.delete(p1);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 0);

        Aron.end();
    } 

    static void test_delete_none(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        dll.append(p1);
        dll.delete(p2);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 1);
        Test.t(list.get(0).data == 3);

        Aron.end();
    } 
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 

//[ file=eightqueen.html title=""
// n queens problem
class Queen{
    List<Move> list = new ArrayList<>();
    private int width = 4;
    public Queen(int width){
        this.width = width;
    }

    class Move{
        public int c;
        public int r;
        public Move(int c, int r){
            this.c = c;
            this.r = r;
        }
    }

    // int c = 0;
    public void queenSolver(int c){
        if(c == width){
            for(Move m:list){
                Print.p("[" + m.c + "," + m.r + "]");
            }
            Ut.l();
        }else{
            for(int r=0; r<width; r++){
                if(isValidMove(c, r)){
                    list.add(new Move(c, r));
                    queenSolver(c+1);
                    list.remove(list.size()-1);
                }
            }
        }
    }
    public boolean isValidMove(int c, int r){
        for(Move m : list){
            if(m.r == r || Math.abs(m.c - c) == Math.abs(m.r - r))
                return false;
        }
        return true;
    }
}
//]

public class EightQueen{
    public static void main(String[] args) {
        test0();
        test1();
    }
    
    static void test0(){
        Aron.beg();
        Queen q = new Queen(4);
        int c = 0;
        q.queenSolver(c);
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

// <enum>enum class example</enum>
// *j_enum_example* *jenum_example*
enum MyType {
    NUM(3),
    ROW(4);
    int value;
    MyType(int value) {
        this.value=value;
    }
    int Value() {
        return this.value;
    }
}

enum DAY{
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
}

public class EnumExample {
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();
        Print.pbl("NUM=" + MyType.NUM.Value());
        Print.pbl("NUM=" + MyType.ROW.Value());
        Aron.end();
    }
    static void test1(){
        Aron.beg();

        getDay(DAY.SUNDAY);
        getDay(DAY.MONDAY);

        Aron.end();
    }
    public static void getDay(DAY day){
        if (day == DAY.SUNDAY){
            Print.pbl("sunday");
        }else if( day == DAY.MONDAY){
            Print.pbl("monday");
        }

    }
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class EvaluateExpr {
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0() {
        Aron.beg();
        String str = "( 1 + 2 )";
        int sum = evaluate(str);
        Test.t(sum == 3);
        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        String str = "( 1 - 2 )";
        int sum = evaluate(str);
        Test.t(sum == -1);
        Aron.end();
    }
    public static void test2() {
        Aron.beg();
        String str = "( 1 - ( 2 - 4 ) )";
        int sum = evaluate(str);
        Test.t(sum == 3);
        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        String str = "( 1 - ( ( 2 - 4 ) + 3 ) )";
        int sum = evaluate(str);
        Test.t(sum == 0);
        Aron.end();
    }
    public static void test4() {
        Aron.beg();
        String str = "( 1 )";
        int sum = evaluate(str);
        Test.t(sum == 1);
        Aron.end();
    }
    public static void test10() {
        Aron.beg();
        String str = "12";
        boolean isNum = str.matches("[0-9]+");
        Print.pbl(isNum);

        str = "a12";
        isNum = str.matches("[0-9]+");
        Print.pbl(isNum);
        Aron.end();
    }
    // iterate the in order traversal  
    public static int evaluate(String str) {
        int sum = 0;
        Stack<Integer> operandStack = new Stack<Integer>();
        Stack<String> operatorStack = new Stack<String>();

        String[] arr = str.split("\\s+");
        for(String s : arr){
            if(Aron.isNumeric(s)) {
                operandStack.push(Integer.parseInt(s));
            } else if(s.equals("+") || s.equals("-")) {
                operatorStack.push(s);
            } else if(s.equals(")")) {
                if(operatorStack.size() > 0 && operandStack.size() > 1) {
                    String op = operatorStack.pop();
                    int right = operandStack.pop();
                    int left  = operandStack.pop();
                    if(op.equals("+")) {
                        operandStack.push(left + right);
                    } else if(op.equals("-")) {
                        operandStack.push(left - right);
                    } else
                        Print.pbl("Expression Error");
                }
            }
        }
        Aron.printArray(arr);
        return operandStack.peek();
    }
}

import java.util.*;
import classfile.*;

public class ExcelColumnNumber{
    public static void main(String[] args) {
        System.out.println("Print all permuation character with repeating character!");
        String s = "ABC";
        char[] array = new char[s.length()];
        int depth = 0;
        Set<Character> map = new LinkedHashSet<Character>();
        //permRepeated(s, array, depth);
        //perm(s, array, depth, map);

        int[] arr = new int[1];
        int num = 20;
        arr[0] = 1;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i, arr, num);

        ExcelSheetRowNumberDirect(1);
        System.out.println("================");
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test11_printBinary();

        test00_ExcelSheetRowNumberDirect();
    }
    
    static void test00_ExcelSheetRowNumberDirect(){
        Aron.beg();
        int num = 1;
        Print.p("num=" + num);
        ExcelSheetRowNumberDirect(num);

        num = 26;
        Print.p("num=" + num);
        ExcelSheetRowNumberDirect(num);

        Aron.end();
    }
    static void test11_printBinary(){
        Aron.beg();

        Test.t(printBinary(0), "0"); 
        Test.t(printBinary(1), "1"); 
        Test.t(printBinary(2), "10"); 
        Test.t(printBinary(3), "11"); 
        Test.t(printBinary(4), "100");

        Aron.end();
    } 

    public static void test5() {
        System.out.println("test5");
        String prefix = "";
        int nBits = 1;
        int count = 0;
        int height = 1;
        nBitsBinaryString("", nBits, count, height);
    }
    public static void test6() {
        System.out.println("test6");
        String prefix = "";
        int nBits = 2;
        int count = 0;
        int height = 2;
        nBitsBinaryString("", nBits, count, height);
    }
    public static void test7() {
        System.out.println("test7");
        String prefix = "";
        int nBits = 3;
        int count = 0;
        int height = 4;
        nBitsBinaryString("", nBits, count, height);
    }

    public static void nBitsBinaryString(String prefix, int nBits, int count, int height) {
        if(count == nBits && height == 0)
            System.out.println(prefix);
        else if(height > 0) {
            nBitsBinaryString(prefix + "0", nBits, count, height-1);
            nBitsBinaryString(prefix + "1", nBits, count+1, height-1);
        }
    }
    /*
    public static void permrepeating(String str, String permStr, int k, int h){
        int len = array.length;
        if(permStr.length() == k){
            System.out.println(permStr);
        }
        else{
            for(int i=0; i<len; i++){
                String s = str.charAt(i) + "";
                permrepeating(str, permStr + s, k, h+1);
            }
        }
    }
    */
    public static void test1() {
    }
    public static void test2() {
        ExcelSheetRowNumberDirect(1000000);
    }

    public static void test3() {
        int n = ExcelSheetStringToInteger("A");
        System.out.println("A=" + n);

        n = ExcelSheetStringToInteger("Z");
        System.out.println("Z=" + n);


        n = ExcelSheetStringToInteger("AA");
        System.out.println("AA=" + n);
        n = ExcelSheetStringToInteger("AB");
        System.out.println("AB=" + n);
    }

    public static void test4() {
        String str = ExcelSheetIntergeToString(1);
        System.out.println("1=" + str);

        str = ExcelSheetIntergeToString(2);
        System.out.println("2=" + str);

        str = ExcelSheetIntergeToString(26);
        System.out.println("26=" + str);

        str = ExcelSheetIntergeToString(28);
        System.out.println("28=" + str);
    }

    // 1 -> 0 -> 'A'
    // 2 -> 1 -> 'B'
    // 3 -> 2 -> 'C'
    // 26->25 -> 'Z'
    // 27->26 -> 'AA'

    public static String ExcelSheetIntergeToString(int n) {
        String ret = "";
        char[] array = new char[26];
        for(int i=0; i<26; i++)
            array[i] = (char)((int)'A' + i);

        if( n-1 == 0)
            ret = array[n-1] + "";
        else {
            while(n > 0) {
                int rem = (n-1) % 26;
                n = (n-1) / 26;
                ret = (char)array[rem] + "" + ret;
            }
        }
        return ret;
    }
    // 'A' -> 0 -> 1
    // 'B' -> 1 -> 2
    // 'C' -> 2
    // 'Z' -> 25
    // 'AA'-> 26 ->27
    // (a % m) = x
    // 1 % m = y
    // (a + 1) % m  = x + y
    //
    public static int ExcelSheetStringToInteger(String str) {
        int sum = 0;
        if(str != null) {
            int len = str.length();
            for(int i=0; i<len; i++) {
                int n = str.charAt(len-1-i) - 'A' + 1;
                sum += (int)Math.pow(26, i)*n;
            }
        }
        return sum;
    }

    //Calculate the excel sheet row number directly
    //   s = 26^1 + 26^2 + 26^3 + ... + 26^k
    // 26s = 26^2 + 26^3 + 26^4 + ... + 26^(k+1)
    // 25s = 26^(k+1) - 26
    // 25s + 26 = 26^(k+1)
    // log(25s+26)/log(26) = k+1
    // log(25s+26)/log(26)-1 = k
    public static void ExcelSheetRowNumberDirect(int num) {
        int k = (int)(Math.log(25*num + 26)/Math.log(26)) - 1;
        int diff = num - (int)(Math.pow(26, k+1) - 26)/25;
        int[] arr = new int[26];

        Print.p(k);
        Print.p("diff=" + diff);

        for(int i=0; i<26; i++)
            arr[i] = 'a'+i;

        int n = diff;
        if(diff == 0)
            n = num;

        while(n > 0) {
            int r = (n-1) % 26;
            Print.p((char)arr[r]);
            n /= 26;
        }
        System.out.println();
    }
    //print excel sheet row number algorithm based on permutation
    public static void ExcelSheetRowNumber(String s, int num) {
        int[] arr = new int[1];
        arr[0] = 1;
        char[] array = new char[s.length()];
        int depth = 0;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i, arr, num);
    }


    //Given string character array and integer k,
    //print all permutation with repeatation string length k
    public static void permRepeatedChooseK(String s, char[] array, int depth, int k, int[] arr, int num) {
        if(depth == k) {
            if(arr[0] == num)
                System.out.print("<"+num+">");
            System.out.print("{"+arr[0]+"}");
            arr[0]++;
            for(int i=0; i<depth; i++) {
                System.out.print("["+array[i]+"]");
            }
            System.out.println();
        } else {
            for(int i=0; i<s.length(); i++) {
                array[depth] = s.charAt(i);
                permRepeatedChooseK(s, array, depth+1, k, arr, num);
            }
        }
    }
    
    //[ file=headertonumber.html title=""
    static int excelNum(String header){
        int sum = 0;
        if(header != null){
            int len = header.length(); 
            for(int i=0; i<len; i++){
                int n = header.charAt(len-1 - i) - 'A' + 1;
                sum += n*Math.pow(26, i);
            }
        }
        return sum;
    }
    //]

    //[ file=numbertoheader.html title=""
    // 0 -> 'A'
    // 1 -> 'B'
    // 25 -> 'Z'
    // num = 1 -> 'A'
    // num = 26 -> 'A' + 25 = 'Z'
    // num = 27
    // reminder = 0 -> 'A'
    // num = 1
    // reminder = 0 -> 'A'
    // num = 52
    // (52 - 1) % 26 = 25 -> 'Z'
    // 52 / 26 = 2
    //  x = ['A' - 'Z'] - 'A'
    //  x = [0 ... 25]
    //  
    //  n = x + 1
    //  sum = (x + 1)*pow(26, 2) + (x + 1)*pow(26, 1) + (x+1)*pow(26, 0)
    static String numToHeader(int num){
        String str = "";
        while(num > 0){
            int reminder = (num - 1) % 26;
            char ch = (char)(reminder + 'A');
            str = ch + "" + str;
            num = (num - 1) / 26;
        }
        return str;
    }
    //]

    static String printBinary(int n){
        String str = "";
        if( n == 0)    
            str += "0";
        else{     
            while(n > 0){
                int reminder = n % 2;
                str = (reminder + "") + str;
                n /= 2;
            }
        }
        return str;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class ExcelNumberBinary{
    public static void main(String[] args) {
        test1();
        test3();

        test0_excel();
        test1_excel();
        test2_excel();

        test0_printExcel();
        test1_printExcel();
        test2_printExcel();
    }
    public static void test0() {
        Aron.beg();
        String str = intToAlphabet(0);
        Print.pb(str);
        Aron.end();
    }
    public static String intToAlphabet(int n) {
            int num = (int)'a' + n;
            char ch = (char)num;
            return "" + ch;
    }
    public static void test1() {
        Aron.beg();
        int num = 16;
        printAllBinary(num);
        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        int num = 17;
        printAllBinary(num);
        Aron.end();
    }

    //[ file=printbin.html title=""
    /**
    * print all binary from zero to num-1 with length log2(num)
    * @param num maximum number 
    */
    public static void printAllBinary(int num) {
        String str = "";
        int binLen = (int)Math.ceil(Math.log(num)/Math.log(2));

        for(int j=0; j<num; j++){
            int n = j;
            for(int i=0; i<binLen; i++){
                if(n % 2 == 0)
                    str = "0" + str;
                else
                    str = "1" + str;

                n = n/2;
            } 
            Print.pbl(str);
            str = "";
        } 
    }
    //]


    //[ file=binexcel.html title=""
    // [1 -> 26] = ['A' -> 'Z']
    // [0 -> 25]   ['A' -> 'Z'] 
    public static void excelNumSaveLength(int num) {
        int binLen = 1;
        if(num == 1) 
            binLen = 1;
        else 
            binLen = (int)Math.ceil(Math.log(num)/Math.log(26));

        for(int j=1; j<=num; j++){
            int n = j;
            String str = "";
            for(int i=1; i<=binLen; i++){
                String s = Aron.intToAlphabetUpper((n-1)%26);
                str = s + str;
                n = (n-1)/26;
            } 
            Print.pbl(str);
        } 
    }
    //]
    //[ file=excelnum1.html title=""
    // [1 -> 26] = ['A' -> 'Z']
    // [0 -> 25]   ['A' -> 'Z'] 
    public static void printExcel(int num){
        int base = 26;
        for(int i=1; i<=num; i++){
            int x = i;
            String str = "";
            if(x-1 == 0)
                str = 'A' + str;
            else{
                while( x > 0){
                    int r = (x-1) % base;
                    String s = Aron.intToAlphabetUpper(r);
                    str = s + str;
                    x = (x-1) / base;
                }
            }
            Print.pbl(str);
        }
    }
    //]

    public static void test0_excel() {
        Aron.beg();
        int num = 26;
        excelNumSaveLength(num);

        Aron.end();
    }
    public static void test1_excel() {
        Aron.beg();
        int num = 1; 
        excelNumSaveLength(num);

        Aron.end();
    }
    public static void test2_excel() {
        Aron.beg();
        int num = 27; 
        excelNumSaveLength(num);
        Aron.end();
    }
    public static void test0_printExcel() {
        Aron.beg();
        int num = 1; 
        printExcel(num);
        Aron.end();
    }
    public static void test1_printExcel() {
        Aron.beg();
        int num = 26; 
        printExcel(num);
        Aron.end();
    }
    public static void test2_printExcel() {
        Aron.beg();
        int num = 27; 
        printExcel(num);
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

//[ file=throw.html title=""
// User-defined Exception
class BigException extends Exception{
    public BigException(String msg){
        super(msg);
    }
}

class SmallException extends Exception{
    public SmallException(String msg){
        super(msg);
    }
}


public class ExceptionExample{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    // throw IOException and try/catch them
    static void test0(){
        Aron.beg();

        try{
            openFile("text/myfile1.txt");
        }catch(IOException e){
            System.err.println(e.getMessage());
        }

        Aron.end();
    }
    
    static void test1(){
        Aron.beg();
        openFile1("text/myfile1.txt");
        Aron.end();
    }
    
    static void test2(){
        Aron.beg();
        sizeMatter(20);
        sizeMatter(1000);
        sizeMatter(-1000);
        Aron.end();
    } 

    static void sizeMatter(int n){
        try{
            if(n > 100){
                throw new BigException("Too big BigException");
            }else if(n < -100){
                throw new SmallException("Too small SmallException");
            }
        }catch(BigException e){
            Print.p(e.getMessage());
        }catch(SmallException e){
            Print.p(e.getMessage());
        }
    }
    static void openFile(String fName) throws IOException{
        BufferedReader br = new BufferedReader(new FileReader(fName));
        String line = null;
        while( (line = br.readLine()) != null){
            Print.pl(line);
        }
        throw new IOException("Yep, throw IOException");
    }

    static void openFile1(String fName) {
        try{
            BufferedReader br = new BufferedReader(new FileReader(fName));
            String line = null;
            while( (line = br.readLine()) != null){
                Print.pl(line);
            }
        }catch(IOException e){
            System.err.println(e.getMessage());
        }
    }
    //]
} 
import java.util.*;
import java.io.*;
import classfile.*;

public class ExeCommand{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        String output = Aron.executeCommand("ls");
        Print.pbl(output);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import classfile.*;

// Fiabonacci number with matrix, fiabonacci matrix 
class Fibonacci {
    public static void main(String args[]) {
        int n=10;
        int[][] Arr = new int[2][2];
        int[][] A = nFibonacciNum2(Arr, n);
        System.out.println("A[1][0]=" + A[1][0]);

        int fib = nFibonacciNum1(n);
        System.out.println("fib=" + fib);
    }
    //O(n^2)
    public static int nFibonacciNum(int n) {
        if(n == 0)
            return 0;
        else if(n==1)
            return 1;
        return nFibonacciNum(n-1)+nFibonacciNum(n-2);
    }

    //O(n)
    public static int nFibonacciNum1(int n) {
        int ret=0;
        if(n==0)
            ret = 0;
        else if(n==1)
            ret = 1;
        else {
            int a=0;
            int b=1;
            int c=1;
            int count=2;
            while(count <= n) {
                c = a + b;
                a = b;
                b = c;
                count++;
            }
            ret = c;
        }
        return ret;
    }
    //O(logn)
    public static int[][] nFibonacciNum2(int[][] A, int n) {
        if(n==0) {
            A[0][0] = 0;
            A[1][0] = 0;
            A[0][1] = 0;
            A[1][1] = 0;
            return A;
        } else if(n==1) {
            A[0][0] = 1;
            A[1][0] = 1;
            A[0][1] = 1;
            A[1][1] = 0;
            return A;
        } else {
            if(n%2 == 0)
                return MultiMat(nFibonacciNum2(A, n/2), nFibonacciNum2(A, n/2));
            else
                return MultiMat(A, MultiMat(nFibonacciNum2(A, (n-1)/2), nFibonacciNum2(A, (n-1)/2)));
        }
    }

    public static int[][] MultiMat(int[][] A1, int[][] A2) {
        int[][] A = new int[2][2];

        A[0][0] = A1[0][0]*A2[0][0] + A1[0][1]*A2[1][0];
        A[1][0] = A1[1][0]*A2[0][0] + A1[1][1]*A2[1][0];
        A[0][1] = A1[0][0]*A2[1][0] + A1[0][1]*A2[1][1];
        A[1][1] = A1[1][0]*A2[0][1] + A1[1][1]*A2[1][1];
        return A;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// FileOutStream example, outputstream, output stream, write raw data to file,
// filetream filestream, stream file, write byte[] to file,
public class FileOutStreamExample {
    public static void main(String[] args) {
        test0();
    }
    public static void test0() {
        Aron.beg();

        File file = new File("./text/raw1.txt");
        String content = "write byte[] array to file";

        try (FileOutputStream fop = new FileOutputStream(file)) {
            // if file doesn't exists, then create it
            if (!file.exists()) {
                file.createNewFile();
            }

            // get the content in bytes
            byte[] contentInBytes = content.getBytes();

            fop.write(contentInBytes);
            fop.flush();
            fop.close();

            System.out.println("Done");

        } catch (IOException e) {
            e.printStackTrace();
        }

        Aron.end();
    }
}

import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
import java.io.*;
//
import classfile.*; 

// FileInputStream example, FileOutputStream example, 
// FileInputStream, FileOutputStream, read raw byte[] from file, read binary file
// read chunk file, skip file, seek file, 
class FileRead {
    public static void main(String args[]) {
//        test0();
        test1();
//        test2();
    }
    
    static void test0(){
        Aron.beg();

        try {
            // Open the file that is the first
            // command line parameter

            String fName = "/Users/cat/myfile/github/java/text/file3.txt";
            FileInputStream fstream = new FileInputStream(fName);
            // Get the object of DataInputStream
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String strLine;
            //Read File Line By Line
            while ((strLine = br.readLine()) != null) {
                // Print the content on the console
                System.out.println (strLine);
            }
            //Close the input stream
            in.close();
        } catch (Exception e) {
            //Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }
        Aron.end();
    }
    static void test1(){
        Aron.beg();

//        try {
//            String fName = "/Users/cat/myfile/github/java/text/file3.txt";
//            File file = new File(fName);
//
//            FileInputStream fstream = new FileInputStream(fName);
//            int nbyte = 0;
//            //Read File Line By Line
//            byte[] arr = new byte[20];
//            while ((nbyte = fstream.read(arr)) != -1) {
//                for(int i=0; i<nbyte; i++){
//                    Print.pbl(arr[i]);
//                } 
//                String str = new String(arr);
//                Print.pbl(str + " size=" + nbyte);
//            }
//            //Close the input stream
//            fstream.close();
//        } catch (Exception e) {
//            //Catch exception if any
//            System.err.println("Error: " + e.getMessage());
//        }
        
        String fName = "/Users/cat/myfile/github/java/text/file3.txt";
        int bufSize = 40;
        List<String> list = readFileLineByte(fName, bufSize); 
        Aron.printList(list);
        Aron.end();
    }
    public static List<String> readFileLineByte(String fName, int bufSize){
        List<String> list = new ArrayList<String>(); 
        try {
            FileInputStream fstream = new FileInputStream(fName);
            int nbyte = 0;
            //Read File Line By Line
            byte[] arr = new byte[bufSize];
            byte[] lineArr = new byte[bufSize];
            int k=0;
            while ((nbyte = fstream.read(arr)) != -1) {
                String str = new String(arr);

                for(int i=0; i<nbyte; i++){
                    Print.pbl("char=" + arr[i]);
                    if(arr[i] == '\n'){
                        Print.pbl("newline=" + arr[i]);

                        lineArr[k] = arr[i];
                        list.add(new String(lineArr));
                        k = 0;
                        lineArr = new byte[bufSize];
                    }else{
                        lineArr[k] = arr[i];
                        k++;
                    }
                }
            }
            //Close the input stream
            fstream.close();
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
        }
        return list;
    }
    
    static void test2(){
        Aron.beg();
        String currDir = "/Users/cat/myfile/github/java";
        List<String> list = Aron.getCurrentDirs(currDir);
        Aron.printList(list);
        List<String> flist = Aron.getCurrentFiles(currDir);
        Ut.l();
        Aron.printList(flist);

        Aron.end();
    }
}
import java.util.*;
import java.util.stream.*;
import java.io.*;
import classfile.*;

public class Filter {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        List<Integer> list1 = Arrays.asList(1, 2, 3); 
        List<Integer> list2 = Arrays.asList(2, 1, 3); 
        List<Integer> left = list1.stream().filter(x -> x < 2).collect(Collectors.toList());
        List<Integer> right = list1.stream().filter(x -> x > 2).collect(Collectors.toList());
        Aron.printList(left);
        Aron.printList(right);

        

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
}

public class FindKeyRotateArray {
    public static void main(String[] args) {
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
    }

    public static void test0() {
        System.out.println("Find the max element in a sorted and rotated array");
        int[] array = {1, 2, 3};
        int left = 0;
        int right = array.length - 1;
        int key = 1;
        boolean ret = findKey(array, left, right, key);
        //boolean ret1 = binarySearch(array, left, right, key);
        boolean ret2 = findKey(array, left, right, key);
        System.out.println("key="+ret);
        //System.out.println("key1="+ret1);
        System.out.println("key2="+ret2);
    }
    public static void test1() {
        System.out.println("Find the max element in a sorted and rotated array");
        int[] array = {1, 2, 3};
        int left = 0;
        int right = array.length - 1;
        int key = 1;
        Aron.printArray(array);
        System.out.println("key="+key);
        boolean ret = findKey(array, left, right, key);
        System.out.println("key="+ret);
    }

    public static void test2() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {1, 2, 3};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }
    public static void test3() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test4() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test5() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test6() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex2(array, left, right);
        System.out.println("index="+index);
    }

    public static void test7() {
        System.out.println("Find the min Index in a sorted and rotated array");
        int[] array = {3, 2};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMinIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test8() {
        System.out.println("Find the min Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMinIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static int findMaxIndex(int[] array, int left, int right) {
        int ret = -1;
        int len = right - left + 1;
        if( len == 1)
            ret = left;
        else if( len == 2)
            ret = array[left] > array[right]? left:right;
        else if(len > 2) {
            int mid = (left + right)/2;
            if(array[left] < array[mid])
                ret = findMaxIndex(array, mid, right);
            else
                ret = findMaxIndex(array, left, mid);
        }
        return ret;
    }

    public static boolean findKey(int[] array, int left, int right, int key) {
        if(left == right)
            return array[left] == key;

        int maxIndex = findMaxIndex(array, left, right);
        return binarySearch(array, left, maxIndex, key) || binarySearch(array, maxIndex+1, right, key);
    }
    public static boolean binarySearch(int[] array, int left, int right, int key) {
        boolean ret = false;
        if(array != null) {
            int mid = (left + right)/2;
            if(left < right) {
                if(key < array[mid]) {
                    ret = binarySearch(array, left, mid-1, key);
                } else if(key > array[mid]) {
                    ret = binarySearch(array, mid+1, right, key);
                } else
                    ret = true;
            } else if(left == right)
                ret = array[left] == key;
        }
        return ret;
    }

    // 1 2 3
    // 2 3 1
    // 1
    public static int findMinIndex(int[] array, int left, int right) {
        if(array != null) {
            if(array[left] < array[right])
                return left;
            else {
                int mid = (left + right)/2;
                if(array[mid] < array[right])
                    return findMinIndex(array, left, mid);
                else if(array[mid] > array[right])
                    return findMinIndex(array, mid+1, right);
                else if(array[mid] == array[right])
                    return mid;
            }
        }
        return -1;
    }
    // 1 2 3
    // 2 3 1
    // 3 1
    //
    // 3 1 2

    public static int findMaxIndex2(int[] array, int left, int right) {
        if( array != null) {
            //no rotation
            // {2}
            // {2, 3}
            if(array[left] < array[right])
                return right;
            else {
                //One rotation at least
                int mid = (left + right)/2;
                if(array[left] < array[mid])
                    return findMaxIndex2(array, mid, right);
                else if(array[left] > array[mid])
                    return findMaxIndex2(array, left, mid);
                else if(array[left] == array[mid])
                    return mid;
            }
        }
        return -1;
    }

    //No duplicated elements in the array
    public static boolean findKeyRotateArray(int[] array, int left, int right, int key) {
        boolean ret = false;
        if(array != null) {
            int len = right - left + 1;
            if(len == 1) {
                if(key == array[left])
                    ret = true;
            } else if (len > 1) {
                int mid = (left + right)/2;
                if(array[left] < array[mid]) {
                    if(key > array[mid])
                        ret = findKey(array, mid+1, right, key);
                    else if(key < array[mid]) {
                        if(array[left] < key)
                            ret = findKey(array, left, mid-1, key);
                        else if(array[left] > key)
                            ret = findKey(array, mid+1, right, key);
                        else
                            ret = true;
                    } else
                        ret = true;
                } else if(array[left] > array[mid]) {
                    if(key < array[mid])
                        ret = findKey(array, left, mid-1, key);
                    else if(key > array[mid]) {
                        if(key < array[left]) {
                            ret = findKey(array, mid+1, right, key);
                        } else if(key > array[left]) {
                            ret = findKey(array, left, mid-1, key);
                        } else
                            ret = true;
                    } else
                        ret = true;
                } else {
                    ret = array[left] == key || array[right] == key? true : false;
                }
            }
        }
        return ret;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
    public Node parent;
	public int data;
    boolean isVisited;
	public Node(int n)
	{ data = n; left = right = parent = null; isVisited = false;}
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ 
                        cur.left = new Node(n); end = true; 
                        cur.left.parent = cur;
                    }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ 
                        cur.right = new Node(n); end = true; 
                        cur.right.parent = cur;
                    }
					else
						cur = cur.right;
				}
			}
		}
	}

	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	
	public Node getRoot()
	{ return root;}
}
class FindKthNeighbour 
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();

		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);

		Node r = b1.getRoot();
		Inorder(r);
        //
		int[] Arr = new int[100];
		int len=0;
        Node initNode = r;

        List<Node> list = new LinkedList<Node>();
        Node randNode = GetRandomNode(r, initNode, list); 
        System.out.println("randNode["+randNode.data+"]");
        PrintAllKthNeighbour(randNode, 3);
	}
	
    public static Node GetRandomNode(Node node, Node initNode, List<Node> list)
    {
        if(node != null)
        {
            GetRandomNode(node.left, initNode, list);
            list.add(node);
            GetRandomNode(node.right, initNode, list);
            Random rand = new Random();
            if(initNode == node)
            {
                int index = rand.nextInt(list.size()); 
		        System.out.println("rand=["+index+"] list=["+list.size()+"]");
                return list.get(index);
            }
        }
        return null;
    }
    public static void PrintAllKthNeighbour(Node node, int k)
    {
        if(node != null && !node.isVisited)
        {
            node.isVisited = true;
            if(k == 0)
            {
		        System.out.println("Neighbour["+node.data+"]");
            }
            else
            {
                k--;
                PrintAllKthNeighbour(node.left, k);
                PrintAllKthNeighbour(node.right, k);
                PrintAllKthNeighbour(node.parent, k);
            }
        }
    }
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
public class FindMaxRotateArray 
{
				public static void main(String[] args)
				{
                    System.out.println("Find the max element in a sorted and rotated array");
                    int[] array = {1, 2, 4};
                    int left = 0;
                    int right = array.length - 1;
                    int max = findMax(array, left, right);
                    int key = 2;
                    boolean ret = findKey(array, left, right, key);
                    System.out.println("max="+max);
                    System.out.println("key="+ret);
				}
                public static int findMax(int[] array, int left, int right)
                {
                    int ret = 0; 
                    int len = right - left + 1;
                    if( len == 1)
                        ret = array[left];
                    else if( len == 2)
                        ret = array[left] > array[right]? array[left]:array[right];
                    else if(len > 2)
                    {
                        int mid = (left + right)/2;
                        if(array[left] < array[mid])
                            ret = findMax(array, mid, right);
                        else 
                            ret = findMax(array, left, mid);
                    }
                    return ret;
                }
                //No duplicated elements in the array
                public static boolean findKey(int[] array, int left, int right, int key)
                {
                    boolean ret = false;    
                    if(array != null)
                    {
                        int len = right - left + 1; 
                        if(len == 1)
                        {
                            if(key == array[left])
                                ret = true;
                        }
                        else if (len > 1)
                        {
                            int mid = (left + right)/2;    
                            if(array[left] < array[mid])
                            {
                                if(key > array[mid])
                                    ret = findKey(array, mid+1, right, key);
                                else if(key < array[mid])
                                {
                                    if(array[left] < key)
                                        ret = findKey(array, left, mid-1, key);
                                    else if(array[left] > key)
                                        ret = findKey(array, mid+1, right, key);
                                    else 
                                        ret = true;
                                }
                                else
                                    ret = true;
                            }
                            else if(array[left] > array[mid])
                            {
                                if(key < array[mid])
                                    ret = findKey(array, left, mid-1, key);
                                else if(key > array[mid])
                                {
                                    if(key < array[left])
                                    {
                                        ret = findKey(array, mid+1, right, key);
                                    }
                                    else if(key > array[left])
                                    {
                                        ret = findKey(array, left, mid-1, key);
                                    }
                                    else
                                        ret = true;
                                }
                                else
                                    ret = true;
                            }
                            else
                            {
                                ret = array[left] == key || array[right] == key? true : false;
                            }
                        }
                    }
                    return ret;
                }
}
import java.util.*;

public class FindMedianLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Find the median of linkedlist");
        SLL s1 = new SLL();
        s1.append(2);
        s1.append(20);
        s1.append(30);
        s1.append(40);
        s1.append(50);

        Node node = median(s1.getHead());
        System.out.println("median["+node.data+"]");
    }

    public static void show(Node curr)
    {
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }
    
    public static Node median(Node head)
    {
        Node curr = head;
        Node mcurr = curr;
        if(curr != null)
        {
            while(curr.next != null)
            {
                curr = curr.next.next;
                if(curr == null)
                    break;
                mcurr = mcurr.next;
            }
        }
        return mcurr;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class FindNegative2DMat 
{
	public static void main(String args[])
	{
			int[][] Arr = new int[3][4];
			gen2D(Arr);
			int s = FindNegative(Arr);
			System.out.println("s=" + s);
	}

	public static void gen2D(int[][] Arr)
	{
		int row, col;
		if(Arr != null)
		{
			row = Arr.length;
			col = Arr[0].length;
			Arr[0][0] = -2;
			Random r = new Random();
			for(int i=0; i<row; i++)
			{
				int ran = r.nextInt(3); 
				for(int j=0; j<col; j++)
				{
					if(i-1>=0 && j-1>=0)
					Arr[i][j] = Arr[i-1][j]+ Arr[i][j-1]+ran + 5;
					else if(j-1>=0)
						Arr[i][j] = Arr[i][j-1]+ran;
					else if(i-1>=0)
						Arr[i][j] = Arr[i-1][j]+ran;

					System.out.print(String.format("%10s", Arr[i][j]));
				}
				System.out.println();
			}
		}
	}
	public static int FindNegative(int[][] Arr)
	{
		int sum=0;
		if(Arr != null)
		{
			int nRow = Arr.length;
			int nCol = Arr[0].length; 

			int down = 0;
			int left = nCol-1;

			while(down < nRow && left >=0)
			{
				if(Arr[down][left] < 0)
				{
					sum = sum + left + 1;
					down++;
				}
				else 
					left--;
			}
		}
		return sum;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class FindNode 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(10);
		b1.Insert(5);
		b1.Insert(15);
        
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
        

        System.out.println("Before Swap");
        inorder(b1.getRoot());

        System.out.println("============");
        System.out.println("After Swap");

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        swap(199, 16, b1.getRoot(), first, second);
        
        inorder(b1.getRoot());
        System.out.println("============");
        findNode(b1.getRoot(), 199);
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            else if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    public static boolean findNode(Node node, int k)
    {
        if(node != null)
        {
            if(findNode(node.left, k))
            {
                System.out.println(node.data);
                return true;
            }

            if(node.data == k)
            {
                System.out.println(k);
                return true;
            }

            if(findNode(node.right, k))
            {
                System.out.println(node.data);
                return true;
            }
        }
        return false;
    }
    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
		        System.out.println(node.data);
            inorder(node.right);
        }
    }
}
import java.util.*;

class Node {
    char ch;
    public Node(char ch) {
        this.ch = ch;
    }
}

// get first non duplicated char from a stream
// use HashMap and Double LinkedList
public class FirstOccurCharFromStream {
    public static void main(String[] args) {
        System.out.println("Find the first occurrence character from a stream");
        String str = "kkc";
        char ch = FirstOccurrence(str);
        System.out.println("ch=["+ch+"]");
    }
    public static char FirstOccurrence(String str) {
        char ret = 0;
        List<Node> list = new LinkedList<Node>();
        if(str != null) {
            Map<Integer, Node> map = new HashMap<Integer, Node>();
            int len = str.length();
            for(int i=0; i<len; i++) {
                char ch = str.charAt(i);
                if(map.containsKey((int)ch)) {
                    Node node = map.get((int)ch);
                    if(node != null) {
                        list.remove(node);
                        map.put((int)ch, null);
                    }
                } else {
                    Node node = new Node(ch);
                    map.put((int)ch, node);
                    list.add(node);
                }
            }
        }
        if(list.size() > 0)
            ret = list.get(0).ch;
        return ret;
    }
}
import java.util.*;


//single linked list
class Node 
{
	Node next;
	int data;
	public Node(int n)
	{ next = null; data = n;}
}

class SLL
{
	Node head;
	public SLL()
	{ head = null;}
	public void append(int n)
    {
        Node cur = head;
		if(head == null)
			head = new Node(n);
		else
		{
			while(cur.next != null)
			{ 
                cur = cur.next; 
            }
			cur.next = new Node(n);
		}

    }
	public void append(Node no)
	{
		Node cur = head;
		if(head == null)
			head = no;
		else
		{
			while(cur.next != null)
			{ cur = cur.next; }
			cur.next = no;
		}
	}

	//recursive 
	static Node next=null;
	public void Reverse(Node cur)
	{
		if(cur != null)
		{
			Reverse(cur.next);
			if(next != null)
				next.next = cur;	
			else 
				head = cur;
			next = cur;
			cur.next = null;
		}
	}
	//iteration
	public void Reverse1(Node cur)
	{
		if(head != null)
		{
			Node prev = null;
			Node next = cur.next;

			while(cur != null)
			{
				cur.next = prev;
				prev = cur;
				cur = next;
				if(next != null)
					next = next.next;
			}
			head = prev;
			
		}
	}
	public Node getHead()
	{ return head;}

    public Node getTail()
	{ 
        Node curr = head;
        while(curr != null && curr.next != null)
        {
            curr = curr.next;
        }
        return curr;
    }

	public void Remove(Node no)
	{
		if(no != null && head != null)
		{
			Node cur = head;	
			Node prev = null;
			while(cur != no)
			{
				prev = cur;
				cur = cur.next;
			}
			if(prev != null && no.next != null)
			{ prev.next = no.next; no.next = null; }
			else if(prev == null && no.next != null)
			{ head = no.next; no.next = null; }
			else if(prev != null && no.next == null)
			{ prev.next = null; }
			else 
			{ no = null; head = null;}
		}	
	}
	public void show()
	{
		Node cur=head;
		while(cur != null)
	 	{ System.out.println("cur.data=" + cur.data); cur=cur.next;}
	}
}

public class FixSortedLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    public static void test1()
    {
        SLL s1 = new SLL();
        s1.append(1);
        s1.append(2);
        s1.append(4);
        s1.append(3);
        s1.append(5);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    public static void test2()
    {
        SLL s1 = new SLL();
        s1.append(3);
        s1.append(2);
        s1.append(1);
        s1.append(4);
        s1.append(5);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    public static void test3()
    {
        SLL s1 = new SLL();
        s1.append(3);
        s1.append(2);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }
    public static void test4()
    {
        SLL s1 = new SLL();
        s1.append(3);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    public static void test5()
    {
        SLL s1 = new SLL();
        s1.append(Integer.MIN_VALUE);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }
    public static void test6()
    {
        SLL s1 = new SLL();
        s1.append(Integer.MAX_VALUE);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }
    public static void test7()
    {
        SLL s1 = new SLL();
        s1.append(Integer.MAX_VALUE);
        s1.append(Integer.MIN_VALUE);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    // Fix reversed sublist in a single linkedlist
    // Input: 1->2->3->5->4->6  (5->4) reverse
    // output:1->2->3->4->5->6
    public static void Fix(Node head)
    {
        Stack<Integer> stack = new Stack<Integer>();
        Node curr = head;

        Node minNode = new Node(Integer.MIN_VALUE);
        minNode.next = curr;
        curr = head = minNode;
        while(curr != null && curr.next != null)
        {
            curr = curr.next; 
        }
        Node prev = curr;
        curr.next = new Node(Integer.MAX_VALUE);
        Node start = null;
        curr = head;
        while(curr != null)
        {
            Node next = curr.next;
            if(next != null)
            {
                if(curr.data > next.data)
                {
                    stack.push(curr.data);
                    if(start == null)
                        start = curr;
                }
                else if(start != null)
                {
                    stack.push(curr.data);
                    break;
                }
            }
            curr = next;
        }
        while(start != null && !stack.empty())
        {
            start.data = stack.pop();
            System.out.println("start.data["+start.data+"]");
            start = start.next;
        }
        head = head.next;
        prev.next = null;

    }

    public static void show(Node head)
    {
        Node curr = head;
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }

}
import classfile.*;

public class FlapBST {
    public static void main(String[] args) {
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(20);
        bst.insert(1);
        //Aron.binImage(bst.root);
        Aron.inorder(bst.root);
        flap(bst.root);
        Ut.l();
        Aron.inorder(bst.root);
        Aron.binImage(bst.root);
        
    }
    public static void flap(Node root) {
        if(root != null) {
            flap(root.left);
            flap(root.right);
            Node tmp = root.left;
            root.left = root.right;
            root.right = tmp;
        }
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class FormatExample{
    public static void main (String[] args)
	{
		String sendID = "AABB";
        String output = String.format("%0"+(10-sendID.length())+"d%s", 0, sendID);
        System.out.println(output);
	}
} 

import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	
    public Node getRoot()
	{ return root;}
}
class GeneBinaryTree
{
	public static void main(String args[])
	{
		BST b1 = new BST();

		b1.Insert(15);
		b1.Insert(12);
		
		b1.Insert(14);
		b1.Insert(17);
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
		b1.Insert(20);
		b1.Insert(18);

		Node r = b1.getRoot();

		System.out.println("digraph G{");
        int level = 0;
        Inorder(r, level);
		System.out.println("}");
	}
    	
	public static void Inorder(Node root, int level) {
		if(root != null) {
			//System.out.println("" + root.data + "[label=" + root.data +"];");
			System.out.println(root.data);
            if(root.left != null){
			    System.out.print("" + root.data + "->");
            }
			Inorder(root.left, level+1);

            if(root.right != null){
			    System.out.print("" + root.data + "->");
            }
			Inorder(root.right, level+1);
		}
	}
}
import java.util.ArrayList;
import java.util.List;
class Node
{
    Map<String, Node> map = new HashMap<String, Node>();
}

class Tree
{
    Node root;
    public Tree()
    {
    }
}

public class GeneralTree 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

/**
* Generate Java simple template code
*/ 
public class GenerateProgram{
    final static String fName = "/Users/cat/myfile/github/java/text/program.txt";
    public static void main(String[] args) {
        printInfo();
        Print.p("Argument len=" + args.length);

        for(String s : args){
            Print.p("args:" + s);
        }
        if(args.length > 0)
            generateCode(args[0]);
        else
            Print.p("No Class Name is provided");
    }

    public static void printInfo(){
        Print.pb(fName);
    }
    /**
    * Generate Java file from a class name(e.g. MyClass => MyClass.java)
    */ 
    public static void generateCode(String pName){
        Aron.beg();
        List<String> list = Aron.readFile(fName);

        for(int i=0; i<list.size(); i++){ 
            String s = list.get(i);
            String newStr  = s.replace("Program", pName);
            Print.p(newStr);
            list.set(i, newStr);
        }
        Aron.line();

        List<String> list2 = new ArrayList<String>(); 
        for(int i=0; i<list.size(); i++){ 
            String s = list.get(i);
            Print.p(s);
            list2.add(s + "\n");
        }

        String newName = "/Users/cat/myfile/github/java/" + pName + ".java";
        Aron.writeFile(newName, list2);

        Aron.end();
    }
} 
import java.io.*;
import java.lang.String;
import java.util.*;
import java.lang.reflect.*;

import classfile.*;

// get all methods, all method, method signature
public class GetAllMethods{
    public static void main(String[] args) {
        //Method method = Test.getClass().getMethod();
        //Parameter para = new CachingParameter();

//        Class<String> clz = String.class;
//        for (Method m : clz.getDeclaredMethods()) {
//           System.err.println(m.getName());
//           for (Parameter p : m.getParameters()) {
//              System.err.println("  " + p.getName());
//           }
//        }

        Class<GetAllMethods> clz = GetAllMethods.class;
        for (Method m : clz.getDeclaredMethods()) {
           System.err.println(m.getName());
           for (Parameter p : m.getParameters()) {
              System.err.println("  " + p.getName());
           }
        }

        for(Method m : GetAllMethods.class.getMethods()) {
            Class<?>[] parameterTypes = m.getParameterTypes();
            for(Class<?> t : parameterTypes){
              System.out.println("type:" + t.getName());
            }
            Class<?> returnType = m.getReturnType();
            // funny stuff goes here
        }
    }
    static void print(String str1, int num){
    }
    static void test0(){
        Aron.beg();
        Aron.end();
    }
} 
import java.io.*;
class GetCurrentPath 
{
	public static void main(String args[])
	{
					File currentPath = new File(new File(".").getAbsolutePath());
					System.out.println("absoluatepath="+currentPath.getAbsolutePath());
					try{
					System.out.println("canonicalpath="+currentPath.getCanonicalPath());
					}catch(IOException e)
					{
					}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.lang.reflect.*;

class GetMethod{
    public void foo() { }
    public String baz() {
        return "";
    }
    //[ file=getmethod.html title=""
    public static void main(String args[]) {
        try {
            Class c = GetMethod.class;
            Method[] m = c.getDeclaredMethods();
            for (int i = 0; i < m.length; i++)
                System.out.println(m[i].toString());
        } catch (Throwable e) {
            System.err.println(e);
        }
    }
    //]
}

import java.io.*;
import java.util.*;
class GivenSumPair 
{
	public static void main(String args[])
	{
		int[] Arr = {7, 5, 6, 7, -10, 1};
		Pair(Arr, -9);

	}

	public static void Pair(int[] Arr, int sum)
	{
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		
		for(int i=0; i<Arr.length; i++)
		{
			if(map.containsKey(new Integer(Arr[i])))
			{
				Integer v = map.get(new Integer(Arr[i]));
				int n = v.intValue(); n++;
				map.put(new Integer(Arr[i]), new Integer(n));
			}
			else
			{
				map.put(new Integer(Arr[i]), new Integer(1));
			}
		}

		for(int i=0; i<Arr.length; i++)
		{
			int diff = sum - Arr[i];
			if(map.containsKey(new Integer(diff)))
			{
				Integer v = map.get(new Integer(diff));
				int n = v.intValue();
				if(n > 0)
				{ System.out.println(diff + " " + Arr[i]);
					n--;
					map.put(new Integer(diff), new Integer(n));
				}
				Integer v1 = map.get(new Integer(Arr[i]));
				int n1 = v1.intValue();
				if(n1 > 0)
				{ n1--;
					map.put(new Integer(Arr[i]), new Integer(n1));
				}
			}
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

// leftPad()
import org.apache.commons.lang3.StringUtils;

public class GraphExample{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        int level = 0;
        Node root = createGeneralTree();
        preorderGraph(root);
        Aron.prettyPrintGeneral(root, level);
        Aron.line();
        postorderGraph(root);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(7);
        b1.insert(15);
        b1.insert(1);
        b1.insert(5); 
        b1.insert(0); 

        b1.print();
        Aron.line();
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(51);
        b1.insert(16);
        b1.insert(35);
        b1.insert(45);
        b1.insert(15);
        b1.insert(1);
        b1.insert(95);
        b1.insert(7); 

        int level = 0;
        b1.print();
        Aron.line();
        Aron.prettyPrint(b1.root, level);
        Aron.line();
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root);

        Aron.end();
    } 

    static void test3(){
        Aron.beg();
        Node root = createGeneralTree();

        Aron.end();
    } 

    // create generate tree and pretty print 
    public static Node createGeneralTree(){
        Aron.beg();
        Node root = new Node(1);
        Node n1 = new Node(2);
        Node n2 = new Node(3);
        Node n3 = new Node(4);

        root.list.add(n1);
        root.list.add(n2);
        root.list.add(n3);

        Node nn1 = new Node(22);
        Node nn2 = new Node(33);
        Node nn3 = new Node(44);

        Node nn11= new Node(222);
        Node nn22 = new Node(333);
        Node nn33 = new Node(444);

        n1.list.add(nn1);
        n1.list.add(nn2);
        n1.list.add(nn3);

        n2.list.add(nn11);
        n2.list.add(nn22);
        n2.list.add(nn33);

        int level = 0;
        Aron.prettyPrintGeneral(root, level);

        return root;
    }

    public static void preorderGraph(Node curr){
        if(curr != null){
            Print.pbl(curr.data);
            for(Node n : curr.list){
                preorderGraph(n);
            }
        }
    }

    public static void postorderGraph(Node curr){
        if(curr != null){
            for(Node n : curr.list){
                postorderGraph(n);
            }
            Print.pbl(curr.data);
        }
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class GraphLoopPath{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
    }
    static void test0(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n4);
        map.put(n2, n1);

        System.out.println("n1, n4=[" + isAPath(n1, n4, map, set) + "]"); 
        System.out.println("n2, n3=[" + isAPath(n2, n3, map, set) + "]"); 
        System.out.println("n1, n2=[" + isAPath(n1, n2, map, set) + "]"); 

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n4);
        map.put(n2, n1);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n4);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }

    static void test3(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);

        map.put(n1, n2);
        map.put(n2, n1);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }
    static void test4(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);

        n2.next = n3;

        map.put(n1, n2);
        map.put(n3, n1);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }

    static void test5(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 3;
        System.out.println("True[" + isPathMatrix(source, destination, arr2d, height, width) + "]"); 

        Aron.end();
    }

    static void test6(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 1;
        System.out.println("True[" + isPathMatrix(source, destination, arr2d, height, width) + "]"); 

        Aron.end();
    }

    static void test7(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 1;
        int destination = 2;
        System.out.println("False[" + isPathMatrix(source, destination, arr2d, height, width) + "]"); 

        Aron.end();
    }

    static void test8(){
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        List<Integer> list = new ArrayList<Integer>(); 

        int[][] arr2d = {
            {0, 2, 7, 0},
            {0, 0, 0, 4},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 3;
        int min = Integer.MAX_VALUE;
        System.out.println("min path[" + minPathMatrix(source, destination, list, min, arr2d, height, width) + "]"); 

        Aron.end();
    }
    static void test9(){
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        List<Integer> list = new ArrayList<Integer>(); 

        int[][] arr2d = {
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},

            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
        }; 

        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 3;
        int min = Integer.MAX_VALUE;
        System.out.println("min path[" + minPathMatrix(source, destination, list, min, arr2d, height, width) + "]"); 

        Aron.end();
    }

    //[ file=pathloop.html title=""
    //1, 1
    //
    //1, 4 
    //<1, 2->3>
    //<2, 4>
    //<3, 4>
    //<2, 1>
    //              1 
    //         2        3     
    //              4
    static boolean isAPath(Node sNode, Node dNode, Map<Node, Node> map, Set<Node> set){
        if(sNode != null && dNode != null){
            if(set.contains(sNode)){
                return false;
            }else{
                set.add(sNode);
            }
            if(sNode.data == dNode.data)
                return true;
            else{
                Node curr = map.get(sNode);
                while(curr != null){
                    if(curr.data == dNode.data){
                        return true;
                    }else{
                        return isAPath(curr.next, dNode, map, set);
                    }
                }
            }
        }
        return false;
    }

    static boolean isLoop(Node curr, Map<Node, Node> map, Set<Node> set){
        if(curr != null){
            if(set.contains(curr)){
                return true;
            }else{
                set.add(curr);
                Node child = map.get(curr);
                while(child != null){
                    if(isLoop(child, map, set))
                        return true; 
                    child = child.next;
                }
                set.remove(curr);
            }
        }
        return false;
    }

    static boolean isPathMatrix(int s, int d, int[][] arr, int height, int width){
        if(arr != null && s < height){
            if(s == d)
                return true;
            else{
                for(int i=0; i< width; i++){
                    if(arr[s][i] == 1){
                        return isPathMatrix(i, d, arr, height, width); 
                    }
                }
            }
        }
        return false;
    }

    static int maxSumBin(Node root, int sum, int max){
        if(root != null){
            if(root.left == null && root.right == null){
                return Math.max(sum + root.data, max);
            }else{
                int lmax = maxSumBin(root.left, sum + root.data);
                int rmax = maxSumBin(root.right, sum + root.data);

                return Math.max(lmin, rmin);
            }
        }
        return 0;
    }

    static int maxSumBin2(Node root){
        if(root != null){
            return Math.max(maxSumBin2(root.left), maxSumBin2(root.right)) + root.data;
        }
        return 0;
    }

    static int minPathMatrix(int s, int d, List<Integer> list, int min, int[][] arr, int height, int width){
        if(arr != null && s < height){
            if(s == d){
                int sum = 0;
                for(Integer n : list)
                    sum += n;
                min = Math.min(sum, min);
            }
            else{
                for(int i=0; i< width; i++){
                    if(arr[s][i] > 0){
                        list.add(arr[s][i]);
                        min = minPathMatrix(i, d, list, min, arr, height, width); 

                        if(list.size() > 0)
                            list.remove(list.size()-1);
                    }

                }
            }
        }
        return min;
    }
    //]
} 
interface HashMapInterface
{
    Object put(Object key, Object value);
    Object get(Object key);
    Object remove(Object key);
}

class Node
{
    Object key;
    Object value;
    Node next;
    public Node(Object key, Object value)
    {
        this.next = null;
        this.key = key;
        this.value= value;
    }
}
class HashMapClass implements HashMapInterface
{
    Node[] nodeArray;
    int size;
    public HashMapClass(int size)
    {
        this.size = size;
        nodeArray = new Node[size];
    }
    public Object put(Object key, Object value)
    {
        boolean done = false;
        Object ret = null;
        Node curr = nodeArray[key.hashCode() % this.size];
        while(curr != null && !done)
        {
            if(key != curr.key)
            {
                curr = curr.next;
            }
            else
            {
                ret = curr.value;
                done = true;
            }
        }
        return ret;
    }
    public Object get(Object key)
    {
        Object ret = null;
        if(key != null)
        {
            boolean done = false;
            Node curr = nodeArray[key.hashCode() % this.size];
            while(curr != null && !done)
            {
                if(key != curr.key)
                {
                    curr = curr.next;
                }
                else
                {
                    ret = curr.value;
                    done = true;
                }
            }
        }
        return ret;
    }
    public Object remove(Object key)
    {
        Object ret = null;
        if(key != null)
        {
            boolean done = false;
            Node curr = nodeArray[key.hashCode() % this.size];
            Node prev = curr;
            while(curr != null && !done)
            {
                if(key != curr.key)
                {
                    prev = curr;
                    curr = curr.next;
                }
                else
                {
                    ret = curr.value;
                    if(prev == curr)
                    {
                        prev = curr = null;
                    }
                    else
                    {
                        prev.next = curr.next;
                        done = true;
                    }
                }
            }
        }
        return ret;
    }
}

public class HashMapImple 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class HashMapIterate  
{
	public static void main(String args[])
	{
		Map<String, String> hashmap = new HashMap<String, String>();
		hashmap.put("key0", "str0");	
		hashmap.put("key1", "str1");	
		hashmap.put("key2", "str2");	
		hashmap.put("key3", "str3");	

		for(String key : hashmap.keySet())
		{
			String value = hashmap.get(key);
			System.out.println("hashmap["+key+","+value+"]");	
		}
	}
}
public class Haversine {
    public static final double R = 6372.8; // In kilometers
    public static double haversine(double lat1, double lon1, double lat2, double lon2) {
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        lat1 = Math.toRadians(lat1);
        lat2 = Math.toRadians(lat2);
 
        double a = Math.pow(Math.sin(dLat / 2),2) + Math.pow(Math.sin(dLon / 2),2) * Math.cos(lat1) * Math.cos(lat2);
        double c = 2 * Math.asin(Math.sqrt(a));
        return R * c;
    }
    public static void main(String[] args) {
        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

class Interval implements Comparable<Interval> {
    public int begin;
    public int end;
    public Interval(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }
    public int compareTo(Interval inter) {
        if(this.begin > inter.begin)
            return 1;
        else if(this.begin == inter.begin)
            return 0;
        else
            return -1;
    }
    public String toString() {
        return "[" + begin + " " + end + "]";
    }
}

public class Hello {
    public static void main(String[] args) {
        test0();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test00();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
        test19();
    }
    static void test00() {
        Aron.beg();
        PriorityQueue<Interval> queue = new PriorityQueue<Interval>();
        Stack<Interval> stack = new Stack<Interval>();
        int[] arr1 = {4, 1, 2, 6, 9};
        int[] arr2 = {5, 1, 4, 9, 10};

        for(int i=0; i<arr1.length; i++) {
            queue.add(new Interval(arr1[i], arr2[i]));
        }
        if(queue.size() > 0) {
            stack.push(queue.remove());
        }
        while(!queue.isEmpty()) {
            Interval top = stack.peek();
            Interval inter = queue.remove();
            if(top.end < inter.begin)
                stack.push(inter);
            else {
                stack.peek().end = Math.max(stack.peek().end, inter.end);
            }
        }
        while(!stack.empty()) {
            System.out.println("[" + stack.peek().begin + " " + stack.peek().end + "]");
            stack.pop();
        }

        Aron.end();
    }

    static void test0() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(5);
        sll.append(4);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = cloneLinkedList(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test2() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test3() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        sll.append(4);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test4() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test5() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test6() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test7() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseLinkedList(sll.head);
        Aron.printSLL(nhead);

        Aron.end();
    }

    static void test8() {
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseIte(sll.head);
        Aron.printSLL(nhead);
        Aron.end();
    }

    static void test9() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);

        SingleLinkedList sll2 = new SingleLinkedList();
        sll2.append(1);
        sll2.append(2);
        sll2.append(3);


        Node curr = sll.head;
        Node head = sll.head;

        while(curr != null && curr.next != null) {
            curr = curr.next;
        }
        curr.next = head;

        boolean circular = isCircular(sll.head);
        System.out.println("isCircular[" + circular + "]");

        boolean circular2 = isCircular(sll2.head);
        System.out.println("isCircular2[" + circular2 + "]");

        Aron.end();
    }
    static void test10(){
        Aron.beg();
        String str = "";
        System.out.println("empty str " + str + "[" + isBalance(str) + "]");

        str = "()";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "([)]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "()([])";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        Aron.end();
    }
    
    static void test11(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test12(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        h = insertNodeToSortedList(ssl.head, 5);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test13(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node newHead = insertNodeToSortedList(ssl.head, 15);
        Aron.printSLL(newHead);
        Aron.end();
    }

    static void test14(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);
        s1.append(7);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        s2.append(6);
        s2.append(11);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test15(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test16(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test17(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test18(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }
    static void test19(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(4);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    //[ file=nextnext.html title=""
    public static Node reverseIte(Node curr) {
        Node prev = null;
        Node next = null;
        while(curr != null) {
            next = curr.next;
            curr.next = prev;

            prev = curr;
            curr = next;
        }
        return prev;
    }

    public static Node reverseLinkedList(Node curr) {
        if(curr == null || curr.next == null)
            return curr;

        Node head = reverseLinkedList(curr.next);
        curr.next.next = curr;
        curr.next = null;

        return head;
    }

    public static Node reversePair(Node head) {
        Node curr = head;
        while(curr != null && curr.next != null) {
            int tmp = curr.data;
            curr.data = curr.next.data;
            curr.next.data = tmp;

            curr = curr.next.next;
        }
        return head;
    }

    public static boolean isCircular(Node curr) {
        if(curr == null)
            return false;
        else {
            Node next = curr.next;
            if(curr == next)
                return true;

            while(next != null) {
                if(curr == next)
                    return true;

                curr = curr.next;

                next = next.next;
                if(next != null)
                    next = next.next;
            }
        }
        return false;
    }
    //]


    static Node cloneLinkedList(Node head) {
        Node newHead = null;
        Node newCurr = null;
        Node curr = head;

        if(curr != null) {
            newCurr = newHead = new Node(head.data);

            while(curr.next != null) {
                newCurr.next = new Node(curr.next.data);
                newCurr = newCurr.next;
                curr = curr.next;
            }
        }
        return newHead;
    }

//    static boolean isBal(String str, int index){
//        if(str != null && index < str.length()){
//            if(!isBal(str, index + 1))
//                return false;
//
//            if(str.charAt(index) == '(' || str.charAt(index) == '[')
//                return isBal(str, index + 1);
//            else
//                return false;
//
//            else if(str.charAt(index) == ')'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '(') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }else if(str.charAt(index) == ']'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '[') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }
//        }
//        return true;
//    }

    static Node mergeSortedList(Node head1, Node head2){
        if(head1 == null)
            return head2;
        if(head2 == null)
            return head1;
        Node curr1 = head1;
        Node curr2 = head2;
        Node curr = null; 
        Node head = null;

        while(curr1 != null || curr2 != null){
            if(curr1 == null){
                if(curr != null)
                    curr.next = new Node(curr2.data);
                else
                    head = curr = new Node(curr2.data);

                curr2 = curr2.next;

            }else if(curr2 == null){
                if(curr != null)
                    curr.next = new Node(curr1.data);
                else
                    head = curr = new Node(curr1.data);

                curr1 = curr1.next;
            }else{
                if(curr1.data < curr2.data){
                    if(curr == null){
                        head = curr = new Node(curr1.data);
                    }else{
                        curr.next = new Node(curr1.data);
                    }

                    curr1 = curr1.next;
                }else{
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else{
                        curr.next = new Node(curr2.data);
                    }

                    curr2 = curr2.next;
                }
            }

            if(curr.next != null)
                curr = curr.next;
        }
        return head;
    }

    static Node insertNodeToSortedList(Node head, int num){
       Node curr = head; 
       Node prev = null;

       while(curr != null){
           if(curr.data < num){
               prev = curr;
               if(curr.next == null){
                   prev.next = new Node(num);
                   return head;
               }
           }else{
               if(prev != null){
                   prev.next = new Node(num);
                   prev.next.next = curr;
                   return head;
               }else{
                   // first node
                   Node node = new Node(num);
                   node.next = curr;
                   head = node;
                   return head;
               }
           }
           curr = curr.next;
       }
       return head;

    }

    static boolean isBalance(String str) {
        Stack<String> stack = new Stack<String>();
        if(str != null) {
            for(int i=0; i<str.length(); i++) {
                String s = str.charAt(i) + "";
                if(s.equals("(") || s.equals("[")) {
                    stack.push(s);
                } else {
                    if(s.equals(")")) {
                    if(!stack.empty() && stack.peek().equals("(")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else if(s.equals("]")) {
                    if(!stack.empty() && stack.peek().equals("[")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else {
                        System.out.println("Error");
                        return false;
                    }

                }
            }
        }
        return stack.empty();
    }
}
import java.util.HashMap;
import java.util.Map;
import java.util.Hashtable;
import java.util.HashSet;
import java.util.List;
import java.util.*;
import java.lang.Math;
import java.io.*;

import classfile.*;

class MyNode{
    public int data;
    public List<MyNode> list;
    public MyNode(int data){
        this.data = data;
        list = new ArrayList<MyNode>();
    }
}

class MyTree{
    public MyNode root;

    public MyTree(){
    }

    public void create(){
        root = new MyNode(1);
        root.list.add(new MyNode(2));
        root.list.add(new MyNode(3));

        MyNode branch = new MyNode(10);
        branch.list.add(new MyNode(11));
        branch.list.add(new MyNode(12));
        root.list.add(branch);

        MyNode branch1 = new MyNode(20);
        branch1.list.add(new MyNode(21));
        branch1.list.add(new MyNode(22));
        root.list.add(branch1);
    }
    public void printTree(MyNode node, int level, BufferedWriter bw){
        //Aron.beg();

        try{
            if(node != null){
                String format;

                if(level == 0)
                    format = "%1$1s";
                else
                    format = "%1$" + (level*10) + "s";

                //System.out.println(String.format(format, "[" + node.data));
                System.out.print(" [ " + node.data + " ");
                bw.write(" [ " + node.data + " ");
                for(MyNode n : node.list){
                    printTree(n, level+1, bw);
                }
                System.out.print(" ] " + " ");
                bw.write(" ] " + " ");
                //System.out.println(String.format(format, "]"));
            }
        }catch(IOException e){
        }

        //Aron.end();
    }
}

public class Hello1{
    public static void main(String[] args){
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
    }
    public static int height(Node root){
        return root == null ? -1 : Math.max(height(root.left), height(root.right)) + 1;
    }

    public static void printTree(MyNode node, int level){
        if(node != null){
            String format;
            if(level == 0)
                format = "%1$1s";
            else
                format = "%1$" + (level*10) + "s";

            System.out.println(String.format(format, "[" + node.data));
            for(MyNode n : node.list){
                printTree(n, level+1);
            }
            System.out.println(String.format(format, "]"));
        }
    }

    public static void test0(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        System.out.println("[" + height(bst.root) + "]");

        Aron.end();
    }

    public static void test1(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(1);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        System.out.println("[" + height(bst.root) + "]");
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        System.out.println("[" + height(bst.root) + "]");

        Aron.end();
    }

    public static void test3(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(20);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);

        Aron.end();
    }

    public static void test4(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(20);
        bst.insert(30);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);

        Aron.end();
    }
    
    static void test5(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);
        System.out.println("\n---------------------------------"); 

        Node curr = bst.root;
        while(curr != null){
            System.out.println("[" + curr.data + "]");
            curr = curr.next;
        }

        Aron.end();
    }
    static void test6(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(3);
        bst.insert(7);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);
        System.out.println("\n---------------------------------"); 

        Node curr = bst.root;
        while(curr != null){
            System.out.println("[" + curr.data + "]");
            curr = curr.next;
        }

        Aron.end();
    }

    public static int BinaryTreeLevel(Node root){
        return root == null ? 0 : Math.max(BinaryTreeLevel(root.left), BinaryTreeLevel(root.right)) + 1;
    }

    static Node prev = null;
    public static void printLevel(Node curr, int level){
        if(curr != null){
            if(level == 1 ){
                System.out.println("[" + curr.data + "]");
                if(prev != null){
                    prev.next = curr;
                    prev = curr;
                }else{
                    prev = curr;
                }
            }else{
                printLevel(curr.left, level - 1);
                printLevel(curr.right, level - 1);
            }
        } 
    }
    public static void print(Node curr){
        for(int i = 1; i<= BinaryTreeLevel(curr); i++){
            printLevel(curr, i);
        }
    }
    
    static void test7(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);
        Node n5 = new Node(5);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n5);
        map.put(n5, n4);

        for(Map.Entry<Node, Node> entry: map.entrySet()){
            Node curr = entry.getValue();
            while(curr != null){
                System.out.println("[" + entry.getKey().data + " " + curr.data + "]");
                curr = curr.next;
            }
        }
        List<Node> list = new ArrayList<Node>();
        list.add(n1);
        getAllPaths(n1, map, 4, list);

        Aron.end();
    }
    
    static void test8(){
        Aron.beg();
        int[] arr = {2, -5, 8, -2, 3};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test9(){
        Aron.beg();
        int[] arr = {-1, -5, 8, -4, 5, -2, 3, -2};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test10(){
        Aron.beg();
        int[] arr = {-1, -5, 8};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }

    static void test11(){
        Aron.beg();
        int[] arr = {6, -5, 8};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }

    static void buildMap(Node r, int key, Map<Integer, Integer> map){
        if(r != null){
            System.out.println("[" + r.data + "][" + key + "]");
            map.put(key, r.data);
            buildMap(r.left, 2*key + 1, map);
            buildMap(r.right, 2*key + 2, map);
        }
    }
    // index = 0
    static Node buildTree(Map<Integer, Integer> map, int index){
        Integer n = map.get(index);
        if(n != null){
            Node root = new Node(n);
            root.left = buildTree(map, 2*index+1);
            root.right = buildTree(map, 2*index+2);
            return root;
        }
        return null;
    }
    static void getAllPaths(Node n, Map<Node, Node> map, int num, List<Node> list){
        if(n.data == num){
            for(Node node : list){
                System.out.println("[" + node.data + "]");
            }
            System.out.println("\n---------------------------------"); 
        }else{
                Node curr = map.get(n);
                while(curr != null){
                    list.add(curr);
                    getAllPaths(curr, map, num, list);

                    if(list.size() > 0)
                        list.remove(list.size()-1);

                    curr = curr.next;
                }
        }
    }
    static int maxList(int[] arr){
        int max = -1;
        int first = 0;
        int second = 0;
        if(arr != null && arr.length > 0){
            max = arr[0];
            int sum = arr[0];
            for(int i=1; i<arr.length; i++){
                    sum += arr[i];
                    System.out.println("sum[" + sum + "]");
                    System.out.println("arr[" + i + "]=" + arr[i]);
                    if(sum < 0){
                        sum = 0;
                        if(i + 1 < arr.length)
                            first = i + 1;
                    }

                    if( max < Math.max(sum, arr[i])){
                        max = Math.max(sum, arr[i]);
                        second = i;
                    }
            }
            System.out.println("f[" + first + "]");
            System.out.println("s[" + second + "]");
        }
        return max;
    }

    static void test12(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 0, 1, 1},
            {1, 0, 1, 1},
            {0, 0, 0, 1},
            {0, 0, 1, 0},
            {0, 1, 1, 0},
        }; 

//[0][0]=0[0][1]=0[0][2]=5[0][3]=0
//[1][0]=1[1][1]=0[1][2]=0[1][3]=0
//[2][0]=0[2][1]=0[2][2]=0[2][3]=0
//[3][0]=0[3][1]=0[3][2]=3[3][3]=0
//[4][0]=0[4][1]=0[4][2]=0[4][3]=0


        int h = 0;
        int w = 0;
        int height = arr2d.length;
        if(height > 0){
            int width = arr2d[0].length;

            System.out.println("h[" + height + "]");
            System.out.println("w[" + width + "]");
            for(int i=0; i< height; i++){
                for(int j=0; j< width; j++){
                    int count = maxCount(arr2d, i, j, height, width);
                    System.out.print("[" + i + "][" + j + "]=" + count);
                }
                System.out.println("");
            } 
            
        }
        
        Aron.end();
    }

    static int maxCount(int[][] arr2d, int h, int w, int height, int width){
        if(arr2d != null){
            if(arr2d[h][w] == 1){
                arr2d[h][w] = 2;
                int n1 = 0;
                int n2 = 0;
                int n3 = 0;
                int n4 = 0;
                if(h + 1 < height)
                    n1 = maxCount(arr2d, h + 1, w, height, width);
                if(h - 1 >= 0)
                    n2 = maxCount(arr2d, h - 1, w, height, width);
                if(w + 1 < width)
                    n3 = maxCount(arr2d, h, w + 1, height, width);
                if(w - 1 >= 0)
                    n4 = maxCount(arr2d, h, w - 1, height, width);

                return n1 + n2 + n3 + n4 + 1;
            }
        }
        return 0;
    }
    
    static void test13(){
        Aron.beg();

        try{
            BufferedWriter bw = new BufferedWriter(new FileWriter("file3.txt"));
            int level = 0; 
            MyTree t = new MyTree();
            t.create();
            t.printTree(t.root, level, bw);

            bw.close();

            BufferedReader br = new BufferedReader(new FileReader("file3.txt"));
            String line;
            while((line = br.readLine()) != null){
                //System.out.println("inside[" + line + "]");
                break;
            }
            System.out.println("\n---------------------------------"); 

            String[] arr = line.split("\\s+");

            List<String> list = new ArrayList<String>(); 
            for(String s : arr){
                System.out.print("<<" + s + ">>"); 
                if(s.trim().length() > 0)
                    list.add(s);
            }

            br.close();
            level = 0;
            MyNode r = null;
            System.out.println("\n buildTree2---------------------------------"); 
            MyNode root = buildTree2(r, list.iterator());

//            System.out.println("\n---------------------------------"); 
//            for(String s : arr){
//                System.out.print("(" + s + ")"); 
//            }
            printTree(root, level);
            System.out.println("\n---------------------------------"); 

        }catch(IOException e){
            System.out.println("[" + e.getMessage() + "]");
        }

        Aron.end();
    }

    static MyNode buildTree2(MyNode root, Iterator<String> ite){
        if(ite.hasNext()){
            String token = ite.next();

            if(token.equals("[")){
                if(root == null)
                    return buildTree2(root, ite);
                else{
                    root.list.add(buildTree2(root, ite));
                    return root;
                }
            }else if(token.equals("]")){
            }
            else{
                MyNode nn = new MyNode(Integer.parseInt(token));
                if(root != null){
                    root.list.add(nn);
                    return buildTree2(root, ite);
                }else{
                    root = new MyNode(Integer.parseInt(token));
                    root.list.add(buildTree2(root, ite)); 
                }
            }
            return root;
        }
        return null;
    }

    static void test14(){
        Aron.beg();
        String file = "file.txt";
        try(BufferedReader br = new BufferedReader(new FileReader(file))){
            for(String line; (line = br.readLine()) != null;){
                System.out.println("[" + line + "]");
            }
        }catch(IOException e){
            System.out.println("[" + e.getMessage() + "]");
        }

        String file1 = "file1.txt";
        try(BufferedWriter bw = new BufferedWriter(new FileWriter(file1))){
            bw.write("dog\n");
            bw.write("God");
        }catch(IOException e){
            System.out.println("[" + e.getMessage() + "]");
        }

        Aron.end();
    }
    static void test15(){
        Aron.beg();
        
        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20); 
        int n = 0;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        buildMap(bt.root, n, map);
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " " + entry.getValue() +"]");
        }
        int index = 0;
        Node root = buildTree(map, index);
        Aron.inorder(root);
                 
        Aron.end();
    }
    
    static void test16(){
        Aron.beg();

        System.out.println(String.format("[%1$-1s]" , "123"));
//        System.out.println(String.format("[%1$05d]" , "123"));

        Aron.end();
    }

    static void test17(){
        Aron.beg();
        String str = "[1 [2][3][10[11][12]][20[21][22]]]";
        String[] arr = str.split("\\d+");
        for(String s : arr){
            System.out.println("{" + s + "}");
        }
        Aron.end();
    }
    static void test18(){
        Aron.beg();
        List<Integer> list = new ArrayList<Integer>(); 
        list.add(1);
        list.add(2);
        list.add(3);

        Iterator<Integer> ite = list.iterator();
        while(ite.hasNext()){
            System.out.println("[" + ite.next() + "]"); 
        }
        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node {
    public Node left;
    public Node right;
    public int data;
    public Node(int n) {
        data = n;
        left = null;
        right = null;
    }
    public Node getLeft() {
        return left;
    }
    public Node getRight() {
        return right;
    }
    public void setLeft(Node l) {
        left = l;
    }
    public void setRight(Node r) {
        right = r;
    }
}

class BST {
    Node root;
    public BST() {
        root = null;
    };
    public void Insert(int n) {
        if(root == null) {
            root = new Node(n);
        } else {
            Node curr = root;
            boolean end = false;
            while(curr != null && !end) {
                if(n < curr.data) {
                    if(curr.left == null) {
                        curr.left = new Node(n);
                        end = true;
                    } else
                        curr = curr.left;
                } else {
                    if(curr.right == null) {
                        curr.right = new Node(n);
                        end = true;
                    } else
                        curr = curr.right;
                }
            }
        }
    }
    public void Inorder(Node curr) {
        if(curr != null) {
            Inorder(curr.left);
            System.out.print(curr.data + " ");
            Inorder(curr.right);
        }
    }
    public Node getRoot() {
        return root;
    }
}
class InorderIteration {

    public static Node prev = null;
    public static void main(String args[]) {
        BST b1 = new BST();
        b1.Insert(15);
        b1.Insert(12);
        /*
        b1.Insert(14);
        b1.Insert(17);
        b1.Insert(19);
        b1.Insert(130);
        b1.Insert(16);
        b1.Insert(10);
        */

        PostorderIteration(b1.getRoot());
        System.out.println();
        Postorder(b1.getRoot());
        Node node = ConvertBSTToCircileDoubleLinkedList(b1.getRoot());
        int count = 0;
        while(node != null && count < 20) {
            System.out.println("<"+node.data+">");
            node = node.right;
            count++;
        }
        //Inorder(b1.getRoot());
    }

    // in order traversal using iteration
    // inorder iteration
    public static void InorderIteration(Node curr) {
        Stack<Node> st = new Stack<Node>();
        while(curr != null || !st.isEmpty()) {
            if(curr != null) {
                st.push(curr);
                curr = curr.left;
            } else {
                Node no = st.pop();
                System.out.println("[" + no.data + "]");
                curr = no.right;
            }
        }
    }

    //Convert bst binary search tree to circular double linked list
    public static Node ConvertBSTToCircileDoubleLinkedList(Node curr) {
        Stack<Node> st = new Stack<Node>();
        Node currNode = null;
        Node first = null;
        Node prev = null;
        while(curr != null || !st.isEmpty()) {
            if(curr != null) {
                st.push(curr);
                curr = curr.left;
            } else {
                prev = currNode;
                currNode = curr = st.pop();
                if(prev != null) {
                    prev.right = currNode;
                    currNode.left = prev;
                } else {
                    first = currNode;
                }
                //System.out.println(currNode.data);
                curr = curr.right;
            }
        }
        if(first != null) {
            first.left = currNode;
            currNode.right = first;
        }
        return first;
    }
    public static void PostorderIteration(Node curr) {
        /*
        Stack<Node> st = new Stack<Node>();
        Node prev = null;
        while(curr != null || !st.isEmpty())
        {
            if(curr != null)
            {
                st.push(curr);
                prev = curr.left;
                curr = curr.left;
            }
            else
            {
                curr = st.pop();
                if(prev == curr.right)
                    System.out.println("curr.data=" + curr.data);
                prev = curr.right;
                curr = curr.right;
            }
        }
        */
    }
    public static void Inorder(Node root) {
        if(root != null) {
            Inorder(root.left);
            System.out.println("data=" + root.data);
            Inorder(root.right);
        }
    }
    public static void Postorder(Node myroot) {
        if(myroot != null) {
            System.out.println("post=" + myroot.data);
            Postorder(myroot.left);
            Postorder(myroot.right);
        }
    }
}
class Node
{
    int data;
    Node next;
    public Node(int data)
    {
        this.data = data;
        next = null;
    }
}
class CircularLinkedList
{
    Node first;
    public CircularLinkedList()
    {
        first = null;
    }
    public void print()
    {
        Node tmpFirst = first;
        if( tmpFirst != null)
        {
            Node curr = tmpFirst.next;
            System.out.println("["+tmpFirst.data+"]");
            while(tmpFirst != curr)
            {
                System.out.println("["+curr.data+"]");
                curr = curr.next;
            }
        }
    }
    public void print(Node first)
    {
        this.first = first;
        print();
    }
    public void setFirst(Node first)
    {
        this.first = first;
    }
    public void insert(Node node)
    {
        if(node != null)
        {
            if(first == null) //zero node
            {
                first = node;
                node.next = first;
            }
            else
            {
                Node curr = first;
                Node next = curr.next;
                if(next == null) //one node
                {
                    first.next = node;
                    node.next = first;
                }
                else //two or more nodes
                {
                    boolean done = false;
                    while(!done)
                    {
                        if(curr.data < next.data)
                        {
                           if(curr.data < node.data && node.data < next.data) 
                           {
                                curr.next = node;
                                node.next = next;
                                done = true;
                           }
                        }
                        else
                        {
                            if(node.data > curr.data || node.data < next.data)
                            {
                                curr.next = node;
                                node.next = next;
                                done = true;
                            }
                        }
                        curr = curr.next;
                        next = next.next;
                    }
                }
            }
        }
    }
}
public class InsertCircularLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Insert node to sorted circular linked list!");
        CircularLinkedList cll = new CircularLinkedList();
        Node node1 = new Node(10);
        Node node2 = new Node(6);
        Node node3 = new Node(20);
        Node node4 = new Node(1);
        Node node5 = new Node(7);
        
        cll.insert(node1);
        cll.insert(node2);
        cll.insert(node3);
        cll.setFirst(node2);

        cll.insert(node4);
        cll.insert(node5);
        cll.print();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

// sorted linkedlist, sorted linked list
// gf SortedLinkedList.java
public class InsertSortedList{
    public static void main(String[] args) {
        test10();
        test11();
        test12();
        test13();
    }
    
    static void test10(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();

        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(1);
        sll.append(4);
        sll.append(7);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }
    static void test11_thread(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(1);
        sll.append(4);
        sll.append(7);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }

    static void test11(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(1);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }

    static void test12(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(4);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }
    static void test13(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }
}
class Node
{
    Node next;
    int data;
    public Node(int data)
    {this.data = data;}
}

class InsertToList
{
    Node head;
    public InsertToList()
    {head = null; }
    public void insert(Integer data)
    {
        if(head == null)
            head = new Node(data);
        else
        {
            Node curr = head;
            Node next = curr.next;
            if(next == null) //One node only
            {
                Node node = new Node(data);
                if(data > curr.data)
                    curr.next = node;
                else
                {
                    node.next = curr;
                    head = node;
                }
            }
            else            //More than one node
            {
                //Insert node before the head
                if(data < curr.data)
                {
                    Node node = new Node(data);
                    node.next = curr;
                    head = node;
                }
                else 
                {
                    //Insert node between curr and next 
                    while(next != null)
                    {
                        if(curr.data < data && data < next.data)
                        {
                            curr.next = new Node(data);
                            curr.next.next = next;
                            break;
                        }
                        curr = next;
                        next = next.next;
                    }
                    if(next == null) //Insert to the last node
                    {
                        curr.next = new Node(data);
                    }
                }
            }
        }
    }
    public void printList()
    {
        Node curr = head;
        while(curr != null)
        {
            System.out.print("["+curr.data+"]");
            curr = curr.next;
        } 
    }
}

public class InsertToOrderList 
{
    public static void main(String[] args)
    {
        System.out.println("Insert an integer to order list");
        InsertToList orderList = new InsertToList();        
        orderList.insert(1);
        orderList.insert(0);
        orderList.printList();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class  InterTwoSortArr
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		int[] Arr1 = {1, 4, 8, 10};
		int[] Arr2 = {2, 8, 10, 16};
		int[] A = InterTwoSortedArr(Arr1, Arr2);
		for(int i=0; i<A.length; i++)
			System.out.println("A["+i+"]="+A[i]);
	}
	

	public static int[] InterTwoSortedArr(int[] Arr1, int[] Arr2)
	{
		int[] A = null;
		int[] retArr = null;
		int i=0, j=0, c=0;
		if( Arr1 != null && Arr2 != null)
		{
			int len1 = Arr1.length;
			int len2 = Arr2.length;

			A = new int[len1>len2?len1:len2];
			while(i < len1 && j < len2)
			{ if(Arr1[i]<Arr2[j])
					i++; 
				else if(Arr1[i]>Arr2[j])
					j++; 
				else 
				{ A[c]=Arr1[i];
					i++; j++;
					c++;
				}
			}
			
		}
		retArr = new int[c];
		for(i=0; i<c; i++)
			retArr[i]=A[i];
		return retArr;
	}
}
import java.io.*;

interface myinter 
{
	public void face();
	public void print();
}

class myclass implements myinter 
{
	public void face()
	{
		System.out.println("face");
	}
	public void print()
	{
		System.out.println("print");
	}
}


class Interface 
{
	public static void main(String args[])
	{
		myclass a = new myclass();
		a.face();
		a.print();
	}
}
import java.util.*;

public class IntersectionList {
    public static void main(String[] args) {
        test0();
        test1();
    }

    static  void test0() {
        List<List<Integer>> lists = new ArrayList<List<Integer>>();
        lists.add(Arrays.asList(1, 4, 4, 3, 2));
        lists.add(Arrays.asList(1, 3, 1, 9, 4));
        lists.add(Arrays.asList(1, 6, 3, 2, 2));
        List<Integer> retList = intersection(lists);

        for(Integer n : retList) {
            System.out.println(n);
        }
    }

    static  void test1() {
        List<List<Integer>> lists = new ArrayList<List<Integer>>();
        lists.add(Arrays.asList(1, 4, 4, 3, 2));
        lists.add(Arrays.asList(6));
        lists.add(Arrays.asList(1, 6, 3, 2, 2));
        List<Integer> retList = intersection(lists);

        for(Integer n : retList) {
            System.out.println(n);
        }
    }

    //[ file=intersectionlist.html title=""
    public static List<Integer> intersection(List<List<Integer>> lists) {
        List<Integer> retList = new ArrayList<Integer>();
        if(lists != null) {
            Map<Integer, Set<Integer>> map = new HashMap<Integer, Set<Integer>>();

            for (int i = 0; i < lists.size(); i++) {
                List<Integer> list = lists.get(i);

                for (Integer n : list) {
                    Set<Integer> set = map.get(n);
                    if (set != null) {
                        set.add(i);
                        map.put(n, set);
                    } else {
                        Set<Integer> nSet = new HashSet<Integer>();
                        nSet.add(i);
                        map.put(n, nSet);
                    }
                }
            }
            for (Map.Entry<Integer, Set<Integer>> entry : map.entrySet()) {
                Integer n = entry.getKey();
                Set<Integer> set = map.get(n);
                if (set.size() == lists.size())
                    retList.add(n);
            }
        }
        return retList;
    }
    //]
}
import java.util.*;
import java.io.*;
import classfile.*;

class Entry{
    public String key;
    public Object value;
    public Entry next;
    public Entry(String key, Object value){
        this.key = key;
        this.value = value;
    }
}

class Hash{
    public Entry[] arr;
    public int max;
    public int count = 0;
    public Hash(int max){
        this.max = max;
        arr = new Entry[max];
    }

    public Node get(String key){
        int hash = key.hashCode() % max;
        return (Node)arr[hash].value;
    }
    public void delete(String key){
        if(key != null){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr != null){
                Entry prev = null;
                while(curr != null){
                    if(curr.key == key)
                        break;
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                if(prev == null){
                    arr[hash] = curr.next;
                    count--;
                }else{
                    if(curr != null){
                        prev.next = curr.next;
                        count--;
                    }
                }
            }
        }
    }
    public void put(String key, Node node){
        if(count < max){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr == null){
                arr[hash] = new Entry(key, node);
                count++;
            }
            else{
                Entry prev = null;
                while(curr != null){
                    if(curr.key.equals(key)){
                        // Replace with new value
                        curr.value = node;
                        break;
                    }
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                // No key is found
                if(curr == null){
                    prev.next = new Entry(key, node);
                    count++;
                }
            }
        }
        
    }
}


class Interval implements Comparable<Interval> {
    int startTime;
    int endTime;
    public Interval(int startTime, int endTime) {
        this.startTime = startTime;
        this.endTime = endTime;
    }
    public int compareTo(Interval v) {
        return startTime - v.startTime;
    }
}


//[ file=inorderiterator.html title=""     
class InorderIterator {
    Node curr;
    Stack<Node> stack = new Stack<Node>();
    public InorderIterator(Node r) {
        this.curr = r;
    }
    public boolean hasNext() {
        if(curr != null || stack.size() > 0)
            return true;
        else
            return false;
    }
    public int next() {
        while(hasNext()) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.pop();
                curr = node.right;
                return node.data;
            }
        }
        return -1;
    }
}
//]

public class IntervalExample {
    public static void main(String[] args) {
        test0_InorderIterator();
        test1_InorderIterator();
        test2_InorderIterator();
        test3_InorderIterator();
        test00_hash();
        test01_hash();
        test02_hash();
        test03_hash();
        test04_hash();
        test05_hash();
        test06_hash();
        test07_hash();
        test08_hash();
        test09_hash();
        test010_hash();
        test011_hash();
        test012_hash();
    }
    static void test0_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
//        bst.insert(5);
//        bst.insert(15);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    static void test1_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    static void test2_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    static void test3_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(1);
        bst.insert(15);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    // 4:17
    static int[] multiple(int[] arr) {
        int[] tmpArray = null;
        if(arr != null) {
            int len = arr.length;
            tmpArray = new int[len];
            for(int i=0; i<len; i++) {
                int m = 1;
                for(int j=0; j<len; j++) {
                    if(i != j) {
                        m *= arr[j];
                    }
                }
                tmpArray[i] = m;
            }
        }
        return tmpArray;
    }
    // prefix and suffix
    // abc = [a, bc], [ab, c], [abc, ""]
    static List<String> prefixSuffix(String str) {
        List<String> list = new ArrayList<String>();
        if(str != null) {
            int len = str.length();
            for(int i=0; i<len; i++) {
                String prefix = str.substring(0, i+1);
                String suffix = str.substring(i+1, len);
                list.add(prefix);
                list.add(suffix);
            }

        }
        return list;
    }
    static void test2() {
        Aron.beg();
        String str = "abc";
        prefixSuffix(str);
        Aron.end();
    }
    //  4:14 - 5:20
    static void inorder(Node r) {
        if(r != null) {
            inorder(r.left);
            Print.p(r.data);
            inorder(r.right);
        }
    }
    static void inorderIterator(Node r) {
        Stack<Node> stack = new Stack<Node>();
        Node curr = r;
        while(curr != null || stack.size() > 0) {
            if(curr != null) {
                stack.push(r);
                curr = r.left;
            } else {
                Node p = stack.pop();
                Print.p(p.data);
                curr = p.right;
            }
        }
    }
    // 5:20 - 5:34
    static void preorder(Node r) {
        if(r != null) {
            Print.p(r.data);
            preorder(r.left);
            preorder(r.right);
        }
    }
    static void preorderIterator(Node r) {
        Stack<Node> stack = new Stack<Node>();
        Node curr = r;
        while(curr != null || stack.size() > 0) {
            if(curr != null) {
                Print.p(curr.data);
                stack.push(curr);
                curr = curr.left;
            } else {
                Node p = stack.pop();
                curr = p.right;
            }
        }
    }
    // 5:35 - 5:42
    static void postorder(Node r) {
        if( r != null) {
            postorder(r.left);
            postorder(r.right);
            Print.p(r.data);
        }
    }
    // use two stacks
    static void postorderIterator(Node r) {
        Stack<Node> stack1 = new Stack<Node>();
        Stack<Node> stack2 = new Stack<Node>();
        if(r != null) {
            stack1.push(r);
            while(stack1.size() > 0) {
                Node node = stack1.pop();
                if(node.left != null)
                    stack1.push(node.left);

                if(node.right != null)
                    stack1.push(node.right);

                stack2.push(node);
            }
            while(stack2.size() > 0) {
                Print.p(stack2.pop().data);
            }
        }
    }

    static void test1() {
        Aron.beg();
        int[] arr = {1, 2, 3, 4};
        int[] array = multiple(arr);
        Aron.printArray(arr);
        Aron.printArray(array);

        Aron.end();
    }


    // test1 [1]
    // test2 [1, 2]
    // test3 [2, 1]
    // test4 [3, 1, 2]
    // test5 [2, 3, 1]
    public static int findMaxIndex(int[] arr, int lo, int hi) {
        if(arr != null) {
            if(arr[lo] < arr[hi] || lo == hi)
                return hi;
            else {
                int mid = (lo + hi)/2;
                if(arr[lo] < arr[mid])
                    return findMaxIndex(arr, mid, hi);
                else
                    return findMaxIndex(arr, lo, mid);
            }
        }
        return -1;
    }
    
    static void test00_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        Node node = (Node)hash.get("a");

        Test.f(node, null);
        Test.f(node, new Node(3));
        Test.t(node, new Node(1));

        Aron.end();
    }
    static void test01_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("a", new Node(2));
        Node node = (Node)hash.get("a");
        Test.t(node, new Node(2));

        Aron.end();
    }
    static void test02_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test03_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        hash.put("e", new Node(5));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test04_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.delete("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
        }

        Aron.end();
    }
    static void test05_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.delete("a");
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test06_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test07_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 1);

        Aron.end();
    }
    static void test08_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 0);

        Aron.end();
    }
    static void test09_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        Test.t(hash.count, 2);

        Aron.end();
    }
    static void test010_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        Test.t(hash.count, 1);

        Aron.end();
    }
    static void test011_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
    static void test012_hash(){
        Aron.beg();
        Hash hash = new Hash(3);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

public class InvertBinTree{
    public static void main(String[] args) {
        test0();
        test1();
    }
    
    public static Node invert(Node root){
        if(root != null){
            Node right = invert(root.left);
            Node left  = invert(root.right);
            root.right = right;
            root.left  = left;
            return root;
        }
        return null;
    }
    public static void test0(){
       BST bst = new BST(); 
       bst.insert(10);
       bst.insert(5);
       bst.insert(15);
       bst.insert(7);
       Ut.l();
       Aron.inorder(bst.getRoot());
       Ut.l();
       Node r = invert(bst.getRoot());
       Aron.inorder(r);
    }
    public static void test1(){
       BST bst = new BST(); 
       bst.insert(10);
       bst.insert(5);
       bst.insert(7);
       bst.insert(15);
       bst.insert(12);
       bst.insert(18);
       Ut.l();
       Aron.inorder(bst.getRoot());
       Ut.l();
       Node r = invert(bst.getRoot());
       Aron.binImage(r);
       Aron.inorder(r);
    }
}
public class IsLeapYear 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    public static int isLeapYear(int month, int year)
    {

    }
}
import java.lang.Integer;
import java.lang.String;
import java.util.*;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.stream.Stream;

import classfile.*;

public class JavaDataStructure {
    public static void main(String[] args) {
        System.out.println("Java Data Structure");

        //[file=data-structure.html title=""
        // map, list, linkedlist, HashMap, HashTable, queue, stack
        //
        int[] array     = {1, 2, 3};
        int[][]  array2 = {{1, 2, 3},
            {4, 5, 6}
        };
        // ArrayList
        ArrayList<String> alist = new ArrayList<String>();
        alist.add("dog");
        alist.add("cat");

        // list of list, ArrayList 2D
        ArrayList<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();
        list2d.add(alist);

        // List
        List<String> list = new ArrayList<String>();
        list.add("eloberate");
        list.add("continue");
        list.add("continuous");

        // Vector is old data structure in Java, use List instead
        // Vector is not synchronized
        Vector<String> vector = new Vector<String>();
        vector.add("jobs");
        vector.add("career");
        vector.add("motivation");
        vector.add("ambition");

        // LinkedList
        LinkedList<Integer> linkedList = new LinkedList<Integer>();
        linkedList.add(1);
        linkedList.add(2);

        // Queue
        Queue<Integer> queue = new LinkedList<Integer>();
        queue.add(1);
        queue.add(2);
        queue.remove();
        if(queue.peek() == 2)
            System.out.println("top element is :" + 2);

        // LinkedBlockingDeque
        // blocking, use lock in the implementation
        Deque<String> blockingDeque = new LinkedBlockingDeque<String>();
        blockingDeque.addFirst("first");
        blockingDeque.addLast("last");

        // non-blocking, non blocking, nonblocking queue
        // ConcurrentLinkedDeque, concurrent queue concurrentqueue
        Deque<String> concurrentDeque = new ConcurrentLinkedDeque<String>();
        concurrentDeque.addFirst("first");
        concurrentDeque.addLast("last");

        // HashMap can have null for [k, v]
        Map<String, Integer> map = new HashMap<String, Integer>();
        map.put("cat", 1);
        map.put("dog", 2);

        String key = "cat";
        Integer value = map.get(key);
        if(value != null) {
            value = map.get(key);
            System.out.println("key=" + key + " value=" + value);
        }

        if(map.containsKey(key))
            System.out.println("map contains key=" + key);

        // java, init list, java initialize list, List as Value in HashMap
        Map<String, List<String>> mapList = new HashMap<String, List<String>>();
        mapList.put("1", Arrays.asList("dog", "cat", "cow"));
        mapList.put("2", Arrays.asList("C++", "Java", "Haskell"));
        mapList.put("3", Arrays.asList("Scala", "Python", "Ruby"));

        for(Map.Entry<String, List<String>> entry: mapList.entrySet()) {
            String myKey = entry.getKey();
            List<String> myList = entry.getValue();
            for(String elem: myList) {
                System.out.println("myKey=" + myKey + " list=" + elem);
            }
        }

        if(mapList.containsKey("key")) {
            System.out.println("contains key");
        }

        // HashTable can't have [k, v] to be null
        Map<String, String> table = new Hashtable<String, String>();
        table.put("key", "value");
        table.put("nonull", "nonull");
        for(Map.Entry<String, String> entry : table.entrySet()) {
            System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
        }

        List<String> mylist = mapList.get("dog");
        int size = mapList.size();
        if(mapList.containsValue("1")) {
            System.out.println("contains value");
        }

        for(String str : mylist) {
            System.out.println("str=" + str);
        }

        // iterate set, for set, for hashset, loop set,   HashSet
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2));
        Integer item = 1;
        if(set.contains(item))
            System.out.println("set contains element:" + 1);


        for(Integer n : set) {
            System.out.println("n=:" + n);
        }

        set.remove(item);
        int size1 = set.size();
        System.out.println("size1 =" + set.size());

        // iterate set
        for(Integer elem: set) {
            System.out.println("for elem:=" + elem);
        }

        // set to array
        Integer[] array1 = (Integer[]) set.toArray(new Integer[set.size()]);
        for(Integer n: array1) {
            System.out.println("n=:" + n);
        }

        List<Integer> list4 = new ArrayList<>(); 
        Integer[] array4 = (Integer[]) list4.toArray();

        Integer[] arr5 = {1, 2, 3};
        List<Integer> list5 = Arrays.asList(arr5);

        // list to iterator
        List<Integer> list8 = new ArrayList<Integer>();
        list8.add(1);
        list8.add(2);
        Iterator<Integer> ite = list8.iterator();
        while(ite.hasNext()) {
            System.out.println("[" + ite.next() + "]");
        }

        // double ended queue, deck
        Deque<Node> queue1 = new ArrayDeque<Node>();
        queue1.add(new Node(1));
        queue1.add(new Node(2));
        System.out.println("size[" + queue1.size() + "]");
        queue1.poll();
        System.out.println("size[" + queue1.size() + "]");

        List<String> list1 = new ArrayList<String>();
        List<String> list2 = new LinkedList<String>();
        List<String> list3 = new Stack<String>();
        List<String> list6 = new Vector<String>();
        Queue<String> queue2 = new LinkedList<String>();
        Queue<String> queue3 = new PriorityQueue<String>();
        Map<String, String> mymap = new HashMap<String, String>();
        Map<String, String> mymap1 = new Hashtable<String, String>();
        Map<String, String> mymap2 = new LinkedHashMap<String, String>();

        //]
    }
}
import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import java.util.stream.*;
import java.util.*;
import java.io.*;
import classfile.*;

// *j_json* *json* *json_array* *json_Serializable* *json_class* *j_json_example*
class Item implements Serializable {
    @SerializedName("_OrderDetails")
    private OrderDetails[] mOrderDetails;

    @SerializedName("Id")
    private String mId;
    public String getId(){
        return mId;
    }

    public OrderDetails[] getMOrderDetails(){ 
        return mOrderDetails;
    }

    @SerializedName("OrderData")
    private String mOrderDate;

    @SerializedName("Number")
    private String mNumber;

    @SerializedName("CustomerName")
    private String mCustomerName;

    @SerializedName("Note")
    private String mNote;

    // Add setters and getters

    public static class OrderDetails implements Serializable {
        @SerializedName("ProductName")
        private String mProductName;
        String getMProductName(){
            return mProductName;
        }

        @SerializedName("TotalAfterDiscount_Lc")
        private String mTotalAfterDiscount;

        @SerializedName("MeasureUnitName")
        private String mMeasureUnitName;

        @SerializedName("TotalPrice_Lc")
        private String mTotalPrice;

        @SerializedName("PricePerUnit_Lc")
        private String mPricePerUnit;

        @SerializedName("Quantity")
        private String mQuantity;

        // Add setters and getters
    }
}

public class JsonArray {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        String responseJSON = "[\n" +
                              "  {\n" +
                              "    \"_OrderDetails\": [\n" +
                              "      {\n" +
                              "         \"ProductName\": \"FUCHS SUPER GT SAE 10W30 6X5 / FP10100010102\",\n" +
                              "        \"TotalAfterDiscount_Lc\": \"7500\",\n" +
                              "        \"MeasureUnitName\": \"كرتونة\",\n" +
                              "        \"TotalPrice_Lc\": \"7500\",\n" +
                              "        \"PricePerUnit_Lc\": \"75\",\n" +
                              "        \"Quantity\": \"100\"\n" +
                              "      }\n" +
                              "    ],\n" +
                              "    \"Id\": \"274\",\n" +
                              "    \"OrderDate\": \"4/10/2014 12:00:00 AM\",\n" +
                              "    \"Number\": \"16\",\n" +
                              "    \"CustomerName\": \"الأسد\",\n" +
                              "    \"Note\": \"\"\n" +
                              "  }\n" +
                              "]";

        Item[] placelist;
        Gson gson = new Gson();
        placelist = gson.fromJson(responseJSON, Item[].class);
        System.out.println(Arrays.toString(placelist));
        for(Item m : placelist){
            Print.pbl(m.getId());
            for(Item.OrderDetails order : m.getMOrderDetails()){
                Print.pbl(order.getMProductName());
            }
        }

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
}


import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.util.Iterator;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import classfile.*;

/*
gx https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple/1.1
<!-- https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple -->
<dependency>
    <groupId>com.googlecode.json-simple</groupId>
    <artifactId>json-simple</artifactId>
    <version>1.1</version>
</dependency>
*/


// *j-json-example-array-object*   *json-example*
public class JsonArrayExample{
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        test0();
        Ut.l();
        test1();
        Ut.l();
        test2();
        Ut.l();
        test3();
        Ut.l();
        test4();
    }
    static void test0(){
        Aron.beg();

        JSONParser parser = new JSONParser();
        try {
            // *j-json-read-file*
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/file1.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
 
            String name = (String) jsonObject.get("Name");
            String author = (String) jsonObject.get("Author");
            JSONArray companyList = (JSONArray) jsonObject.get("Company List");
 
            System.out.println("Name: " + name);
            System.out.println("Author: " + author);
            System.out.println("\nCompany List:");
            Iterator<String> iterator = companyList.iterator();
            while (iterator.hasNext()) {
                System.out.println(iterator.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        Aron.end();
    }
    static void test1(){
        Aron.beg();

        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/jsonobj.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
 
            String name = (String) jsonObject.get("name");
            Print.pbl("name=" + name);
            JSONObject jsonObj = (JSONObject)jsonObject.get("obj");
            String age = (String)jsonObj.get("age");
            Print.pbl(age);
        } catch (Exception e) {
            e.printStackTrace();
        }
        Aron.end();
    }

    static void test2(){
        Aron.beg();

        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/jsonArray.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
 
            String name = (String) jsonObject.get("name");
            Print.pbl("name=" + name);
            JSONObject jsonObj = (JSONObject)jsonObject.get("product");
            String age = (String)jsonObj.get("age");
            Print.pbl(age);
            JSONArray jsonArray = (JSONArray)jsonObject.get("array"); 

            Iterator<JSONObject> iterator = jsonArray.iterator();
            while (iterator.hasNext()) {
                Print.pbl(iterator.next().get("id"));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        Aron.end();
    } 

    static void test3(){
        Aron.beg();
        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/jsonObjObj.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
            JSONArray jsonArray = (JSONArray)jsonObject.get("product"); 
            Iterator<JSONObject> iterator = jsonArray.iterator();
            while (iterator.hasNext()) {
                Print.pbl(iterator.next().get("id"));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        Aron.end();
    } 

    static void test4(){
        Aron.beg();
        listAllCategories();
        Aron.end();
    } 

    public static void listAllCategories(){
        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/json_product.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
            JSONArray jsonArray = (JSONArray)jsonObject.get("products"); 
            Iterator<JSONObject> iterator = jsonArray.iterator();
            while (iterator.hasNext()) {
                JSONObject currJson = iterator.next(); 
                Print.pbl(currJson.get("id"));
                Print.pbl(currJson.get("name"));
                Print.pbl(currJson.get("category"));
                Ut.l();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

import classfile.*;
import java.util.*;

class CharacterIterator implements Iterator<Character>{
    String str;
    int index = 0;
    public CharacterIterator(String str){
        this.str = str;
    }
    public boolean hasNext(){
        return index < str.length();
    }
    public Character next(){
        Character ch = str.charAt(index);
        index++;
        return ch;
    }
}

class MyJSon{
    public Map<String, Object> map = new HashMap<String, Object>();
}

// Json parser
class JObj{
    public String value;
    Map<String, JObj> map = new HashMap<String, JObj>();
    Map<String, ArrayList<JObj>> mapList = new HashMap<String, ArrayList<JObj>>();
    public JObj(String value){
        this.value = value;
    }
}

interface Json{
}

class Value implements Json{
    String str;
    public Value(String str){
        this.str = str;
    }
}
class JObject implements Json{
    JObject obj;
}

class JList implements Json{
    List<Json> list = new ArrayList<Json>();
}


public class JsonParser{
    public static void main(String[] args) {
        //test0();
        // this will affect the [static index]
        //test1(); 

    }
    public static void test00() {
        Aron.beg();
        MyJSon son = new MyJSon();
        List<MyJSon> list = new ArrayList<MyJSon>(); 
        son.map.put("a", "b");
        son.map.put("k", new MyJSon());
        son.map.put("k", list);

        Aron.end();
    }
    public static void test0() {
        Aron.beg();
        String str = "\"do\"";
        char[] arr = str.toCharArray();
        String name = parseName(arr);
        Print.pb(name);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        String str = "{\"a\":\"b\"}";
        CharacterIterator ite = str.iterator(); 

        JObj obj = jsonParser(ite);
        print(obj);
        Aron.end();
    }
    public static void print(JObj obj){
        if(obj != null){
            Print.pb(obj.value);
            for(Map.Entry<String, JObj> entry : obj.map.entrySet()){
                Print.pb(entry.getKey());
                print(entry.getValue());
            }
        }
    }

    // {"dog":"cat"}
    // {"dog":{"cat":"rat"}}
    // {"dog":{"cat":"rat","pig":"cow"}}
    // {"dog":[{"cat":"rat"},{"pig":"cow"}]}
    // k->o1
    // k->{01}
    // k->[{o1, o2}]
    // k->[{01}]
    /**
     * {"dog":"cat"}
     * {"dog":"cat", "cow":"rat"}
     * {"dog":{"cat":"rat"}}
     * {"dog":{"cat":"rat", "cow":"pig"}}
     * {"dog":[{"cat":"rat"}, {"cow":"pig"}]
     * dog->{<cat, rat>, <cow, pig>}
     * dog->[<cat, rat>, <cow, pig>]
     */
    static int index = 0;
    public static JObj jsonParser(Iterator<Character> ite){

        return null;
    }

    static String parseValue(char[] arr){
        return parseName(arr);
    }
    // "ab"
    // ""
    static String parseName(char[] arr){
        String str = "";
        int c = 0;
        while(index < arr.length){
            if(arr[index] != '"')
                str += arr[index];
            else{
                c++;
                if(c == 2)
                 break;
            }

            index++;
        }
        return c == 2? str : null;
    }
}
import java.util.*;

// priority heap compareto compareTo heapify heap
//[ file=kclosest.html title=""
// Compile: javac KClosestPoint.java and java KClosestPoint
// Runtime: (n*logk)
class Point{
    double x;
    double y;
    public Point(double x, double y){
        this.x = x;
        this.y = y;
    }
}

class Distance implements Comparable<Distance>{
    Point ref;
    Point point;
    public Distance(Point ref, Point point){
        this.ref = ref;
        this.point = point;
    }

    private double norm(){
        double normRef = (point.x - ref.x)*(point.x - ref.x) +  
                         (point.y - ref.y)*(point.y - ref.y);
        return normRef;
    }
    public int compareTo(Distance d){
        if(this.norm() > d.norm())
            return 1;
        else if(this.norm() == d.norm() )
            return 0;
        else 
            return -1;

    }
    public String toString(){
        return "["+ point.x +"]["+ point.y +"]";
    }
}

public class KClosestPoint {
    public static void main(String[] args) {
        test1();
    }
    public static void test1() {

        Point ref = new Point(1, 1);
        Set<Point> set = new HashSet<Point>(); 
        set.add(new Point(20, 20));
        set.add(new Point(2, 2));
        set.add(new Point(10, 10));
        set.add(new Point(2, 4));

        PriorityQueue<Distance> queue = new PriorityQueue<Distance>();
        for(Point pt : set){
            queue.add(new Distance(ref, pt)); 
        }
        int k = 3;
        while(k > 0){
            System.out.println(queue.remove().toString());
            k--;
        }
    }
}
//]

//Find a sequence of moves of a Knight on a chessboard such that the Knight visits each square only once 
public class KnightTour 
{
    public static void main(String[] args)
    {
        test1();
    }
    public static void test1()
    {
        int[][] board = new int[8][8];
        int count = 0;
        int c = 0;
        int r = 0;
        findPath(board, count, c, r);
    }
    public static void findPath(int[][] board, int count, int c, int r)
    {
        if(board != null)
        {
            if(count == 64)
            {
                Aron.printArray2D(board);
                System.exit(0);
            }
            else
            {
                board[c][r] = count+1;
                System.out.println("["+c+"]["+r+"] count="+count);

                if(c + 1 < 8 && r + 2 < 8 && board[c+1][r+2] == 0)
                    findPath(board, count+1, c+1, r+2);

                if(c + 2 < 8 && r + 1 < 8 && board[c+2][r+1] == 0)
                    findPath(board, count+1, c+2, r+1);

                if(c + 2 < 8 && r - 1 >= 0 && board[c+2][r-1] == 0)
                    findPath(board, count+1, c+2, r-1);

                if(c + 1 < 8 && r - 2 >= 0 && board[c+1][r-2] == 0)
                    findPath(board, count+1, c+1, r-2);

                if(c - 1 >= 0 && r - 2 >= 8 && board[c-1][r-2] == 0)
                    findPath(board, count+1, c-1, r-2);

                if(c - 2 >= 0 && r - 1 >= 0 && board[c-2][r-1] == 0)
                    findPath(board, count+1, c-2, r-1);

                if(c - 2 >= 0 && r + 1 < 8 && board[c-2][r+1] == 0)
                    findPath(board, count+1, c-2, r+1);

                if(c - 1 >= 0 && r + 2 < 8 && board[c-1][r+2] == 0)
                    findPath(board, count+1, c-1, r+2);

                board[c][r] = 0;
            }
        }
    }
}
public class KthMedian 
{
    public static void main(String[] args)
    {
       test1(); 
       test2(); 
       test3(); 
       test4(); 
    }
    public static void test1()
    {
        System.out.println("test1");
        int[] array = {1, 4, 2, 5, 6};
        int lo = 0, hi = array.length-1;
        int k=5;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 6);
    } 
    public static void test2()
    {
        System.out.println("test2");
        int[] array = {1, 4};
        int lo = 0, hi = array.length-1;
        int k=1;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 1);
    } 
    public static void test3()
    {
        System.out.println("test3");
        int[] array = {1};
        int lo = 0, hi = array.length-1;
        int k=1;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 1);
    } 
    public static void test4()
    {
        System.out.println("test4");
        int[] array = {2, 0, 1};
        int lo = 0, hi = array.length-1;
        int k=2;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 1);
    } 

    //Find the kth median element in a unsorted array
    //Return index for the kth smaller element
    //Otherwise return -1
    public static int modifiedQuickSort(int[] array, int lo, int hi, int k)
    {
        if(k <= hi - lo + 1) 
        {
            if(hi == lo && k == 1)
                return lo;
            else{
                int pindex = partition(array, lo, hi);
                int leftLen = pindex - lo;
                int rightLen = hi - pindex;
                if(pindex + 1 > k) 
                    return modifiedQuickSort(array, lo, pindex-1, k);
                else if(pindex + 1 < k)
                    return modifiedQuickSort(array, pindex+1, hi, k - (leftLen+1));
                else 
                    return pindex;
            }
        }
        return -1;
    }

    //use modified quicksort algorithm to find the kth median element
    //partition an array to two parts: left_array < pivot < right_array
    public static int partition(int[] array, int lo, int hi)
    {
        int top = lo;
        if(array != null)
        {
            int pivot = array[hi];
            for(int i=lo; i<=hi; i++)
            {
                if(array[i] < pivot)
                {
                    swap(array, i, top);
                    top++;
                }
            }
            swap(array, top, hi); 
        }
        return top;
    } 
    public static void swap(int[] array, int i, int j)
    {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
public class LCS 
{
    /**
     * 0               if i ==0 || j == 0
     * 
     *                  LCS(A[i-1], B[j-1]) + 1  if A[i]==B[j]
     * LCS(A[i], B[j] 
     *                  Max(LCS(A[i-1], B[j]), LCS(A[i], B[j-1]) if A[i] != B[j]
     *
     */
    public static void main(String[] args)
    {
                    System.out.println("Hello World!");
                    char[] A = {'a', 'b', 'c', 'd'}; 
                    char[] B = {'a', 'c'}; 
                    char[] Arr = new char[10];
                    int i = A.length;
                    int j = B.length;
                    int k = 0;
                    LCS(A, i, B, j, Arr, k); 
                    for(int x=0; x<2; x++)
                    {
                        System.out.println("Arr["+x+"]="+Arr[x]);
                    }
    }
    static int LCS(char[] A, int i, char[] B, int j, char[] Arr, int k)
    {
        if(i == 0 || j == 0)
        {
            return 0;
        }
        else if(A[i-1] == B[j-1])
        {
            Arr[k]=A[i-1];
            return LCS(A, i-1, B, j-1, Arr, k+1)+1;
        }
        else
        {
            return LCS(A, i-1, B, j, Arr, k)>LCS(A, i, B, j-1, Arr, k)?LCS(A, i-1, B, j, Arr, k):LCS(A, i, B, j-1, Arr, k);
        }
    }
}
import java.util.*;
import classfile.*; 

// LRU cache
// least recent used cache
// lru cache  
class Node<T> {
    Node next;
    Node prev;
    String key;
    T data;
    public Node(String key, T data) {
        next = prev = null;
        this.key = key;
        this.data = data;
    }
}

class LRU {
    Node least;
    Node most;
    int maxSize;
    int count;
    Map<String, Node<String>> map = new HashMap<String, Node<String>>();
    public LRU(int size) {
        least = most = null;
        maxSize = size;
        count = 0;
    }

    Node get(String key) {
        Node<String> node = map.get(key);
        if( node != null) {
            if(node != most) {
                remove(node.key);
                append(key, node.data);
            }
        }
        return node;
    }
    void insert(String key, String data) {
        if(!map.containsKey(key)) {
            append(key, data);
        } else {
            Node node = map.get(key);
            remove(key);
            append(key, data);
        }
    }
    void remove(String key) {
        Node curr = map.get(key);
        if( curr != null) {
            Node prev = curr.prev;
            Node next = curr.next;
            if(prev == null && next == null) {
                least = most = null;
                curr.next = curr.prev = null;
            } else if(prev != null && next == null) {
                most = prev;
                most.next = null;
                curr.next = curr.prev = null;
            } else if(prev == null && next != null) {
                least = next;
                next.prev = null;
                curr.next = curr.prev = null;
            } else {
                prev.next = next;
                next.prev = prev;
                curr.next = curr.prev = null;
            }
            map.remove(key);
            count--;
        }
    }
    void append(String key, String data) {
        if(least == null && count < maxSize) {
            Node<String> node = new Node<String>(key, data);
            least = most = node;
            map.put(key, node);
            count++;
        } else {
            if(count < maxSize) {
                Node<String> node = new Node<String>(key, data);
                most.next = node;
                node.prev = most;
                most = node;
                map.put(key, node);
                count++;
            } else {
                Node next = least.next;
                least.next = null;
                if(next != null)
                    next.prev = null;
                else
                    least = most = null;
                least = next;
                count--;
                append(key, data);
            }
        }
    }
    void print() {
        Node curr = least;
        while(curr != null) {
            System.out.println("<"+curr.key+","+curr.data+">");
            curr = curr.next;
        }
    }
}

public class LRUCache {
    public static void main(String[] args) {
        test0();
    }
    
    static void test0(){
        Aron.beg();

        System.out.println("Least Recent Used Cache");
        LRU  lru = new LRU(4);

        lru.insert("key", "mydata");
        lru.insert("key1", "mydata1");
        lru.insert("key2", "mydata2");
        lru.insert("key3", "mydata3");
        lru.insert("key4", "mydata4");
        lru.insert("key5", "mydata5");
        lru.get("key2");
        lru.insert("key3", "mydatakey3");
        lru.print();
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    } 
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;


// gx /Library/WebServer/Documents/zsurface/image/lrucache.png
// LRU cache, least recent used cache, lru cache new
// In memory catche.
// e.g. memcache 
//
//
// insert - if the key is in the map, remove the node from the list
//          update the map with new node, append the node to the list
// 
//          if the list is full, remove the oldest node, and append
//          the new node to the list, and update the map with new node
//  
//          update the map with new key/node
//          update the map with new key/node
// 
class RNode{
    String key;
    String data;
    public RNode(String key, String data){
        this.key = key;
        this.data = data;
    }
}
class LRUCacheNew {
    int max;
    int count;
    List<RNode> list = new ArrayList<RNode>(); 
    Map<String, RNode> map = new HashMap<String, RNode>(); 
    public LRUCacheNew(int max){
        this.max = max;
        count = 0;
    }
    public  RNode get(String key){
        RNode node = map.get(key);
        if(node != null){
            list.remove(node);
            list.add(node);
        }
        return node;
    }

    // gx /Library/WebServer/Documents/zsurface/image/lrucache.png
    public void insert(String key, RNode node){
        RNode vnode = map.get(key);
        if(vnode != null){
            // vnode is in the list
            map.remove(vnode.key);
            list.remove(vnode);
            map.put(key, node);
            list.add(node);
        }else{
            // vnode is not in the list
            if(count < max){
                map.put(key, node);
                list.add(node);
                count++;
            }else{
                if(max > 0){
                    list.remove(0);
                    map.put(key, node);
                    list.add(node);
                }
            }
        }
    }
    public void print(){
        for(RNode node : list){
            Print.pb(node.key + " " + node.data);
        }
    }
}

public class LRUCache2{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        LRUCacheNew lru = new LRUCacheNew(3);
        RNode n1 = new RNode("k1", "data1");
        RNode n2 = new RNode("k2", "data2");
        RNode n3 = new RNode("k3", "data3");
        RNode n4 = new RNode("k4", "data4");

        lru.insert(n1.key, n1);
        lru.insert(n2.key, n2);
        lru.insert(n3.key, n3);

        lru.print();

        Ut.l();
        lru.insert(n4.key, n4);

        lru.print();
        
        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        LRUCacheNew lru = new LRUCacheNew(3);
        RNode n1 = new RNode("k1", "data1");
        RNode n2 = new RNode("k2", "data2");
        RNode n3 = new RNode("k3", "data3");
        RNode n4 = new RNode("k2", "data4");
        RNode n5 = new RNode("k1", "data5");

        lru.insert(n1.key, n1);
        lru.insert(n2.key, n2);
        lru.insert(n3.key, n3);

        
        lru.print();

        Ut.l();
        lru.insert(n4.key, n4);
        Print.pb("insert k2  data4");
        lru.print();
        Ut.l();
        lru.insert(n5.key, n5);
        Print.pb("insert k1  data5");
        lru.print();

        Aron.end();
    }
} 

public class LeastDiff 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] arr = {1, 2, 3, 20, 30};
        int lo = 0;
        int hi = arr.length-1;
        int key = 5;
        int[] m = new int[1];
        m[0] = Integer.MAX_VALUE;
        LeastDiff(arr, lo, hi, key, m);
        System.out.println("m="+m[0]);
    }
    public static boolean LeastDiff(int[] arr, int lo, int hi, int key, int[] m)
    {
        if(lo <= hi)
        {
            int mid = (lo+hi)/2;
            if(key < arr[mid])
            {
                m[0] = Math.min(m[0], Math.abs(key - arr[mid]));
                return LeastDiff(arr, lo, mid-1, key, m);
            }
            else if(key > arr[mid])
            {
                m[0] = Math.min(m[0], Math.abs(key - arr[mid]));
                return LeastDiff(arr, mid+1, hi, key, m);
            }
            else
            {
                m[0] = 0;
                return true;  
            }
        }
        return false;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

class LevelOrder {
    public static Node prev = null;
    public static void main(String args[]) {
        test0();    
        test1();    
    }
    
    static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);
        b1.insert(1);
        b1.insert(11);

        Node r = b1.getRoot();
        Queue<Node> q = new LinkedList<Node>();
        q.offer(b1.getRoot());
        LevelOrderRecursion(q);
        System.out.println("");
        LevelOrder(b1.getRoot());
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);
        b1.insert(1);
        b1.insert(11);
        LevelOrder(b1.root);
        LevelOrderOneQueue(b1.root);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    } 

    //level order recursion levelorder recursion
    public static void LevelOrderRecursion(Queue<Node> q) {
        Queue<Node> q1 = new LinkedList<Node>();
        while(q.peek() != null) {
            Node node = q.poll();
            Print.pb(node.data);
            if(node.left != null)
                q1.offer(node.left);
            if(node.right != null)
                q1.offer(node.right);
        }
        System.out.println();
        if(q1.peek() != null)
            LevelOrderRecursion(q1);
    }

    // level order with one queue
    public static void LevelOrderOneQueue(Node root) {
        if(root != null){
            Queue<Node> queue = new LinkedList<Node>();
            queue.offer(root);
            while(queue.peek() != null){
                Node curr = queue.remove();
                Print.pb(curr.data);
                if(curr.left != null)
                    queue.offer(curr.left);
                if(curr.right != null)
                    queue.offer(curr.right);

            }
        }
    }

    //level order with two queues
    public static void LevelOrder(Node cur) {
        Queue<Node> Q1 = new LinkedList<Node>();
        Queue<Node> Q2 = new LinkedList<Node>();
        Q1.offer(cur);
        while(Q1.peek() != null || Q2.peek() != null) {
            while(Q1.peek() != null) {
                Node top = Q1.poll();
                System.out.print(top.data + " ");
                if(top.left != null)
                    Q2.offer(top.left);
                if(top.right != null)
                    Q2.offer(top.right);
            }
            System.out.println();
            while(Q2.peek() != null) {
                Node top = Q2.poll();

                System.out.print(top.data + " ");
                if(top.left != null)
                    Q1.offer(top.left);
                if(top.right != null)
                    Q1.offer(top.right);
            }
            System.out.println();
        }
    }
}
import java.util.*;

public class LexicographicOrder 
{
    public static void main(String[] args)
    {
        System.out.println("Try it");
        test1();
        System.out.println("===========");
        printLexico(5);
        System.out.println("===========");
        printLexico(10);
        System.out.println("===========");
        printLexico(100);
        System.out.println("===========");
        printLexico(105);
        System.out.println("===========");
        printLexico(1234);
        System.out.println("===========");
    }
    public static void printLexico(int n)
    {
        System.out.println("n=["+n+"]");
        for(int down = 1; down <10; down++)
        {
            int base = down;
            while(base <= n)
            {
                System.out.print("["+base+"] ");
                base *= 10;
            }

            base /=10;
            while(base >=10 && base <= n)
            {
                int sum = base;
                for(int i=1; i<10 && base+i <=n; i++)
                {
                    sum = base + i;
                    System.out.print("["+sum+"] ");
                }
                base = sum/10 + 1;
                if(base*10 <= n)
                    base *=10;
            }
        }
    }
    public static void test1()
    {
        String s = "abc";
        for(int i=0; i<s.length(); i++)
        {
            String str = s.substring(0, i+1);
            System.out.println("str="+str);
        }
    }
}
import java.util.List;
import java.util.ArrayList;
class Node
{
    int data;
    Node root;
    Node left;
    Node right;
    public Node(int data)
    {
        this.data = data;
        this.root = null;
        this.left = null;
        this.right = null;
    }
    public Node(Node root)
    {
        this.root = root;
    }
}
class SLinkedList
{
    Node head;
    public SLinkedList()
    {
        head = null;
    }
    public void addBST(Node root)
    {
        if(head == null)
            head = new Node(root);
        else
        {
            Node curr = head;
            while(curr.right != null)
            {
                curr = curr.right;
            }
            curr.right = new Node(root);
        }
    }
    public void add(int data)
    {
        if(head == null)
        {
            head = new Node(data);
        }
        else
        {
            Node curr = head;
            while(curr.right != null)
            {
                curr = curr.right; 
            }
            curr.right = new Node(data);
        }
    }
    public void show()
    {
        Node curr = head;
        while(curr != null)
        {
            System.out.print("["+curr.data+"]");
            curr = curr.right;
        }
    }
    public void inorder(Node r)
    {
        if( r != null)
        {
            inorder(r.left);
            System.out.print("["+r.data+"]");
            inorder(r.right);
        }
    }
    public void showBST()
    {
        Node curr = head;
        while(curr != null)
        {
            Node tmp = curr;
            inorder(tmp.root);    
            curr = curr.right;
            System.out.println("=========");
        }
    }
}

class BST
{
    Node root;
    public BST()
    {
        root = null;
    }
    public void insert(int data)
    {
        if(root == null)
        {
            root = new Node(data);
        }
        else
        {
            Node curr = root;
            boolean done = false;
            while(!done)
            {
                if(data < curr.data)
                {
                    if(curr.left != null)
                    {
                        curr = curr.left;
                    }
                    else
                    {
                        curr.left = new Node(data);
                        done = true;
                    }
                }    
                else
                {
                    if(curr.right != null)
                    {
                        curr = curr.right;
                    }
                    else
                    {
                        curr.right = new Node(data);
                        done = true;
                    }
                }
            }
        }
    }
}


public class LinkedListBST 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        SLinkedList sll = new SLinkedList();
        //sll.add(1);
        //sll.add(2);
        //sll.add(3);
        //sll.add(4);
        //sll.show();

        BST bst1 = new BST();
        BST bst2 = new BST();
        BST bst3 = new BST();
        System.out.println("=========");
        bst1.insert(10); 
        bst1.insert(5); 
        bst1.insert(15); 
        bst1.insert(7); 
        bst1.insert(30); 
        bst1.insert(12); 
        bst1.insert(1); 
        bst1.insert(2); 
        bst1.insert(0); 
        inorder(bst1.root);

        System.out.println("=========");
        bst2.insert(100); 
        bst2.insert(50); 
        bst2.insert(15); 
        bst2.insert(70); 
        bst2.insert(200); 
        bst2.insert(140); 
        bst2.insert(300); 
        inorder(bst2.root);

        System.out.println("=========");
        bst3.insert(30); 
        bst3.insert(60); 
        bst3.insert(105); 
        bst3.insert(9); 
        bst3.insert(50); 
        bst3.insert(10); 
        bst3.insert(1); 
        inorder(bst3.root);


        System.out.println("=========");
        sll.addBST(bst1.root);
        sll.addBST(bst2.root);
        sll.addBST(bst3.root);
        System.out.println("=========");
        sll.showBST();

        System.out.println("----------");
        List<List<Integer>> listList = new ArrayList<List<Integer>>();
        List<Integer> list = new ArrayList<Integer>(); 
        DFS(sll.head, sll.head.root, list, listList);
    }
    public static void DFS(Node curr, Node root, List<Integer> list, List<List<Integer>> listList)
    {
        if(curr != null)
        {
            if(root != null)
            {
                DFS(curr, root.left, list, listList);
                DFS(curr, root.right, list, listList);
                if(root.left == null && root.right == null)
                {
                    //System.out.print("{"+root.data+"}");
                    list.add(root.data);
                }
                if(list.size() > 1 || (list.size() > 0 && curr.root == root))
                {
                    System.out.println("");
                    List<Integer> tmpList = new ArrayList<Integer>(list);
                    listList.add(tmpList);
                    list.clear();
                    if(curr.right != null)
                    {
                        DFS(curr.right, curr.right.root, list, listList);
                        list.clear();
                        if(listList.size() > 0)
                            listList.remove(listList.size()-1);
                    }
                    else
                    {
                        for(List<Integer> mylist : listList)
                        {
                            for(Integer num : mylist)
                            {
                                System.out.print("["+num+"]");
                            }
                            System.out.println();
                        }
                        if(listList.size() > 0)
                            listList.remove(listList.size()-1);
                    }
                }
            }
        }
    }
    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
            System.out.print("["+node.data+"]");
            inorder(node.right);
        }
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class LinkedListToBST{
    public static void main(String[] args) {
        //test0_buildTree();
        test01_buildTree();
        test2_middleLinkedList();
        test3_middleLinkedList();
        test4_buildTree2();
        test0_buildTree3();
        test0_buildTree4();
    }
    static void test0_buildTree() {
        Aron.beg();
        int[] arr = {1, 2, 3, 4};
        int lo = 0;
        int hi = arr.length-1;
        Node root = buildTree(arr, lo, hi);
        Aron.levelOrder(root);
        Aron.inorder(root);
        Aron.binImage(root);

        Aron.end();
    }

    static void test01_buildTree() {
        Aron.beg();
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
        int lo = 0;
        int hi = arr.length-1;
        Node root = buildTree(arr, lo, hi);
        Aron.levelOrder(root);
        Aron.inorder(root);
        Aron.binImage(root);

        Aron.end();
    }
    public static Node buildTree(int[] arr, int lo, int hi) {
        if(lo <= hi) {
            int mid = 0;
            if ((lo + hi)%2 == 1)
                mid = (lo + hi)/2 + 1;
            else
                mid = (lo + hi)/2;
            Node parent = new Node(arr[mid]);
            parent.left = buildTree(arr, lo, mid-1);
            parent.right = buildTree(arr, mid+1, hi);
            return parent;
        }
        return null;
    }
    static int index = 0;
    public static Node buildTree2(int[] arr, int count){
        if(count == 0)
            return null;
        else{
            Node left = buildTree2(arr, count/2);
            Node parent = new Node(arr[index]);
            parent.left = left;

            index++;
            parent.right = buildTree2(arr, count - count/2 - 1);
            return parent;
        }
    }

    public static Node buildTree3(Iterator<Integer> ite, int count){
        if(count == 0)
            return null;
        else{
            Node left = buildTree3(ite, count/2);
            Node parent = new Node(ite.next());
            parent.left = left;

            parent.right = buildTree3(ite, count - count/2 - 1);
            return parent;
        }
    }

    static void test0_buildTree3(){
        Aron.beg();
        Integer[] arr = {1, 2, 3, 4}; 
        final Iterator<Integer> ite = Arrays.asList(arr).iterator();
        int count = arr.length;
        Node parent = buildTree3(ite, count);
        Aron.inorder(parent);
        Aron.line();
        Aron.preorder(parent);

        Aron.end();
    }

    static void test0_buildTree4(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);

        int count = 3;
        Node parent = buildTree4(sll.head, count);

        Aron.inorder(parent);
        Ut.l();
        Aron.preorder(parent);

        Aron.end();
    }
    public static Node buildTree4(Node curr, int count){
        if(count == 0)
            return null;
        else{
            Node left = buildTree4(curr, count/2);
            Node parent = new Node(curr.data);
            parent.left = left;
            parent.right = buildTree4(curr.next, count - count/2 - 1);
            return parent;
        }
    }

    public static Node middleLinkedList(Node head){
        int steps = 2;
        int count = 0;

        Node first = head;
        if(first != null) {
            Node second = first.next;
            while(second != null && second.next != null) {
                first = first.next;
                while(count < steps && second != null) {
                   second = second.next;
                    count++;
                }
                steps++;
                count = 0;
            }
        }
        return first;
    }

    static void test2_middleLinkedList(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        sll.append(4);
        Aron.printSLL(sll.head);
        Node node = middleLinkedList(sll.head);
        Test.t(node.data, 2);

        Aron.end();
    } 
    static void test3_middleLinkedList(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node node = middleLinkedList(sll.head);
        Test.t(node.data, 1);

        Aron.end();
    } 
    
    static void test4_buildTree2(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        
        
        int[] arr = {1, 2, 3, 4}; 
        int index = 0;
        int count = arr.length;

        Node parent = buildTree2(arr, count);
        Aron.levelOrder(parent);
        Aron.inorder(parent);

        Aron.end();
    }
}

import classfile.*;

class LinkedListToBST2 {
    /* head node of link list */
    static LNode head;

    /* Link list Node */
    class LNode {
        int data;
        LNode next, prev;

        LNode(int d) {
            data = d;
            next = prev = null;
        }
    }

    /* A Binary Tree Node */
    class TNode {
        int data;
        TNode left, right;

        TNode(int d) {
            data = d;
            left = right = null;
        }
    }

    /* This function counts the number of nodes in Linked List
       and then calls sortedListToBSTRecur() to construct BST */
    TNode sortedListToBST() {
        /*Count the number of nodes in Linked List */
        int n = countNodes(head);

        /* Construct BST */
        return sortedListToBSTRecur(n);
    }

    /* The main function that constructs balanced BST and
       returns root of it.
       n  --> No. of nodes in the Doubly Linked List */
    TNode sortedListToBSTRecur(int n) {
        /* Base Case */
        if (n <= 0)
            return null;

        /* Recursively construct the left subtree */
        TNode left = sortedListToBSTRecur(n / 2);

        /* head_ref now refers to middle node,
           make middle node as root of BST*/
        TNode root = new TNode(head.data);

        // Set pointer to left subtree
        root.left = left;

        /* Change head pointer of Linked List for parent
           recursive calls */
        head = head.next;

        /* Recursively construct the right subtree and link it
           with root. The number of nodes in right subtree  is
           total nodes - nodes in left subtree - 1 (for root) */
        root.right = sortedListToBSTRecur(n - n / 2 - 1);

        return root;
    }

    /* UTILITY FUNCTIONS */
    /* A utility function that returns count of nodes in a
       given Linked List */
    int countNodes(LNode head) {
        int count = 0;
        LNode temp = head;
        while (temp != null) {
            temp = temp.next;
            count++;
        }
        return count;
    }

    /* Function to insert a node at the beginging of
       the Doubly Linked List */
    void push(int new_data) {
        /* allocate node */
        LNode new_node = new LNode(new_data);

        /* since we are adding at the begining,
           prev is always NULL */
        new_node.prev = null;

        /* link the old list off the new node */
        new_node.next = head;

        /* change prev of head node to new node */
        if (head != null)
            head.prev = new_node;

        /* move the head to point to the new node */
        head = new_node;
    }

    /* Function to print nodes in a given linked list */
    void printList(LNode node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    /* A utility function to print preorder traversal of BST */
    void preOrder(TNode node) {
        if (node == null)
            return;
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    /* Drier program to test above functions */
    public static void main(String[] args) {
        LinkedListToBST2 llist = new LinkedListToBST2();

        /* Let us create a sorted linked list to test the functions
           Created linked list will be 7->6->5->4->3->2->1 */
        llist.push(7);
        llist.push(6);
        llist.push(5);
        llist.push(4);
        llist.push(3);
        llist.push(2);
        llist.push(1);

        System.out.println("Given Linked List ");
        llist.printList(head);

        /* Convert List to BST */
        TNode root = llist.sortedListToBST();
        System.out.println("");
        System.out.println("Pre-Order Traversal of constructed BST ");
        llist.preOrder(root);
    }
}

import classfile.*;

class LinkedListToBalancedBST {
    /* head node of link list */
    static LNode head;

    /* Link list Node */
    class LNode {
        int data;
        LNode next, prev;

        LNode(int d) {
            data = d;
            next = prev = null;
        }
    }

    /* A Binary Tree Node */
    class TNode {
        int data;
        TNode left, right;

        TNode(int d) {
            data = d;
            left = right = null;
        }
    }

    /* This function counts the number of nodes in Linked List
       and then calls sortedListToBSTRecur() to construct BST */
    TNode sortedListToBST() {
        /*Count the number of nodes in Linked List */
        int n = countNodes(head);

        /* Construct BST */
        return sortedListToBSTRecur(n);
    }

    /* The main function that constructs balanced BST and
       returns root of it.
       n  --> No. of nodes in the Doubly Linked List */
    TNode sortedListToBSTRecur(int n) {
        /* Base Case */
        if (n <= 0)
            return null;

        /* Recursively construct the left subtree */
        TNode left = sortedListToBSTRecur(n / 2);

        /* head_ref now refers to middle node,
           make middle node as root of BST*/
        TNode root = new TNode(head.data);

        // Set pointer to left subtree
        root.left = left;

        /* Change head pointer of Linked List for parent
           recursive calls */
        head = head.next;

        /* Recursively construct the right subtree and link it
           with root. The number of nodes in right subtree  is
           total nodes - nodes in left subtree - 1 (for root) */
        root.right = sortedListToBSTRecur(n - n / 2 - 1);

        return root;
    }

    /* UTILITY FUNCTIONS */
    /* A utility function that returns count of nodes in a
       given Linked List */
    int countNodes(LNode head) {
        int count = 0;
        LNode temp = head;
        while (temp != null) {
            temp = temp.next;
            count++;
        }
        return count;
    }

    /* Function to insert a node at the beginging of
       the Doubly Linked List */
    void push(int new_data) {
        /* allocate node */
        LNode new_node = new LNode(new_data);

        /* since we are adding at the begining,
           prev is always NULL */
        new_node.prev = null;

        /* link the old list off the new node */
        new_node.next = head;

        /* change prev of head node to new node */
        if (head != null)
            head.prev = new_node;

        /* move the head to point to the new node */
        head = new_node;
    }

    /* Function to print nodes in a given linked list */
    void printList(LNode node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    /* A utility function to print preorder traversal of BST */
    void preOrder(TNode node) {
        if (node == null)
            return;
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    /* Drier program to test above functions */
    public static void main(String[] args) {
        LinkedListToBalancedBST llist = new LinkedListToBalancedBST();

        /* Let us create a sorted linked list to test the functions
           Created linked list will be 7->6->5->4->3->2->1 */
        llist.push(7);
        llist.push(6);
        llist.push(5);
        llist.push(4);
        llist.push(3);
        llist.push(2);
        llist.push(1);

        System.out.println("Given Linked List ");
        llist.printList(head);

        /* Convert List to BST */
        TNode root = llist.sortedListToBST();
        System.out.println("");
        System.out.println("Pre-Order Traversal of constructed BST ");
        llist.preOrder(root);
    }
}

// This code has been contributed by Mayank Jaiswal(mayank_24)
import java.util.*;

public class ListAndSet 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
        test3();
        test4();
    }
    public static Set<Integer> clone(Set<Integer> set)
    {
        Set<Integer> s = new LinkedHashSet<Integer>(); 
        for(Integer ele: set)
            s.add(ele);

        return s;
    }
    public static void test1()
    {
        System.out.println("test1"); 
        int[] list = {1, 2};
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2)); 
        System.out.println(match(list, set));

    } 
    public static void test2()
    {
        System.out.println("test2"); 
        int[] list = {1, 4, 2};
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2)); 
        System.out.println(match(list, set));

    } 
    public static void test3()
    {
        System.out.println("test3"); 
        int[] list = {2, 4, 3, 1, 2};
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2, 3)); 
        System.out.println(match(list, set));
    } 
    public static void test4()
    {
        System.out.println("test4"); 
        int[] list = {2, 4, 3, 1, 2};
        Set<Integer> set = new HashSet<Integer>(); 
        System.out.println(match(list, set));
    } 
    public static boolean match(int[] list, Set<Integer> set)
    {
        Set<Integer> set1 = clone(set);
        if( list != null && set != null)
        {
            if(set1.isEmpty())
                return true;

            boolean start = false;
            for(int ele: list)
            {
                if(set1.contains(ele))
                {
                    set1.remove(ele);
                    start = true; 
                }
                else{
                    if(start)
                        set1 = clone(set);           
                    start = false;
                }

                if(set1.isEmpty())
                    return true;
            }
        }
        return false;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

//[ file=lock.html title=""
class MyLock{
    private boolean isLocked = false;

    public synchronized boolean lock(){
        if(!isLocked){
            isLocked = true;
            return isLocked;
        }
        return false;
    }
    public synchronized void unlock(){
        isLocked = false;
        notify();
    }
}
//]

public class LockExample{
    public static void main(String[] args) {
    }
    public static void print(){
    }
    static void test0(){
        Aron.beg();
        Aron.end();
    }
} 
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;


// logger, logging example, logger example, java logger
public class LoggerExample{
    private final static Logger LOGGER = Logger.getLogger(LoggerExample.class.getName());
    static private FileHandler fileTxt;
    static private SimpleFormatter formatterTxt;

    public static void main(String[] args) {
        try{
            test0();
        }catch(IOException e){
        }
    }
    public static void test0() throws IOException {
        Aron.beg();

        fileTxt = new FileHandler("./text/Logging.txt");
        formatterTxt = new SimpleFormatter();
        LOGGER.setLevel(Level.INFO);
        fileTxt.setFormatter(formatterTxt);
        LOGGER.addHandler(fileTxt);

        LOGGER.info("Logging an INFO-level message {0}");
        

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

public class LongestContinuousSum 
{
    public static void main(String[] args)
    {
        test0(); 
        test1(); 
        test2(); 
        test3(); 
        test4(); 
        test5(); 
        test6(); 
        test7(); 
        test8(); 
    }
    public static int Sum(int[] array)
    {
        int max = 0;
        if(array != null)
        {
            int len = array.length;
            int[] result = new int[len];
            if(len > 0)
            {
                result[0] = array[0];
                for(int i=1; i<len; i++)
                {
                    result[i] = result[i-1] + array[i] > array[i] ? result[i-1] + array[i] : array[i];
                }
                for(int i=0; i<len; i++)
                {
                    if(max < result[i])      
                        max = result[i];
                }
            }
        }
        return max;
    }

    public static void test0()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 8, -5, 20, 3, -2}; 
        int max = Sum(array);
        System.out.println("max=" + max);
    }

    public static void test1()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{1, -5, 8, -2}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }

    public static void test2()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{1, -5, 8, 4, -2, 3, -1}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test3()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 1, -5, 8, 4, -2, 3, -1}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test4()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 4, 2}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test5()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 4, 2, -8}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }

    public static void test6()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }

    public static void test7()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{8}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test8()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{8, -1}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void maxSumWithIndex(int[] array)
    {
        if(array != null && array.length > 0)
        {
            int len = array.length;
            int[] maxArr = new int[len];
            maxArr[0] = array[0]; 

            int first = 0;
            int second = 0;
            int max = array[0];
            for(int i=1; i < len; i++)
            {
                maxArr[i] = Math.max(maxArr[i-1] + array[i], array[i]);            
                if(maxArr[i] > max)
                {
                    if(i-1 >=0 && maxArr[i-1] < 0)
                        first = i;
                    second = i;
                    max = maxArr[i];
                }
            }

            /*
            max = maxArr[0];
            for(int i=1; i<len; i++)
                if(maxArr[i] > max)
                    max = maxArr[i];
            */
            System.out.println("max=" + max);
            System.out.println("first=" + first);
            System.out.println("second=" + second);
        }
    }
}
import java.io.*;

class LongestEmptyArray 
{
	public static void main(String args[])
	{
		// 0 means empty
		// 1 means non-empty 
		int[] Arr = {0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0}; 
		System.out.println("cool");
		int max = Longest(Arr);
		System.out.println("max=" + max);
	}
	// go right and go down
	public static int Longest(int[] Arr)
	{
		int max=0;
		if( Arr != null)
		{
			int len = Arr.length;
			int[] A = new int[len];

			if(Arr[0] == 0)
				A[0] = 1;
			else 
				A[0] = 0;

			for( int i=1; i<len; i++)
			{ if(Arr[i] == 0)
					A[i] = A[i-1]+1;	
			}
			
			for(int i=0; i<len; i++)
			{
				if(A[i] > max)
					max = A[i];
			}
		}		
		return max;
	}
}
import classfile.*;

public class LongestIncreasingSubsequence {
    public static void main(String[] args) {
        //test0();
        test1();
        test2();
        test3();
        test4();
    }

    static void test0() {
        Aron.beg();
        Integer[] array = {1, 0, 7, 2, 6};
        int len = array.length;
        Aron.printArray(array);
        int m = LISDP(array);

        System.out.println();
        int recm = LISRecursion(array, len);
        int len2 = array.length;
        System.out.println("==========================");
        int recm2 = LISRecursion2(array, len2);
        System.out.println("max LIS=["+m+"]");
        System.out.println("max LISRecursion=["+recm+"]");
        System.out.println("max LISRecursion2=["+recm2+"]");
        System.out.println("==========================");
        LISTree(array, len2);

        Aron.end();
    }

    static void test1() {
        Aron.beg();
        Integer[] array = {1, 0, 7, 2, 6};
        Aron.printArray(array);
        int len = array.length;
        int max = LISRecursion(array, len);

        System.out.println("LISRecursion=["+ max +"]");
        Aron.end();
    }
    static void test2() {
        Aron.beg();
        Integer[] array = {1, 0, 7, 2, 6};
        Aron.printArray(array);
        int len = array.length;
        int max = LISRecursion2(array, len);
        System.out.println("LISRecursion2=["+ max +"]");

        Aron.end();
    }

    static void test3() {
        Aron.beg();

        Integer[] array = {1, 0, 7, 2, 6};
        int len = array.length;
        Aron.printArray(array);
        LISTree(array, len);

        Aron.end();
    }

    static void test4() {
        Aron.beg();

        Integer[] array = {1, 0, 7, 2, 6};
        int len = array.length;
        Aron.printArray(array);
        LISRecursion_debug(array, len);

        Aron.end();
    }

    //L[i] = 1 + Max(L[i-1]) where j < i && arr[j] < arr[i]
    public static int LISRecursion_debug(Integer[] array, int len) {
        if(len == 1)
            return 1;
        else {
            int max = 1;
            for(int i=1; i < len; i++) {
                int m = LISRecursion_debug(array, i);
                //System.out.print("array["+(i-1)+"]="+array[i-1]+" array["+(len-1)+"]="+array[len-1]+"\n");
                System.out.print("("+ array[i-1] + " , "+ array[len-1] + ")");
                if(array[i-1] < array[len-1])
                    max = Math.max(max, m+1);
                //System.out.println("max=["+max+"]");
            }
            System.out.println();
            return max;
        }
    }


    //Find the longest increasing subsequence integers
    //{2, 4, 1, 5} => 2->4->5
    //{2, 4, 1, 2, 3} => 1->2->3
    //L[i] = 1 + Max(L[i-1]) where j < i && arr[j] < arr[i]
    public static int LISRecursion(Integer[] array, int len) {
        if(len == 1)
            return 1;
        else {
            int max = 1;
            for(int i=1; i < len; i++) {
                int m = LISRecursion(array, i);
                if(array[i-1] < array[len-1])
                    max = Math.max(max, m+1);
            }
            System.out.println();
            return max;
        }
    }

    public static void LISTree(Integer[] array, int len) {
        if(len == 1) {
            //System.out.println("["+array[len-1]+"]");
        } else {
            for(int i=1; i<len; i++) {
                LISTree(array, i);
                System.out.println("["+array[i-1]+"]->["+array[len-1]+"]");
            }
        }
    }
    public static int LISRecursion2(Integer[] array, int len) {
        int max = 1;
        if(len == 1)
            return max;
        else {
            for(int i=1; i<len; i++) {
                int m = LISRecursion2(array, len-1);
                System.out.print("array["+(i-1)+"]="+array[i-1]+" array["+(len-1)+"]="+array[len-1]+"\n");
                if(array[i-1] < array[len-1])
                    max = Math.max(max, m+1);
            }
            System.out.println("-----------------------");
        }
        return max;
    }

    //Dynamic programming algorithm solves Longest Increasing Subsequence
    //with complexity O(n^2)
    public static int LISDP(Integer[] array) {
        int len = array.length;
        int[] maxlist = new int[len];
        for(int i=0; i<len; i++)
            maxlist[i] = 1;

        for(int i=1; i<len; i++) {
            for(int j=0; j<i; j++) {
                if(array[j] < array[i])
                    maxlist[i] = Math.max(1 + maxlist[j], maxlist[i]);
            }
        }

        int m = Integer.MIN_VALUE;
        for(int i=0; i<len; i++) {
            if(maxlist[i] > m)
                m = maxlist[i];
        }
        return m;
    }
}
    //Dynamic programming algorithm solves Longest Increasing Subsequence
    //with complexity O(n^2)
    public static int LISDP(int[] array)
    {
        int len = array.length;
        int[] maxlist = new int[len];
        for(int i=0; i<len; i++)
            maxlist[i] = 1;

        for(int i=1; i<len; i++)
        {
            for(int j=0; j<i; j++)
            {
                if(array[j] < array[i])            
                    maxlist[i] = Math.max(1 + maxlist[j], maxlist[i]);
            }            
        } 
        
        int m = Integer.MIN_VALUE;
        for(int i=0; i<len; i++)
        {
            if(maxlist[i] > m)
                m = maxlist[i];
        }
        return m;
    }
import java.io.*;
import java.lang.String;
import java.util.*;
class LongestPalindrome 
{
	public static void main(String args[])
	{
        longest("abc");
	}
    public static void longest(String str){
        int len = str.length();
        int newStr = "";
        for(int i=0; i<len-1; i++){
            newstr += str.charAt(i);
        }
        System.out.println(newStr);
    }

    //complexity O(N^2)
    public static String longest2(String str)
    {
        String palindrome = "";
        if(str != null)
        {
            String newStr = "#";
            for(int i=0; i<str.length(); i++)
            {
                newStr += str.charAt(i) + "#";
            }

            int len = newStr.length();
            int maxoffset = 0;
            for(int i=0; i<len; i++)
            {
                for(int offset=0; offset<len; offset++)
                {
                    if(i-offset >= 0 && i+offset<len && newStr.charAt(i-offset) == newStr.charAt(i+offset))
                    {
                        if(offset > maxoffset)
                        {
                            maxoffset = offset;
                            palindrome = newStr.substring(i-offset, i+offset+1);
                        }
                    }
                }
            }
            String tmpStr = "";
            for(int i=0; i<palindrome.length(); i++)
            {
                if(palindrome.charAt(i) != '#')
                    tmpStr += palindrome.charAt(i) + ""; 
            }
            palindrome = tmpStr;
        }
        return palindrome;
    }
    //complexity O(n)
    public static void logestPalindrome(String str)
    {
        if( str != null)
        {
            String newStr = "#";
            for(int i=0; i<str.length(); i++)
            {
                newStr += str.charAt(i) + "#"; 
            }
            int len = newStr.length();
            int[] p = new int[len];
            int c=1;
            int rightEdge = 0;
            for(int i=1; i<len; i++)
            {
                int j = c-(i-c);
                if(p[j] < rightEdge-c)
                   p[i] = p[j];
                else 
                   p[i] = rightEdge-c ;
                while(i-p[i] >= 0 && p[i-p[i]] == p[i+p[i]])
                {
                    p[i]++;
                }
                if(i+p[i] > rightEdge)
                {
                    rightEdge = i+p[i];
                    c = i;
                }
            }
            System.out.println("p="+p);
        }
    }

    public static void test1()
    {
        String s = "abbcc";
        int d = 0;
        int offset = 0;
        String[] maxArr = new String[1];
        longestPalindromeRecursion(s, d, offset, maxArr);
        System.out.println("s="+s);
        System.out.println("pal=" + maxArr[0]);
    }

    public static void test2()
    {
        String s = "abccb";
        int d = 0;
        int offset = 0;
        logestPalindrome(s);
        System.out.println("s="+s);
    }


    public static void longestPalindromeRecursion(String s, int d, int offset, String[] maxArr)
    {
        if(offset < s.length())
        {
            substring(s, d, offset, maxArr);
            longestPalindromeRecursion(s, d, offset+1, maxArr);
        }
    }
    public static void substring(String s, int d, int offset, String[] maxArr)
    {
        if(offset + d + 1 <= s.length())
        {
            String str = s.substring(offset, offset + d+1);
            if(isPalindrome(str, d))
            {
                if(maxArr[0] != null) 
                {
                    if(str.length() > maxArr[0].length())
                        maxArr[0] = str;
                }
                else
                    maxArr[0] = str;
                    
            }
            substring(s, d+1, offset, maxArr);
        }
    }
    public static boolean isPalindrome(String s, int i)
    {
        if(s.length() <= 1)
            return true;
        else if(s.charAt(i) != s.charAt(s.length()-1-i))
            return false;
        else
        {
            if(i+1 <s.length() && s.length() > 2)
                return isPalindrome(s.substring(i+1, s.length()-2), i+1);
            return true;
        }
    }
}
public class LongestPalindromeSubstringN2 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int maxlen = longestPalindromeSubstring("abkbc");
        System.out.println("maxlen="+maxlen);
    }
    public static int longestPalindromeSubstring(String str)
    {
        int maxlen = 0;
        if(str != null && str.length() > 1)
        {
            int len = str.length();
            maxlen = 1;
            for(int i=0; i<len; i++)
            {
                int currlen = 0;
                for(int j=0; j<len; j++)
                {
                    if(i+1 < len && str.charAt(i) == str.charAt(i+1))
                    {
                        if(i-j >=0 && i+1+j < len && str.charAt(i-j) == str.charAt(i+1+j))
                        {
                            if(j==0)
                                currlen +=1;
                            else 
                            {
                                if(currlen > maxlen)
                                    maxlen = currlen;
                            }
                        }
                    }
                    else 
                    {
                        if(i-j >= 0 && i+j < len && str.charAt(i-j) == str.charAt(i+j))
                        {
                            currlen += 2;
                            if(currlen > maxlen)
                                maxlen = currlen;
                        }
                    }
                }
            }
        }
        return maxlen;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*; 

class LowestCommonAncestor{
    public static Node prev = null;
    public static void main(String args[]) {
        test0_findNode();
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
    }
    public static void test0_findNode() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        Node r = findNode(b1.root, 17);
        Test.t(r.data, 17);

        Aron.end();
    }


    public static void test00() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);
        b1.insert(1);
        b1.insert(11);

        Node r = b1.getRoot();
        Node lca = LCABinTree(r, 12, 15);
        System.out.println("lca.data=" + lca.data);
        Aron.end();
    }

    public static void test0() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7); 
        Node lca = LCA2(b1.root, 1, 7);
        if(lca != null)
            Test.t(lca.data, 5);

        //Aron.binImage(b1.root);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7); 
        Node lca = LCA2(b1.root, 5, 7);
        Test.t(lca.data, 5);

        Aron.end();
    }

    public static void test2() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        b1.insert(15);
        b1.insert(18);
        b1.insert(19);
        b1.insert(35);
        Node lca = LCA2(b1.root, 15, 35);
        Test.t(lca.data, 15);
        //Aron.binImage(b1.root);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        b1.insert(15);
        Node lca = LCA2(b1.root, 12, 15);
        Test.t(lca.data, 12);
        //Aron.binImage(b1.root);

        Aron.end();
    }
    public static void test4() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        Node lca = LCA2(b1.root, 10, 12);
        Test.t(lca.data, 10);

        Aron.end();
    }

    public static void test5() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(11);
        b1.insert(12);
        Node lca = LCA2(b1.root, 12, 10);
        Test.t(lca.data, 10);

        Aron.end();
    }


//    public static Node LCA(Node r, int value1, int value2) {
//        Node ret=null;
//        if(r != null) {
//            if((r.left != null && (value1 == r.left.data || value2 == r.left.data)) ||
//                    (r.right != null && (value1 == r.right.data || value2 == r.right.data)))
//                ret = r;
//            else if(value1 < r.data && value2 < r.data)
//                ret=LCA(r.left, value1, value2);
//            else if(value1 > r.data && value2 > r.data)
//                ret=LCA(r.right, value1, value2);
//            else
//                ret = r;
//        }
//        return ret;
//    }
//
    //[ file=findnode.html title=""
    public static Node findNode(Node root, int n){
        if(root != null){
            if( root.data == n)
                return root;
            Node l = findNode(root.left, n);
            Node r = findNode(root.right, n);
            if(l != null)
                return l;
            else if(r != null)
                return r;
        }
        return null;
    }
    //]

    //[ file=lcanew.html title=""
    public static Node LCA_BasedOnFindNode(Node r, int n1, int n2){
        if(r != null){
            if(r.data == n1 || r.data == n2)
                return r;

           Node left = LCA_BasedOnFindNode(r.left, n1, n2); 
           Node right = LCA_BasedOnFindNode(r.right, n1, n2);

           if(left != null && right != null)
               return r;
           else if(left != null)
               return left;
           else if(right != null)
               return right;
           
        }
        return null;
    }
    //]

    public static Node LCA(Node root, int n1, int n2){
        if(root != null){
            if( root.data == n1 || root.data == n2)
                return root;

            Node l = LCA(root.left, n1, n2);
            Node r = LCA(root.right, n1, n2);
            if(l != null && r != null)
                return root;
            else if(l != null)
                return l;
            else if(r != null)
                return r;
        }
        return null;
    }
    public static Node LCA2(Node r, Node n1, Node n2) {
        Node ret=null;
        if(r != null && n1 != null && n2 != null) {
            if( r.left != null && (r.left.data == n1.data || r.left.data == n2.data) ||
                    r.right != null && (r.right.data == n1.data || r.right.data == n2.data))
                ret = r;
            else if(n1.data < r.data && n2.data < r.data)
                ret=LCA2(r.left, n1, n2);
            else if(n1.data > r.data && n2.data > r.data)
                ret=LCA2(r.right, n1, n2);
            else
                ret=r;
        }
        return ret;
    }

    //LCA for Binary Tree
    public static Node LCABinTree(Node r, int value1, int value2) {
        if( r != null) {
            if( r.data == value1 || r.data == value2)
                return r;
            Node nl = LCABinTree(r.left, value1, value2);
            Node nr = LCABinTree(r.right, value1, value2);
            if( nl != null && nr != null)
                return r;
            else if( nl != null)
                return nl;
            else if( nr != null)
                return nr;

        }
        return null;
    }

    public static boolean equalBinaryTree(Node r1, Node r2) {
        if(r1==null && r2==null)
            return true;
        else if(r1 != null && r2 != null) {
            if(r1.data != r2.data)
                return false;
            if(!equalBinaryTree(r1.left, r2.left))
                return false;
            if(!equalBinaryTree(r1.right, r2.right))
                return false;
        } else
            return false;
        return true;
    }

    // lowest common ancestor, least common ancestor, lca, LCA
    public static Node LCA2(Node root, int n1, int n2) {
    if(root != null){
        if(root.data == n1 || root.data == n2)
            return root;

        Node l = LCA2(root.left, n1, n2);
        Node r = LCA2(root.right, n1, n2);
        if(l != null && r != null)
            return root;
        else if( l != null)
            return l;
        else if( r != null)
            return r;
    }
    return null;
    }

}
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

public class  MagicSquareSolver{ 
 public static void main(String[] args) {
        System.out.println("Hello World!");
        MagicSquare mag = new MagicSquare();
        mag.test2();
    }
    static String remove(String str, int k){
        String s = "";
        for(int i=0; i<str.length(); i++){
            if(i != k)
                s += str.charAt(i) + "";
        }
        return s;
    }

    static void perm(String prefix, String str){
        if(str.length() == 0){
            System.out.println(prefix);
        }
        else{
            for(int i=0; i<str.length(); i++){
                perm(prefix + str.charAt(i), remove(str, i));
            }
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Majority 
{
	public static void main(String args[])
	{
	  int[] A={2, 3, 2}; 
		System.out.println(majority(A));
	}
	public static boolean majority(int[] A)
	{
		boolean ret = false;
		if( A != null)
		{
			int len = A.length;
			if(len == 1)
				ret = true;
			else if(len > 1)
			{
				int c=1;
				int mj=0;
				for(int i=1; i<len; i++)
				{
					if(A[mj] == A[i])
					 c++; 
					else
					{ c--;
						if(c == 0)
						{ mj = i; c=1;}
					}
				}
				int count=0;
				for(int i=0; i<len; i++)
				{
					if(A[mj] == A[i])
						count++;
				}
				if(count > len/2)
					ret = true;
			}
		}
		return ret;
	}
}

import java.io.*;
import java.util.*;
public class ManhattanProblem {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        int[][] array2d = new int[3][2];

        System.out.println("array2.length="+array2d.length);
        System.out.println("array2[0].length="+array2d[0].length);

        for(int i=0; i<3; i++)
        {
            for(int j=0; j<2; j++)
                System.out.print("["+array2d[i][j]+"]");
            System.out.println();
        }

        test8();
        test9();
        test10();
        test11();
    }
    public static boolean man(int[][] arr, int c, int r, ){
    }
    
    public static int[][] readFile(){
        int[][] array2d = null;
        try {
            BufferedReader bufferReader = new BufferedReader(new InputStreamReader(System.in));
            int count =0;
            int numRow = 0;
            String line = null;
            int row = 0;
            while((line = bufferReader.readLine()) != null){
                String[] array = line.split(" ");
                if(count == 0){
                    if(array.length > 0){
                        numRow = Integer.parseInt(array[0]);
                        array2d  = new int[numRow][numRow];
                    }
                } 
                else{
                    if(numRow != array.length){
                        System.out.print("ERROR"); 
                        return null;
                    }else{
                        for(int i=0; i<array.length; i++){
                            array2d[row][i] = Integer.parseInt(array[i]);        
                        }
                    }
                    row++;
                }
                count++;
            }
        } catch (Exception e) {
        }
        return array2d;
    }

    public static void test8() {
        System.out.println("test8");
        int[][] arr = { 
            {1,3,3},
            {0,3,9},
            {0,3,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 3;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                ret = manhattan(arr, h, w, k, arr[h][w]); 
                System.out.println("ret =" + ret);
            }
        }
        System.out.println("--ret =" + ret);
    }

    public static void test11() {
        System.out.println("test11");
        int[][] arr = { 
            {0,3,1},
            {0,1,4},
            {7,1,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 4;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                int num = arr[h][w];
                ret = manhattan(arr, w, h, k, num); 
                System.out.println("ret =" + ret);
            }
        }
        System.out.println("--ret =" + ret);
    }

    public static void test10() {
        System.out.println("test10");
        int[][] arr = { 
            {1,3,6},
            {0,4,4},
            {7,9,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 4;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                int num = arr[h][w];
                ret = manhattan(arr, w, h, k, num); 
                System.out.println("ret =" + ret);
            }
        }
        System.out.println("--ret =" + ret);
    }

    public static void test9() {
        System.out.println("test9");
        int[][] arr = { 
            {1,3,6},
            {0,4,4},
            {7,9,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 1;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                int num = arr[h][w];
                ret = manhattan(arr, w, h, k, num); 
                System.out.println("ret =" + ret);
            }
        }
        System.out.println("--ret =" + ret);
    } 
    //[file=manhattan.html title=""
    public static boolean manhattan(int[][] arr, int h, int w, int k, int num){
        final int visited = -1000; 
        boolean ret0 = false;
        boolean ret1 = false;
        boolean ret2 = false;
        boolean ret3 = false;
        boolean ret4 = false;
        int height = arr.length;
        int width = arr[0].length;

        if( k == 0){
            ret0 = num == arr[h][w];
        }else if(arr[h][w] != visited){
            int tmp = arr[h][w];
            arr[h][w] =  visited;
            if(w + 1 < width){
                 arr[h][w] = visited;
                 ret1 = manhattan(arr, h, w+1,k-1, num);
                 arr[h][w] = tmp;
                 if(ret1)
                     return ret1;
             }

            if(w - 1 >= 0){
                 arr[h][w] = visited;
                 ret2 = manhattan(arr,  h, w-1,k-1, num);
                 arr[h][w] = tmp;
                 if(ret2)
                     return ret2;
             }

            if(h - 1 >= 0){
                 ret3 = manhattan(arr,  h-1, w, k-1, num);
                 arr[h][w] = tmp;
                 if(ret3)
                     return ret3;
             }

             if(h + 1 < height){
                 ret4 = manhattan(arr, h+1, w, k-1, num);
                 arr[h][w] = tmp;
                 if(ret4)
                     return ret4;
             }
        }
        return ret0 || ret1 || ret2 || ret3 || ret4;
    }
}
import java.io.*;
import java.util.*;
class Mapdemo
{
	public static void main(String args[])
	{
		Map ml = new HashMap();		
		ml.put("cool", "89");
		System.out.println(ml);

		if(ml.containsKey("cool"))
		{
			System.out.println("yup");
		}
		else
		{
			System.out.println("no");
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class MatchNum{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test10();
        test11();
    }
    public static void test0(){
        Aron.beg();
        String str = "12";
        boolean isNum = isNumeric(str);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        String str = "1200";
        boolean isNum = isNumeric(str);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        String str = "0";
        boolean isNum = isNumeric(str);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        String str = "a";
        boolean isNum = isNumeric(str);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test4(){
        Aron.beg();
        String str = "0314";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test5(){
        Aron.beg();
        String str = "0";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);
        Aron.end();
    }
    public static void test6(){
        Aron.beg();
        String str = "-123";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test7(){
        Aron.beg();
        String str = "0";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test8(){
        Aron.beg();
        String str = "+12";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test9(){
        Aron.beg();
        String str = "+";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test10(){
        Aron.beg();
        String str = "-";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test11(){
        Aron.beg();
        String str = "+-";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }

    // is positive Integer from [-n -1 0 1 n] 
    public static boolean isNumeric(String str){
        //return str.matches("[1-9][0-9]+");
        return str.matches("[-+]?[1-9][0-9]*|0");
    }
} 

public class MatrixDiagonal {
    public static void main(String[] args) {
        int[][] array = { {1, 2, 3, 4},
            {2, 3, 4, 5},
            {6, 7, 9, 8},
            {3, 2, 1, 2}
        };
        int len = array.length;
        for(int i=0; i<len; i++) {
            for(int j=0; j<len; j++) {
                System.out.print("["+array[i][j]+"]");
            }
            System.out.println("");
        }

        System.out.println("Print all diagonals of matrix");
        printDiagonal(array);
    }
    //Given square matrix
    public static void printDiagonal(int[][] array) {
        if(array != null) {
            int len = array.length;
            for(int i=0; i<2*len-1; i++) {

                for(int j=0; j<len && j+i<len; j++) {
                    if(j == j+i) {
                        System.out.print("["+array[j][j]+"]");
                    }
                }
                if(i==0)
                    System.out.println("");
                for(int j=0; j<len && j+i < len; j++) {
                    if(j < j+i) {
                        System.out.print("["+array[j][j+i]+"]");
                    }
                }
                if(i != 0)
                    System.out.println("");
                for(int j=0; j<len && j+i<len; j++) {
                    if(j < j+i) {
                        System.out.print("["+array[j+i][j]+"]");
                    }
                }
                if(i != 0)
                    System.out.println("");
            }
        }
    }
}
public class MatrixMulti {
    public static void main(String[] args) {
        test0();
        test1();
    }

    // multiply matrix, mul matrix, mult matrix
    public static int[][] multiply(int[][] A, int[][] B) {
        int[][] C = null;
        if( A != null && B != null) {
            int alen = A.length;
            int blen = B.length;
            int clen = alen;
            C = new int[alen][alen];
            for(int c = 0; c < clen; c++) {
                for(int i = 0; i < alen; i++) {
                    int s = 0;
                    for(int j = 0; j < blen; j++) {
                        s += A[i][j]*B[j][c];
                    }
                    C[i][c] = s;
                }
            }
        }
        return C;
    }

    //[ file=matrixmul.html title=""
    // Better way to multiply matrix, mul matrix, mult matrix
    public static int[][] multiply2(int[][] arr1, int[][] arr2) {
        int[][] arr3 = null;
        if( arr1 != null && arr2 != null) {
            int height = arr1.length;
            int width = arr1[0].length;
            int len = height;
            arr3 = new int[height][height];
            for(int k = 0; k < len; k++) {
                for(int i = 0; i < height; i++) {
                    for(int j = 0; j < width; j++) {
                        arr3[i][j] += arr1[i][k]*arr2[k][j];
                    }
                }
            }
        }
        return arr3;
    }
    //]
    
    static void test0(){
        System.out.println("---------------------------------\n");
        int[][] A = {{1}};
        int[][] B = {{2}};
        int[][] C = multiply2(A, B);
        Aron.printArray2D(C);

        System.out.println("---------------------------------\n");
    }
    static void test1(){
        System.out.println("---------------------------------\n");
        int[][] A = {{1, 1},
                    {0, 1}
        };
        int[][] B = {{2, 0},
                    {0, 3}
        };
        int[][] C = multiply2(A, B);
        Aron.printArray2D(C);
        System.out.println("---------------------------------\n");
    }
}
public class MatrixMultiNew 
{
    public static void main(String[] args)
    {
        System.out.println("New Algorithm for Matrix Multiplication!");
        int[][] A = {{1, 2},
                     {3, 4}}; 
        int[][] B = {{2, 3},
                     {4, 5}}; 

        int[][] C = Multiply(A, B);
        for(int i=0; i<C.length; i++)
        {
            for(int j=0; j<C.length; j++)
            {
                System.out.print("["+C[i][j]+"]");
            }
            System.out.println();
        }
    }
    public static int[][] Multiply(int[][] A, int[][] B)
    {
        int[][] C = null;
        if(A != null && B != null)
        {
            C = new int[A.length][A.length];
            for(int i=0; i<A.length; i++)
            {
                for(int j=0; j<A.length; j++)
                {
                    for(int k=0; k<A.length; k++)
                    {
                        
                         C[k][j] += A[k][i]*B[i][j];
                    }
                }
            }
        }
        return C;
    }

}
import java.util.*;
import java.io.*;
import classfile.*;


// max sum, max continuous sum, consecutive sum, max consecutive sum 
// maximum continuous sum, maximum consecutive sum, max array sum, max sum array
// max sum with index, 
// max sum index, first index, last index, first last index
// maxsum
public class MaxConsecutiveArray{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();

        test00();
        test11();
        test12();
        test_maxConsecutiveSum_1();
        test_maxConsecutiveSum_2();
        test_maxConsecutiveSum_3();
        test_maxConsecutiveSum_4();
        test_maxConsecutiveSum_5();
    }
    //[ file=consecutive.html title=""
    //  4, -5, 9, 7, -8, 3
    //--------------------------------------------------------------------------------
    // m = 0
    // max = 0
    //--------------------------------------------------------------------------------
    // m = max(m, m+3) = 3
    // max = 3
    //--------------------------------------------------------------------------------
    // m = max(m, m+-8) = -5 = 0
    // max = 3
    //--------------------------------------------------------------------------------
    // m = max(m, m+7) = 7
    // max = 7
    //--------------------------------------------------------------------------------
    // m = max(m, m+9) = 16
    // max = 16
    //--------------------------------------------------------------------------------
    // m = max(m, m -5) = 11
    // max = 16
    //--------------------------------------------------------------------------------
    // m = max(m, m + 4) = 15
    // max = 16
    //-------------------------------------------------------------------------------- 
    public static int maxConsecutive(int[] arr) {
        int m = 0, max = 0;
        int startIndex = 0;
        int endIndex   = 0;
        if(arr != null) {
            for(int i=0; i<arr.length; i++) {
                if(m + arr[i] > 0){
                    m = Math.max(m + arr[i], arr[i]);

                    if(m > max){
                        max = m;
                    }
                }
                else{
                    m = 0;
                }
            }
        }
        return max;
    }
    //]

    //[ file=maxsumnegative.html  title=""
    // wrong code
    public static int maxConsecutiveNegative(int[] arr) {
        int max_so_far = arr[0], currMax = arr[0];
        if(arr != null) {
            for(int i=1; i<arr.length; i++) {
                max_so_far = Math.max(arr[i], currMax + arr[i]);
                currMax = Math.max(currMax, max_so_far);
            }
        }
        return currMax;
    }
    //]

    // -4, 2 
    // 2, 
    // -4, 2, -1, 5
    // -4, 2, -3, 5
    // first and last index
    static int maxConsecutiveSum(int[] arr){
        int max = 0;
        if(arr != null){
            int len = arr.length;
            if(len > 0){
                max = arr[0];
                int sum = arr[0];
                int first = 0;
                int second = 0;
                int tmpFirst = 0;
                for(int i=1; i<len; i++){
                    if(sum < 0){
                        sum = 0;
                        tmpFirst = i;
                    }
                    sum += arr[i];
                    if(max < sum){
                        max = sum;
                        first = tmpFirst;
                        second = i;
                    }
                }
                Print.pb("first=" + first);
                Print.pb("second=" + second);
            }
        }
        return max;
    } 

    static void test0() {
        Aron.beg();
        int[] arr = {1, -2, 8, 9, -4, 5};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 18);
        Aron.end();
    }

    static void test1() {
        Aron.beg();
        int[] arr = {1};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 1);
        Aron.end();
    }
    static void test2() {
        Aron.beg();
        int[] arr = {1, -9};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 1);
        Aron.end();
    }
    static void test3() {
        Aron.beg();
        int[] arr = {4, 1, -9, 10};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 10);
        Aron.end();
    }
    static void test4() {
        Aron.beg();
        int[] arr = {4, 1, -9, 10, 4, -5, 7};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 16);
        Aron.end();
    }
    public static void test5(){
        Aron.beg();
        int[] arr = {2, -3, -2, 4, -3, 5}; 
        Aron.printArray(arr);
        int max = maxConsecutive(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test6(){
        Aron.beg();
        int[] arr = {2, -3, 2, -2, 5, -3, 2, 1}; 
        Aron.printArray(arr);
        int max = maxConsecutive(arr);
        Test.t(max, 5);

        Aron.end();
    }
    public static void test7(){
        Aron.beg();
        int[] arr = {-2, 0, 0, 7, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutive(arr);
        Test.t(max, 7);

        Aron.end();
    }
    public static void test8(){
        Aron.beg();
        int[] arr = {-2, -3, -1, -4, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, -1);

        Aron.end();
    }
    public static void test00(){
        Aron.beg();
        int[] arr = {-2, -3, -1, -4, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, -1);

        Aron.end();
    }
    public static void test11(){
        Aron.beg();
        int[] arr = {-2, 0, 0, 7, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, 7);

        Aron.end();
    }
    public static void test12(){
        Aron.beg();
        int[] arr = {-3, 2, -4, 9}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, 9);

        Aron.end();
    }

    public static void test_maxConsecutiveSum_1(){
        Aron.beg();
        int[] arr = {-4, 2, -3, 5}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 5);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_2(){
        Aron.beg();
        int[] arr = {-4, 2, -1, 5}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_3(){
        Aron.beg();
        int[] arr = {-4, 2}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 2);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_4(){
        Aron.beg();
        int[] arr = {2}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 2);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_5(){
        Aron.beg();
        int[] arr = {2, 3}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 5);

        Aron.end();
    }
}

public class MaxContinuous 
{
    public static void main(String[] args)
    {
        int[] array = {2, 4, 7, 1, 5, 8, 10, 11, 12, 13, 11, 14, 15, 16, 0, 1, 2, 3, 5, 6, 7};
        maxContinuous(array);
    }
    public static void maxContinuous(int[] array)
    {
        if(array != null)
        {
            int len = array.length;
            int[] arr = new int[len];
            for(int i=0; i<len; i++)
                arr[i] = 1;

            int maxIndex = 0;
            int max = arr[0];
            for(int i=1; i<len; i++)
            {
                if(array[i] > array[i-1])
                    arr[i] = arr[i-1] + 1;

                if(arr[i] > max)
                {
                    max = arr[i];
                    maxIndex = i;
                }
            }
            System.out.println("beginIndex=" + (maxIndex - max + 1));
            System.out.println("maxIndex=" + maxIndex);
            System.out.println("max=" + max);
        }
    }
}
import java.util.HashMap;
import java.util.Map;
import java.util.Hashtable;
import java.util.HashSet;
import java.util.List;
import java.util.*;
import java.lang.Math;

import classfile.*;

public class MaxContinuousList {
    public static void main(String[] args) {
        test8();
        test9();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
    }
    static void test8() {
        Aron.beg();
        Integer[] arr = {2, -5, 8, -2, 3};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test9() {
        Aron.beg();
        Integer[] arr = {-1, -5, 8, -4, 5, -2, 3, -2};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test10() {
        Aron.beg();
        Integer[] arr = {-1, -5, 8};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }

    static void test11() {
        Aron.beg();
        Integer[] arr = {6, -5, 8};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test12() {
        Aron.beg();
        Integer[] arr = {3, -4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test13() {
        Aron.beg();
        Integer[] arr = {-4, 5};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test14() {
        Aron.beg();
        Integer[] arr = {-4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test15() {
        Aron.beg();
        Integer[] arr = {4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test16() {
        Aron.beg();
        Integer[] arr = {4, 0};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test17() {
        Aron.beg();
        Integer[] arr = {0, 4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test18() {
        Aron.beg();
        Integer[] arr = {-2, 4, 3, -8, 3};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void getAllPaths(Node n, Map<Node, Node> map, int num, List<Node> list) {
        if(n.data == num) {
            for(Node node : list) {
                System.out.println("[" + node.data + "]");
            }
            System.out.println("\n---------------------------------");
        } else {
            Node curr = map.get(n);
            while(curr != null) {
                list.add(curr);
                getAllPaths(curr, map, num, list);

                if(list.size() > 0)
                    list.remove(list.size()-1);

                curr = curr.next;
            }
        }
    }

    //[ file=maxlistindex.html title=""
    //
    // only work when not all elem are negative
    //
    // Sun Sep 25 18:03:40 PDT 2016
    // Fix bug: start gets the wrong index
    // start index, end index 
    static int maxList(Integer[] arr) {
        int tmp_start = 0;
        int end = 0;
        int start = 0;
        int max = 0;
        int sum = 0;
        for(int i=0; i<arr.length; i++) {
            if(sum == 0) {
                tmp_start = i;
            }

            if(sum + arr[i] > 0) {
                int m = Math.max(arr[i], sum + arr[i]);
                if(m > max) {
                    max = m;
                    start = tmp_start;
                    end = i;
                }
                sum += arr[i];
            } else {
                sum = 0;
            }
        }
        Print.p("start[" + start + "]");
        Print.p("end  [" + end + "]");
        return max;
    }
    //]
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class MaxDepthIteration 
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();


		b1.Insert(10);
		
		b1.Insert(5);
		b1.Insert(1);
		b1.Insert(7);
		b1.Insert(9);
		
		
		
		
		int c = MaxDepthIteration(b1.getRoot());
		System.out.println("c=" + c);
	}
	//in order traversal using iteration
	public static int MaxDepthIteration(Node r)
	{
		Stack<Node> st = new Stack<Node>();
		Node cur = r;

		int max=0;
		int c=0;
		if( cur != null)
		{ 
			while(!st.empty() || cur != null)
			{
				if(cur != null)
				{
					st.push(cur);
					c++;
					if(c>max)
						max=c;
					cur = cur.left;
				}
				else 
				{ Node no = st.pop();
					if(no.right == null) //last traversal node has to be the right node observation from the recursive Inorder traversal 
						c--;
					System.out.println("no.data=" + no.data);
					cur = no.right;
				}
			}
		}
		return max;
	}
	
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

public class MaxDiff{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0() {
        Aron.beg();
        int[] arr = {2, 4}; 
        int max = maxDiff(arr);
        Test.t(max, 2);
        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        int[] arr = {2, 4, 7, 1, 7, 2}; 
        int max = maxDiff(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();
        int[] arr = {4, 1, 7}; 
        int max = maxDiff(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        int[] arr = {15, 10, 17, 1, 9}; 
        int max = maxDiff(arr);
        Test.t(max, 8);

        Aron.end();
    }

    //[file=maxdiff.html title=""
    // [2, 4, 7, 1, 7, 2]
    // [4, 2] => 0
    // [1, 3, 4]
    // [3, 1, 7]
    public static int maxDiff(int[] arr){
        int maxDiff = 0;
        if(arr != null && arr.length > 1){
            int len = arr.length;
            int min = arr[0];
            for(int i=1; i<len; i++){

                if(arr[i-1] < min)
                    min = arr[i-1];
                    
                if(arr[i] - min > maxDiff)
                    maxDiff = arr[i] - min;
            } 
        }
        return maxDiff;
    }
    //]
}

import java.io.*;
import java.lang.String;
import java.util.*;
class MaxDistance {
    public static void main(String args[]) {
        int[] Arr = {10, 11, 2, 1, 0, 4};
        int max = MaxDistance(Arr);
        System.out.println("max=" + max);
    }


    public static int MaxDistance(int[] Arr) {
        int max_d = 0;
        if( Arr != null) {
            int len = Arr.length;
            int[] InxArr = new int[len];

            if(len > 0) {
                InxArr[0] = 0;
                int c=1;
                for(int i=1; i<len; i++) {
                    if(Arr[i-1] > Arr[i]) {
                        InxArr[c] = i;
                        c++;
                    }
                }
                int k=0;
                for(int i=0; i<len; i++) {
                    for(int j=k; j<c; j++) {
                        int d = len-1-i - InxArr[c-1-j];
                        if(d > 0 && Arr[len-1-i] > Arr[InxArr[c-1-j]]) {
                            if(d > max_d) {
                                max_d = d;
                                k=j;
                            }
                        }
                    }
                }
            }
        }
        return max_d;
    }
}
public class MaxDistanceThreeSortIntegers
{
    public static void main(String[] args)
    {
        System.out.println("hello world!");
        int[] arr1 = {1, 4, 500, 600};
        int[] arr2 = {2, 5, 10, 500};
        int[] arr3 = {6, 20, 30, 500, 501};

        printArray(arr1);
        printArray(arr2);
        printArray(arr3);
        int min = findMaxAbsSum(arr1, arr2, arr3);
        System.out.println("min["+min+"]");
    }
    public static int findMaxAbsSum(int[] arr1, int[] arr2, int[] arr3)
    {
        int gmin = Integer.MAX_VALUE;
        if(arr1 != null && arr2 != null && arr3 != null)
        {
            int len1 = arr1.length;
            int len2 = arr2.length;
            int len3 = arr3.length;
            int inx1 =0, inx2 = 0, inx3 = 0;
            while(inx1 < len1  && inx2 < len2 && inx3 < len3)
            {
                int min = Math.min(Math.min(arr1[inx1], arr2[inx2]), arr3[inx3]);
                int max = Math.max(Math.max(arr1[inx1], arr2[inx2]), arr3[inx3]);
                int sum = 2*(max - min);
                if(sum == 0)
                    return 0;

                if(sum < gmin)
                    gmin = sum;

                if(min == arr1[inx1]) inx1++;
                if(min == arr2[inx2]) inx2++;
                if(min == arr3[inx3]) inx3++;
            }
        }    
        return gmin;
    }
    public static void printArray(int[] arr)
    {
        if(arr != null)
        {
            for(int i=0; i<arr.length; i++)
                System.out.println("arr["+i+"]["+arr[i]+"]");
        }
        System.out.println("===============");
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// graph with weight
// maximum path in graph, max path in graph, max path tree, 
// maximum graph in tree, maxpath, path tree
//
// gx /Library/WebServer/Documents/zsurface/image/maxpath.png
public class MaxPath{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }

    // gx /Library/WebServer/Documents/zsurface/image/maxpath.png
    public static void test0(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 3, 0},
            {0, 0, 7, 3},
            {0, 0, 0, 6},
            {0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 3;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 14);
    
        Aron.end();
    }

    // gx /Library/WebServer/Documents/zsurface/image/maxpath2.png
    public static void test1(){
        Aron.beg();

        int[][] arr2d = {
            {0, 3, 7, 7, 0},
            {0, 0, 9, 2, 4},
            {0, 0, 0, 20,0},
            {0, 0, 0, 0, 9},
            {0, 0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 4;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 41);

        Aron.end();
    }

    public static void test2(){
        Aron.beg();

        int[][] arr2d = {
            {0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 0;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 0);

        Aron.end();
    }

    public static void test3(){
        Aron.beg();

        int[][] arr2d = {
            {0, 3},
            {0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 1;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 3);

        Aron.end();
    }

    // gx /Library/WebServer/Documents/zsurface/image/maxpath.png
    public static int mathPathGraph(int[][] arr, int n1, int n2, int width){
        int max = 0;
        if(n1 != n2){
            for(int i=0; i<width; i++){
                if(n1 != i){
                    if(arr[n1][i] > 0){
                        int m = mathPathGraph(arr, i, n2, width) + arr[n1][i]; 
                        max = Math.max(max, m);
                    }
                }
            } 
        }
        return max;
    }

    // max path in tree, max path tree, maxpath binarytree
    public static int maxPathTree(Node r){
        if(r != null){
            int left = maxPathTree(r.left);
            int right = maxPathTree(r.right);
            return Math.max(left, right) + r.data;
        }
        return 0;
    }
} 

import java.io.*;
import java.lang.*;
import java.util.*;

class MaxRepeatingChar 
{
	public static void main(String args[])
	{
		int c = maxrepeating("aacc");
		System.out.println(c);
	}
	public static int maxrepeating(String str)
	{
		int max = 0;
		if( str != null && str.length() > 0)
		{
			int len=str.length();
			int c=1; max=1;
			if(len > 1)
			{
				for(int i=1; i<len; i++)
				{
					if(str.charAt(i-1) == str.charAt(i))
					{ c++; if(c > max) max = c; }
					else
						c=1;
				}
			}
		}
		return max;
	}
}

import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class MaxSumPathBT 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(10);
		b1.Insert(5);
		b1.Insert(15);
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
        
        System.out.println("Before Swap");
        inorder(b1.getRoot());

        System.out.println("============");
        System.out.println("After Swap");

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        //swap(199, 16, b1.getRoot(), first, second);
        
        System.out.println("Max Sum in a path=" + MaxSumPath(b1.getRoot()));
        inorder(b1.getRoot());
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            else if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
		        System.out.println(node.data);
            inorder(node.right);
        }
    }
    
    public static int MaxSumPath(Node node)
    {
        if(node != null)
        {
            int left = MaxSumPath(node.left) + node.data;
            int right = MaxSumPath(node.right) + node.data;
            if(left > right)
                return left;
            else
                return right;  
        }
        else
        {
            return 0;
        }
    }
}
public class MaxTupleInAscendingOrder 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    public static int[] findMax(int[] arr)
    {
        if( arr != null)
        {
            int[] tuple = new int[3];
            int count = 0;
            tuple[0] = arr[0];
            for(int i=1; i<arr.length; i++)
            {
                for(int j=0; j<=count; j++)
                {
                    if(tuple[j] < arr[i])    
                }
            }
        }
    }
}
public class MazeFindPath 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        /*
        int[][] maze = { {0,0, 4, 4},
                         {4,0, 0, 0},
                         {4,0, 4, 0},
                         {4,0, 0, 3}
                        }; 
        int row = 0;
        int col = 0;
        for(int i=0; i<maze.length; i++)
        {
            for(int j=0; j<maze.length; j++)
            {
                System.out.print("["+maze[i][j]+"]");
            }
            System.out.println();
        }

        int[] path = new int[50];
        int level = 0;
        //findAllPath(maze, row, col, path, level);
        //findPath(maze, row, col);
        int min=100;
        int[] minPath = new int[100];
        int m = findTheShortestPath(maze, col, row, path, minPath, level, min);
        for(int i=0; i<m; i++)
        {
            int c = minPath[i]/maze.length;
            int r = minPath[i]%maze.length;
            System.out.println("["+c+"]["+r+"]");
        }
        */

        test1();

    }

    public static boolean findPath(int[][] maze, int row, int col)
    {
        if(maze != null && row < maze.length && col < maze.length)
        {
               if(maze[row][col] == 3)
               {
                   System.out.println("["+row+"]["+col+"]");
                   return true;
               }
               if(maze[row][col] == 0)
               {
                    maze[row][col] = 2;
                    if(findPath(maze, row, col+1))
                    { 
                       System.out.println("["+row+"]["+col+"]");
                       return true;
                    }
                    if(findPath(maze, row+1, col))
                    {
                       System.out.println("["+row+"]["+col+"]");
                       return true;
                    }
               }
        }
        return false;
    }

    public static void findAllPath(int[][] maze, int row, int col, int[] path, int level)
    {
        if(maze != null && row < maze.length && col < maze.length)
        {
               if(maze[row][col] == 3)
               {
                   path[level] = row*maze.length+col;
                   for(int i=0; i<=level; i++){
                       int r = path[i]/maze.length;
                       int c = path[i]%maze.length; 
                       System.out.println("["+r+"]["+c+"]");
                   }
                   System.out.println("");
               }
               if(maze[row][col] == 0)
               {
                   path[level]=row*maze.length + col;
                    findAllPath(maze, row, col+1, path, level+1);
                    findAllPath(maze, row+1, col, path, level+1);
               }
        }
    } 
    public static int findTheShortestPath(int[][] maze, int col, int row, int[] path, int[] minPath, int level, int min)
    {
        if( maze != null)
        {
            if(maze[col][row] == 3)
            {
                path[level] = col*maze.length+row;
                System.out.println("{"+col+"}{"+row+"}");
                System.out.println("minPath["+level+"]="+path[level]);
                if(level < min)
                {
                    min = level;                    
                    for(int i=0; i<=level; i++)
                    {
                        minPath[i] = path[i];
                    }
                }
            }
            else if(maze[col][row] == 0)
            {
                path[level] = col*maze.length+row;
                System.out.println("{"+col+"}{"+row+"}");
                maze[col][row] = 2;
                int r = 100, d = 100, l = 100, u = 100;
                if(row+1 < maze.length)
                    r = findTheShortestPath(maze, col, row+1, path, minPath, level+1, min);
                if(col+1 < maze.length)
                    d = findTheShortestPath(maze, col+1, row, path, minPath, level+1, min);
                if(row-1 > 0)
                    l = findTheShortestPath(maze, col, row-1, path, minPath, level+1, min);
                if(col-1 > 0)
                    u = findTheShortestPath(maze, col-1, row, path, minPath, level+1, min);
                min = Math.min(Math.min(r, d), Math.min(l, u));
            }
        }
        return min;
    }
    public static void test1()
    {
        int[][] maze = { 
                         {0,0, 4, 4, 0, 0},
                         {0,0, 0, 0, 0, 0},
                         {0,4, 0, 4, 4, 0},
                         {0,4, 0, 4, 0, 0},
                         {0,0, 0, 0, 4, 0},
                         {0,4, 4, 0, 0, 3}
                        }; 
        int row = 0;
        int col = 0;
        for(int i=0; i<maze.length; i++)
        {
            for(int j=0; j<maze.length; j++)
            {
                System.out.print("["+maze[i][j]+"]");
            }
            System.out.println();
        }

        int[] path = new int[100];
        int[] minPath = new int[100];
        int level = 0;
        int min=100;

        int m = findTheShortestPath(maze, col, row, path, minPath, level, min);
        System.out.println("m["+m+"]");
        for(int i=0; i<=m; i++)
        {
            int c = minPath[i]/maze.length;
            int r = minPath[i]%maze.length;
            System.out.println("["+c+"]["+r+"]");
        }
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class MedianOfStream{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        Integer[] arr = {2, 1, 3, 4, 5, 0};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Integer[] arr = {2, 1};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        Integer[] arr = {1, 2};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        Integer[] arr = {2};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }

    // test [2, 1] = > [1, 2], pivot = [0]
    public static void quickSort(Integer[] arr, int lo, int hi){
        if(lo < hi){
            int pivot = partition(arr, lo, hi);
            quickSort(arr, lo, pivot -1);
            quickSort(arr, pivot + 1, hi);
        }
    }

    public static int partition(Integer[] arr, int lo, int hi){
        int big = lo;
        int pivot = arr[hi];
        for(int i=lo; i<=hi; i++){
            if(arr[i] <= pivot){
                swap(arr, big, i);
                if(i < hi)
                    big++;
            }
        }
        return big;
    }
    public static void swap(Integer[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    
    public static void Median(int[] arr){
                    
    }
} 

import java.util.*;

public class MergeArrayLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("merge array and merge linkedlist");
    }

    public static int[] merge(int[] arr1, int[] arr2) {
        int[] arr = null; 
        if(arr1 == null)
            return arr2;
        else if(arr2 == null)
            return arr1;
        else {
            int len1 = arr1.length;
            int len2 = arr2.length;
            arr = new int[len1+len2];
            int inx1 = 0;
            int inx2 = 0;
            int k=0;

            while(inx1 < len1 || inx2 < len2) {
                if(inx1 >= len1) {
                    arr[k] = arr1[inx2];
                    inx2++;
                }
                else if(inx2 >= len2) {
                    arr[k] = arr2[inx1];
                    inx1++;
                }
                else {
                    if(arr1[inx1] < arr2[inx2]) {
                        arr[k] = arr1[inx1];
                        inx1++;
                    }
                    else if(arr1[index] == arr2[inx]){
                        arr[k] = arr1[inx1];
                        k++;
                        inx1++;
                        arr[k] = arr2[inx2];
                        k++;
                        inx2++;
                    }
                    else {
                        arr[k] = arr2[inx2];
                        inx2++;
                    }
                }
                k++;
            }
        }
        return arr;
    }
    public static Node mergeList(Node s1, Node s2)
    {
        Node curr = null;
        Node head = curr;
        while( s1 != null || s2 != null)
        {
            if(s1 == null)
            {
                if(curr == null)
                   head = curr = s2;
                else
                {
                    curr.next = s2;
                    curr = curr.next;
                }
                s2 = s2.next;
            }
            else if(s2 == null)
            {
                if(curr == null)
                    head = curr = s1;
                else
                {
                    curr.next = s1;
                    curr = curr.next;
                }
                s1 = s1.next;
            }
            else
            {
                if(s1.data < s2.data)
                {
                    if(curr == null)
                        head = curr = s1;
                    else
                    {
                        curr.next = s1;
                        curr = curr.next;
                    }
                    s1 = s1.next;
                }
                else
                {
                    if( curr == null)
                        head = curr = s2;
                    else
                    {
                        curr.next = s2;
                        curr = curr.next;
                    }
                    s2 = s2.next;
                }
            }
        }
        return head;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class MergeExtraSpace{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
    static void test0(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 7, 9, 0}; 
        Integer[] arr2 = {3}; 
        int len = 4;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test1(){
        Aron.beg();
        Integer[] arr1 = {4, 0}; 
        Integer[] arr2 = {3}; 
        int len = 1;



        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0}; 
        Integer[] arr2 = {3}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test3(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {3, 9}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }
    static void test4(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {4, 5}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test5(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {4, 5}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge2(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test6(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {2, 3}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge2(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }
    //[ file=mergespace.html title=""
    // 2, 4, [] []
    // [2] 3, {4}
    // [3]x
    public static void merge(Integer[] arr1, int len, Integer[] arr2){
        if(arr1 != null && arr2 != null){
            int len2 = arr2.length;
            for(int i=len-1; i>=0; i--){
                arr1[i+len2] = arr1[i];    
            }
            int p1 = len2;
            int p2 = 0; 
            int k = 0;

            while(p2 < len2 || p1 < len + len2){
                if(p2 >= len2){
                    arr1[k] = arr1[p1];
                    p1++;
                }else if(p1 >= len + len2){
                    arr1[k] = arr2[p2];
                    p2++;
                }else{
                    if(arr1[p1] < arr2[p2]){
                        arr1[k] = arr1[p1];
                        p1++;
                    }else{
                        arr1[k] = arr2[p2];
                        p2++;
                    }
                }
                k++;
            }
        }
    } 

    // [2][]
    // [3]
    public static void merge2(Integer[] arr1, int len1, Integer[] arr2){
        if(arr1 != null && arr2 != null){
            if(arr1.length > 0 || arr2.length > 0){
                int len2 = arr2.length;
                int k = len2 + len1 - 1;
                int p1 = len1 - 1;
                int p2 = len2 - 1;

                while(p1 >= 0 || p2 >= 0){ 
                    if(p1 < 0){
                        arr1[k] = arr2[p2];
                        p2--;
                    }else if(p2 < 0){
                        arr1[k] = arr1[p1];
                        p1--;
                    }else{
                        if(arr1[p1] > arr2[p2]){
                            arr1[k] = arr1[p1];
                            p1--;
                        }else{
                            arr1[k] = arr2[p2];
                            p2--;
                        }
                    }
                    k--;
                }
            }
        }
    }

    //]
} 
package classfile;

import java.io.*;
import java.lang.String;
import java.util.*;

class MergeHalfList{
    public static void main(String args[]) {
    }

    public static Node mergeHalf(Node head) {
        Node curr = head;
        Queue<Node> q0 = new LinkedList<Node>();
        Queue<Node> q1 = new LinkedList<Node>();
        int count = 0;
        while(curr != null) {
            System.out.println("curr[" + curr.data+"]");
            q1.add(new Node(curr.data));
            curr = curr.next;
        }

        int halfsize = q1.size()/2;
        int size = q1.size();
        System.out.println("q1size[" + q1.size()+"]");
        System.out.println("q1size/2[" + halfsize +"]");
        for(int i=0; i<= size/2; i++) {
            Node node = q1.remove();
            System.out.println("node[" + node.data+"] i=[" + i+"]");
            q0.add(new Node(node.data));
        }

        System.out.println("q0.size[" + q0.size()+"]");
        Node prevPair = null;
        Node currPair = null;
        Node newHead = null;
        while(q0.peek() != null) {
            Node n0 = q0.remove();
            Node n1 = null;
            if(q1.peek() != null) {
                n1 = q1.remove();
                System.out.println("q1[" + n1.data+"]");
            }

            n0.next = n1;
            currPair = n0;

            if(prevPair!= null)
                prevPair.next.next = currPair;
            else
                newHead = currPair;
            prevPair = currPair;
        }
        return newHead;
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

//[ file=mergeintervals.html title=""
class Interval implements Comparable<Interval>{
    public int begin;
    public int end;
    public Interval(int begin, int end){
        this.begin = begin;
        this.end = end;
    }
    public int compareTo(Interval inter){
        if(this.begin > inter.begin)
           return 1; 
        else if(this.begin == inter.begin)
            return 0;
        else
            return -1;
    }
    public String toString(){
        return "[" + begin + " " + end + "]";
    }
}

public class MergeIntervals{
    public static void main(String[] args) {
        test00();
    }
    static void test00(){
        Aron.beg();
        PriorityQueue<Interval> queue = new PriorityQueue<Interval>();
        Stack<Interval> stack = new Stack<Interval>();
        int[] arr1 = {4, 1, 2, 6, 9};
        int[] arr2 = {5, 1, 4, 9, 10};
        
        for(int i=0; i<arr1.length; i++){
            queue.add(new Interval(arr1[i], arr2[i]));
        }
        if(queue.size() > 0){
            stack.push(queue.remove());
        }
        while(!queue.isEmpty()){
            Interval top = stack.peek();
            Interval inter = queue.remove();
            if(top.end < inter.begin)
                stack.push(inter);
            else{
                stack.peek().end = Math.max(stack.peek().end, inter.end);
            }
        }
        while(!stack.empty()){
            System.out.println("[" + stack.peek().begin + " " + stack.peek().end + "]");
            stack.pop();
        }
        
        Aron.end();
    }
}
//]
public class MergeSortArray 
{
    public static void main(String[] args)
    {
        System.out.println("Merge Sort Array");
        test1();
        test2();
        test3();
        test4();
    }

    public static void test1()
    {
        int[] A = {3, 2, 1};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }

    public static void test2()
    {
        int[] A = {2, 1};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }

    public static void test3()
    {
        int[] A = {1};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }

    public static void test4()
    {
        int[] A = {10, 1, 9, 100, 6, 3, 3, 5};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }
    public static void merge(int[] A, int lo, int mid, int hi)
    {
        if( A != null)
        {
            int[] B = new int[hi-lo+1];

            int index1 = lo;
            int index2 = mid+1;
            int k=0;
            while(k < (hi-lo+1))
            {
                if(index1 > mid)
                {
                    B[k] = A[index2];
                    index2++;
                }
                else if(index2 > hi)
                {
                    B[k] = A[index1];
                    index1++;
                }
                else
                {
                    if(A[index1] < A[index2])
                    {
                        B[k] = A[index1]; index1++;
                    }
                    else
                    {
                        B[k] = A[index2]; index2++;
                    }
                }
                k++;
            }
            for(int i=0; i<B.length; i++)
                A[lo+i] = B[i];
        }
    }
    public static void mergeSort(int[] A, int lo, int hi)
    {
        if(lo<hi)
        {
            int mid = (lo+hi)/2;
            mergeSort(A, lo, mid);
            mergeSort(A, mid+1, hi);
            merge(A, lo, mid, hi);
        }
    }
}
class Node 
{
	Node next;
	int data;
	public Node(int n)
	{ next = null; data = n;}
}

class SLL
{
	Node head;
	public SLL()
	{ head = null;}

    public void append(int n)
    {
        Node cur = head;
		if(head == null)
			head = new Node(n);
		else
		{
			while(cur.next != null)
			{ 
                cur = cur.next; 
            }
			cur.next = new Node(n);
		}

    }

	public void append(Node no)
	{
		Node cur = head;
		if(head == null)
			head = no;
		else
		{
			while(cur.next != null)
			{ cur = cur.next; }
			cur.next = no;
		}
	}

	//recursive 
	static Node next=null;
	public void Reverse(Node cur)
	{
		if(cur != null)
		{
			Reverse(cur.next);
			if(next != null)
				next.next = cur;	
			else 
				head = cur;
			next = cur;
			cur.next = null;
		}
	}
	//iteration
	public void Reverse1(Node cur)
	{
		if(head != null)
		{
			Node prev = null;
			Node next = cur.next;

			while(cur != null)
			{
				cur.next = prev;
				prev = cur;
				cur = next;
				if(next != null)
					next = next.next;
			}
			head = prev;
			
		}
	}
	public Node getHead()
	{ return head;}
	public void Remove(Node no)
	{
		if(no != null && head != null)
		{
			Node cur = head;	
			Node prev = null;
			while(cur != no)
			{
				prev = cur;
				cur = cur.next;
			}
			if(prev != null && no.next != null)
			{ prev.next = no.next; no.next = null; }
			else if(prev == null && no.next != null)
			{ head = no.next; no.next = null; }
			else if(prev != null && no.next == null)
			{ prev.next = null; }
			else 
			{ no = null; head = null;}
		}	
	}
	public void show()
	{
		Node cur=head;
		while(cur != null)
	 	{ System.out.println("cur.data=" + cur.data); cur=cur.next;}
	}
    public Node getTail()
    {
        Node curr = head;
        while(curr != null && curr.next != null)
        {
            curr = curr.next;
        }
        return curr;
    } 
}

//Merge sort on single linkedlist
public class MergeSortLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Merge Sort linkedlist");
        test1();
        test2();
        test3();
        test4();

    }

    public static void test1()
    {
        System.out.println("Test1()");
        SLL s3 = new SLL();

        s3.append(2);
        s3.append(1);

        show(s3.getHead());
        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test1()=======================");

    }

    public static void test2()
    {
        System.out.println("Test2()");
        SLL s3 = new SLL();

        s3.append(1);
        s3.append(2);
        s3.append(3);

        show(s3.getHead());

        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test2()=======================");
    }


    public static void test3()
    {
        System.out.println("Test3()");
        SLL s3 = new SLL();

        s3.append(6);

        show(s3.getHead());

        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test3()=======================");
    }

    public static void test4()
    {
        System.out.println("Test4()");
        SLL s3 = new SLL();

        s3.append(6);
        s3.append(5);
        s3.append(3);
        s3.append(100);
        s3.append(1);

        show(s3.getHead());

        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test4()=======================");
    }
    public static void show(Node head)
    {
        Node curr = head;
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }
    public static Node getTail(Node head)
    {
        Node curr = head;
        while(curr != null && curr.next != null)
            curr = curr.next;
        return curr;
    }

    public static Node mergeSortLinkedList(Node lo, Node hi)
    {
        if(lo != null && lo != hi)
        {
            Node m = median(lo);
            Node m1 = m.next;
            m.next = null;

            Node left = mergeSortLinkedList(lo, m);
            Node right = mergeSortLinkedList(m1, hi);
            return mergeLinkedList(left, right);
        }
        else
            return lo;
    }

    public static Node median(Node head)
    {
        Node curr = head;
        Node mcurr = curr;
        if(curr != null)
        {
            while(curr.next != null)
            {
                curr = curr.next.next;
                if(curr == null)
                    break;
                mcurr = mcurr.next;
            }
        }
        return mcurr;
    }

    public static Node mergeLinkedList(Node s1, Node s2)
    {
        Node curr1 = s1;
        Node curr2 = s2;
        Node curr = null;
        Node head = curr;
        if(curr1 == curr2)
            head = s1;
        else
        {
            while(curr1 != null || curr2 != null)
            {
                if(curr1 == null)
                {
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else
                    {
                        curr.next = new Node(curr2.data);
                        curr = curr.next;
                    }
                    curr2 = curr2.next;
                }
                else if(curr2 == null)
                {
                    if(curr == null)
                    {
                        head = curr = new Node(curr1.data);
                    }
                    else
                    {
                        curr.next = new Node(curr1.data);
                        curr = curr.next;
                    }
                    curr1 = curr1.next;
                }
                else 
                {
                    if(curr1.data < curr2.data)
                    {
                        if(curr == null)
                            head = curr = new Node(curr1.data);
                        else
                        {
                           curr.next = new Node(curr1.data); 
                           curr = curr.next;
                        }
                        curr1 = curr1.next;
                    }
                    else
                    {
                        if(curr == null)
                            head = curr = new Node(curr2.data);
                        else
                        {
                            curr.next = new Node(curr2.data);
                            curr = curr.next;
                        }
                        curr2 = curr2.next;
                    }
                }
            }
        }
        return head;
    }
}
import java.io.*;
import java.util.*;
class MergeSortedList 
{
	public static void main(String args[])
	{
		int[] Arr1 = new int[10]; 
		Arr1[0] = 5; 
		Arr1[1] = 6; 
		Arr1[2] = 7; 
		Arr1[3] = 8; 
		Arr1[4] = 9; 
		Arr1[5] = 10; 
		int[] Arr2 = {11, 20, 30, 40};
		int[] Arr = Merge(Arr1, Arr2);
		for(int i=0; i< Arr.length; i++)
			System.out.println(Arr[i]);
	}

	public static int[] Merge(int[] Arr1, int[] Arr2)
	{
		int[] ret=null;
		if(Arr1 !=null && Arr2 !=null) 
		{
			int i=Arr1.length-5, j=Arr2.length-1, k=Arr1.length-1;	
			while(j !=-1)
			{
				System.out.println("i=" + i + "  " + "j=" + j);
				if(i == -1)
				{
					Arr1[k] = Arr2[j]; j--;
				}
				else if(Arr1[i] > Arr2[j])
				{
					Arr1[k] = Arr1[i]; i--;
				}
				else 
				{
					Arr1[k] = Arr2[j]; j--;
				}
				k--;
					
			}
		}
		return Arr1;
	}
}
import java.io.*;
import java.util.*;
class MergeSortedListToArray {
    public static void main(String args[]) {
        int[] Arr1 = {1, 9, 12};
        int[] Arr2 = {2, 15};
        int[] Arr3 = {5, 7, 20};
        int[] Arr = Merge(Merge(Arr1, Arr2), Arr3);
        for(int i=0; i< Arr.length; i++)
            System.out.println(Arr[i]);
    }

    public static int[] Merge(int[] Arr1, int[] Arr2) {
        int[] A=null;
        if( Arr1 != null && Arr2 != null) {
            int len1 = Arr1.length;
            int len2 = Arr2.length;
            A = new int[len1+len2];
            int i=0, j=0, c=0;
            while(i<len1 || j<len2) {
                if(i == len1) {
                    A[c]=Arr2[j];
                    j++;
                } else if( j == len2) {
                    A[c]=Arr1[i];
                    i++;
                } else {
                    if(Arr1[i]<Arr2[j]) {
                        A[c] = Arr1[i];
                        i++;
                    } else {
                        A[c] = Arr2[j];
                        j++;
                    }
                }
                c++;
            }
        }
        return A;
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

public class MergeSortedSingleLinkedList{
    public static void main(String[] args) {
        test14();
        test15();
        test16();
        test17();
        test18();
        test19();
    }
    

    static void test14(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);
        s1.append(7);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        s2.append(6);
        s2.append(11);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test15(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test16(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test17(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test18(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }
    static void test19(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(4);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    //[ file=mergesortedsll.html title=""
    static Node mergeSortedList(Node head1, Node head2){
        if(head1 == null)
            return head2;
        if(head2 == null)
            return head1;
        Node curr1 = head1;
        Node curr2 = head2;
        Node curr = null; 
        Node head = null;

        while(curr1 != null || curr2 != null){
            if(curr1 == null){
                if(curr != null)
                    curr.next = new Node(curr2.data);
                else
                    head = curr = new Node(curr2.data);

                curr2 = curr2.next;

            }else if(curr2 == null){
                if(curr != null)
                    curr.next = new Node(curr1.data);
                else
                    head = curr = new Node(curr1.data);

                curr1 = curr1.next;
            }else{
                if(curr1.data < curr2.data){
                    if(curr == null){
                        head = curr = new Node(curr1.data);
                    }else{
                        curr.next = new Node(curr1.data);
                    }

                    curr1 = curr1.next;
                }else{
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else{
                        curr.next = new Node(curr2.data);
                    }

                    curr2 = curr2.next;
                }
            }

            if(curr.next != null)
                curr = curr.next;
        }
        return head;
    }
    //]
}
import classfile.*;

public class MergeThreeSortList 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
    }
    public static void test1()
    {
        int[] arr1 = {1};
        int[] arr2 = {2, 8, 10, 40};
        int[] arr3 = {5};
        int[] arr = mergeThreeList(arr1, arr2, arr3);
        Aron.printArray(arr1);
        Aron.printArray(arr2);
        Aron.printArray(arr3);
        Aron.printArray(arr);
    }

    public static void test2()
    {
        int[] arr1 = {1, 9, 20, 30};
        int[] arr2 = {2, 8, 10, 40};
        int[] arr3 = {5, 18, 21, 29};
        int[] arr = mergeThreeList(arr1, arr2, arr3);
        Aron.printArray(arr1);
        Aron.printArray(arr2);
        Aron.printArray(arr3);
        Aron.printArray(arr);
    }
    public static int[] mergeThreeList(int[] arr1, int[] arr2, int[] arr3)
    {
        int[] arr = null;
        if(arr1 != null && arr2 != null && arr3 != null)
        {
            int len1 = arr1.length;
            int len2 = arr2.length;
            int len3 = arr3.length;
            int inx = 0;
            int inx1=0, inx2=0, inx3=0;
            arr = new int[len1+len2+len3];
            while(inx1 < len1 || inx2 < len2 || inx3 < len3)
            {
                if(inx1 >= len1 && (inx2 < len2 && inx3 < len3))
                {
                    arr[inx] = Math.min(arr2[inx2], arr3[inx3]);
                    if( arr[inx] == arr2[inx2]) inx2++;
                    if( arr[inx] == arr3[inx3]) inx3++;
                }
                else if(inx2 >= len2 && (inx1 < len1 && inx3 < len3))
                {    
                    arr[inx] = Math.min(arr1[inx1], arr3[inx3]);
                    if( arr[inx] == arr1[inx1]) inx1++;
                    if( arr[inx] == arr3[inx3]) inx3++;
                }
                else if(inx3 >= len3 && (inx1 < len1 && inx2 < len2))
                {    
                    arr[inx] = Math.min(arr1[inx1], arr2[inx2]);
                    if( arr[inx] == arr1[inx1]) inx1++;
                    if( arr[inx] == arr2[inx2]) inx2++;
                }
                else if(inx1 >= len1 && inx2 >= len2 && inx3 < len3)
                {
                    arr[inx] = arr3[inx3]; inx3++;
                }
                else if(inx2 >= len2 && inx3 >= len3 && inx1 < len1)
                {
                    arr[inx] = arr1[inx1]; inx1++;
                }
                else if(inx1 >= len1 && inx3 >= len3 && inx2 < len2)
                {
                    arr[inx] = arr2[inx2]; inx2++;
                }
                else
                {
                    arr[inx] = Math.min(Math.min(arr1[inx1], arr2[inx2]), arr3[inx3]);
                    if( arr[inx] == arr1[inx1]) inx1++;
                    if( arr[inx] == arr2[inx2]) inx2++;
                    if( arr[inx] == arr3[inx3]) inx3++;
                }
                inx++;
            }
        }
        return arr;
    }
}
public class Min 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] str = {4};  
        int m  = min(str);
        System.out.println("m="+m);
    }
    public static int min(int[] array)
    {
        int min = Integer.MAX_VALUE;
        if(array != null)
        {
            int len = array.length;
            if(len > 0)
            {
                min = array[0];
                for(int i = 1; i<len; i++)
                {
                    if(min > array[i])
                        min = array[i];
                }
            }
        }
        return min;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class MinSumNum {
    public static void main(String[] args) {
        test0();
        test1();
        test11();
        test12();
//        test2();
//        test3();
//        test4();
        //test5();
        //test6();
    }

    public static int minSquareTermDY(int n, Map<Integer, Integer> map, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(n == 0) {
//            for(Integer e : list) {
//                System.out.print("[" + e + "]");
//            }
//            System.out.println();
            return 0;
        } else if(n > 0) {
            int inx =(int)Math.sqrt(n) + 1;
            for(int i=1; i<= inx; i++) {

                list.add(i);
                Integer value = map.get(n-i*i);
                Integer m = value;
                if(value == null){
                    m = minSquareTermDY(n-(i*i), map, list);
                    if(m < Integer.MAX_VALUE)
                        m += 1;
                }
                min = Math.min(min, m);
                System.out.println("n-i*i=[" + (n-i*i) + "] min[" + min + "]"); 
                
                if(n - i*i < 0)
                    map.put(n-i*i, Integer.MAX_VALUE);
                else
                    map.put(n-i*i, min);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }
        } 
        return min;
    }
    public static int minSquareTerm(int n, Map<Integer, Integer> map, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(n == 0) {
//            for(Integer e : list) {
//                System.out.print("[" + e + "]");
//            }
//            System.out.println();
            return 0;
        } else if(n > 0) {
            int inx =(int)Math.sqrt(n) + 1;
            for(int i=1; i<= inx; i++) {

                list.add(i);
                int m = minSquareTerm(n-(i*i), map, list);
                if(m < Integer.MAX_VALUE)
                    m += 1;

                min = Math.min(min, m);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }
        } 
        return min;
    }

    public static int minCoin(int s, Integer[] arr, Map<Integer, Integer> map) {
        int min = Integer.MAX_VALUE;
        if(s == 0)
            return 0;
        else if(s > 0) {
            if(arr != null) {
                for(Integer n : arr) {
                    Integer value = map.get(s-n);
                    Integer m = 0;
                    if(value == null){
                        m = minCoin(s-n, arr, map);
                        if(m < Integer.MAX_VALUE)
                            m += 1;
                    }else{
                       m = value;
                    }

                    min = Math.min(min, m);

                    map.put(s-n, min);
                }
            }
        }
        return min;
    }

    static void test0() {
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTerm(4, map, list);
        System.out.println("min=[" + min + "]");
        Aron.end();
    }
    static void test1() {
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTerm(10, map, list);
        System.out.println("min=[" + min + "]");
        Aron.end();
    }
    static void test11() {
        Aron.beg();
        StopWatch sw = new StopWatch();
        sw.start();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTerm(50, map, list);
        //System.out.println("min=[" + min + "]");

        sw.printTime(); 

        Aron.end();
    }

    static void test12() {
        Aron.beg();
        StopWatch sw = new StopWatch();
        sw.start();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTermDY(50, map, list);
        //System.out.println("min=[" + min + "]");

        sw.printTime(); 

        Aron.end();
    }
    static void test2() {
        Aron.beg();
        Integer[] arr = {1, 2}; 
        int s = 3;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }

    static void test3() {
        Aron.beg();
        Integer[] arr = {1}; 
        int s = 3;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }

    static void test4() {
        Aron.beg();
        Integer[] arr = {3}; 
        int s = 3;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }

    static void test5() {
        Aron.beg();
        Integer[] arr = {2, 5}; 
        int s = 10;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }
    static void test6() {
        Aron.beg();
        Integer[] arr = {2, 5, 100}; 
        int s = 100;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }
}
public class MiniDiffSortedArray 
{
    public static void main(String[] args)
    {
        System.out.println("MiniDiffSortedArray");
        test1();
    }
    public static void test1()
    {
        int[] arr1 = {2, 4, 9, 20};
        int[] arr2 = {1, 14, 16, 80};
        int min = miniDiff(arr1, arr2);
        System.out.println("min=["+min+"]");
    }

    public static int miniDiff(int[] arr1, int[] arr2)
    {
        int diff = Integer.MAX_VALUE;
        if(arr1 != null && arr2 != null)
        {
            int inx1 = 0;
            int inx2 = 0;
            while(inx1 < arr1.length && inx2 < arr2.length)
            {
                diff = Math.min(diff, Math.abs(arr1[inx1] - arr2[inx2]));
                int min = Math.min(arr1[inx1], arr2[inx2]); 
                if(min == arr1[inx1]) inx1++;
                if(min == arr2[inx2]) inx2++;
            }
        }
        return diff;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

// Find the minimum distance between two given words
public class MinimumDistanceWord{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    static void test0(){
        Aron.beg();
        String[] arr = {"a", "b", "c", "b", "a", "e"}; 
        String word1 = "a";
        String word2 = "b";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 1);

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        String[] arr = {"a", "b", "c", "e"}; 
        String word1 = "a";
        String word2 = "e";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 3);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        String[] arr = {"a", "b", "a", "e"}; 
        String word1 = "e";
        String word2 = "a";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 1);

        Aron.end();
    }
    static void test3(){
        Aron.beg();
        String[] arr = {"a", "b", "a", "e"}; 
        String word1 = "a";
        String word2 = "e";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 1);

        Aron.end();
    }
    static void test4(){
        Aron.beg();
        String[] arr = {"a", "b", "a", "e"}; 
        String word1 = "a";
        String word2 = "a";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 0);

        Aron.end();
    }
    //[ file=minidistanceword.html title=""
    static int minimumDistance(String[] wordArray, String word1, String word2){
        int minDistance = Integer.MAX_VALUE;
        if(word1 != null && word2 != null){
            int index1 = -1;
            int index2 = -1;
            for(int i=0; i<wordArray.length; i++){
                if(word1.equals(wordArray[i]))
                    index1 = i; 
                
                if(word2.equals(wordArray[i]))
                    index2 = i;

                if(index1 != -1 && index2 != -1){
                    int dist = Math.abs(index1 - index2);
                    minDistance = Math.min(dist, minDistance);
                }
            }
        }
        return minDistance;
    }
    //]
} 
public class ModifyBinSearch 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] array = {1, 2, 10, 4};
        int left = 0; int right = array.length-1;
        int max = max2(array, left, right);
        System.out.println("max="+max);
    }
    public static int max2(int[] array, int left, int right)
    {
        if(array != null)
        {
            int mid = (left + right)/2;
            if(mid < right)
            {
                if(array[mid] < array[mid + 1])
                {
                    return max2(array, mid+1, right);
                }
                else
                    return max2(array, left, mid);
            }
            else
                return array[mid];
        }
        return -1000;
    }
    public static int max(int[] array, int left, int right)
    {
        if(array != null)
        {
            if(array.length == 0)
            {
                return -1000;
            }
            else if(array.length == 1)
            {
                return array[0]; 
            }
            else //two or more elements 
            {
                int mid = (left + right)/2;
                if(right - left > 1)
                {
                    if(array[mid-1] < array[mid])
                        return max(array, mid, right);
                    else
                        return max(array, left, mid-1);
                }
                else
                {
                    return array[left] < array[right]? array[right]:array[left];
                }
            }
        }
        return -1000;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*; 

class MultiplyArrayInteger {
    public static void main(String args[]) {
        test00();
        test0();
        test1();
    }

    //[ file=multiply.html title=""
    /**
    * Multiple all the integers except the current one
    * No Division is allowed
    * Runtime is O(n)
    * [2, 3, 4] => [3*4, 2*4, 2*3] => [12, 8, 6]
    */ 
    public static int[] multiple(int[] arr){
        if (arr == null){
            throw new IllegalArgumentException("arr must not be null.");
        }else{
            int len = arr.length;
            int[] arr1 = new int[len];
            int[] arr2 = new int[len];
            if(len > 1){
                arr1[0] = arr2[len-1] = 1;
                for(int i=1; i<len; i++){
                    arr1[i] = arr[i-1]*arr1[i-1];
                    arr2[len-1 - i] = arr[len-i]*arr2[len-i];
                }
                for(int i=0; i<len; i++)
                arr1[i] = arr1[i]*arr2[i];
            }
            return arr1;
        }
    } 
    //]
    public static void test00() {
        Aron.beg();
        int[] arr1 = {2}; 
        int[] arr = multiple(arr1);
        Aron.printArray(arr);

        Aron.end();
    }

    public static void test0() {
        Aron.beg();
        int[] arr1 = {2, 3}; 
        int[] arr = multiple(arr1);
        Aron.printArray(arr);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        int[] arr1 = {2, 3, 4}; 
        int[] arr = multiple(arr1);
        Aron.printArray(arr);
        Aron.end();
    }

}
public class MultiplyBlockMatrix
{
    public static void main(String[] args)
    {
        System.out.println("Multiply Block Matrix!");
    }
    public static int[][] multiply(int[][] A, int col_lo_a, int col_hi_a, 
                                              int row_lo_a, int row_hi_a,
                                    int[][] B,int col_lo_b, int col_hi_b,
                                              int row_lo_b, int row_hi_b)
    {
        int[][] C = null;
        int col_mid_a = (col_lo_a + col_hi_a)/2;
        int row_mid_a = (row_lo_a + row_hi_a)/2;
        int col_mid_b = (col_lo_b + col_hi_b)/2;
        int row_mid_b = (row_lo_b + row_hi_b)/2;

        int[][] a11 = multiply(A, B, col_lo_a, col_mid_a, row_lo_a, row_mid_a,
                                     col_lo_b, col_mid_b, row_lo_b, row_mid_b);

        int[][] a12 = multiply(A, B, col_mid_a, col_hi_a, row_lo_a, row_mid_a, 
                                     col_mid_b, col_hi_b, row_lo_b, row_mid_b);
        int[][] a21 = multiply(A, B, col_lo_a,  col_mid_a,row_mid_a,row_hi_a,
                                     col_lo_b,  col_mid_b,row_mid_b,row_hi_b);
        int[][] a22 = multiply(A, B, col_mid_a, col_hi_a, row_mid_a,row_hi_a,
                                     col_mid_b, col_hi_b, row_mid_b,row_hi_b);
        return C;
    }
}
import java.io.*;
import classfile.*;

class MultiplyLongInt
{
	public static void main(String args[])
	{
        test1();
        test2();
        test3();
        test4();
        test5();
        test1_multiplynew();
        test2_multiplynew();
        test3_multiplynew();

	}
    //[file=multiplynew.html title=""     
    public static int[] multiplynew(int[] arr1, int[] arr2){
        int len1 = arr1.length;
        int len2 = arr2.length;
        int len = len1 + len2;
        int[][] arr = new int[len1][len1+len2];

        for(int i=len2-1; i >= 0; i--){
            int carry = 0;
            int j=0;
            for(j=len1-1; j >= 0; j--){
                int shiftLeft = i + 1;
                arr[i][j + shiftLeft] = (arr1[j]*arr2[i] + carry) %10;
                carry = (arr1[j]*arr2[i]+carry) / 10;
            }
            arr[i][(i+1)+j] = carry;
        }

        int[] total = new int[len];
        int carry = 0;
        for(int j=len-1; j >= 0; j--){
            int s=0;
            for(int i=0; i < len2; i++){
                s += arr[i][j];
            }
            total[j] = (s + carry) % 10;
            carry = (s + carry)/10;
        }
        return total;
    }
    //]

    //[file=multiplylong.html title="multiply long integer"
    public static int[] multiply(int[] arr1, int[] arr2) {
        if(arr1 != null && arr2 != null && arr1.length > 0 && arr2.length > 0) {
            int len1 = arr1.length;
            int len2 = arr2.length;
            Reverse(arr1);        
            Reverse(arr2);
            int[][] array = new int[len1][len1+len2];

            for(int i=0; i<len1; i++) {
                int carrying = 0;
                int j=0;
                for(j=0; j<len2; j++) {
                    int t = arr1[i]*arr2[j] + carrying;
                    array[i][j + i] = t % 10;
                    carrying = t / 10;
                }
                array[i][j + i] = carrying;
            }

            int[] total = new int[len1+len2];
            int carrying = 0;
            for(int i=0; i<len1 + len2; i++) {
                int s = 0;
                for(int j=0; j < len1; j++) {
                    s += array[j][i];
                }
                total[i] = (s + carrying) % 10; 
                carrying = (s + carrying) / 10;
            }
            Reverse(total);
            return total;
        }
        return null;
    }

    public static void Reverse(int[] A) {
        if(A != null) {
            int len = A.length;
            for(int i=0; i<len/2; i++) {
                int tmp = A[i];
                A[i] = A[len-1-i];
                A[len-1-i] = tmp;
            }
        }
    }
    //]
    

    static void test1(){
        Aron.beg();
		int[] A = {9, 9, 9};
		int[] B = {9, 0, 9};
		int[] S = multiply(A, B);
        Aron.printArray(S);
        Aron.end();
    }
    static void test2(){
        Aron.beg();
		int[] A = {9, 9, 9};
		int[] B = {9, 9, 9};
		int[] S = multiply(A, B);
        Aron.printArray(S);

        Aron.end();
    }
    static void test3(){
        Aron.beg();
		int[] A = {9};
		int[] B = {9, 9, 9};
		int[] S = multiply(A, B);
        Aron.printArray(S);

        Aron.end();
    } 

    static void test4(){
        Aron.beg();
		int[] A = {9};
		int[] B = {1};
		int[] S = multiply(A, B);
        Aron.printArray(S);

        Aron.end();
    } 

    static void test5(){
        Aron.beg();
		int[] A = {9, 9};
		int[] B = {9};
		int[] S = multiply(A, B);
        Aron.printArray(S);
        Aron.end();
    } 

    static void test1_multiplynew(){
        Aron.beg();
        int[] A = {9, 9};
		int[] B = {9};
		int[] S = multiplynew(A, B);
        Aron.printArray(S);

        Aron.end();
    }

    static void test2_multiplynew(){
        Aron.beg();
		int[] A = {1};
		int[] B = {9};
	    int[] S = multiplynew(A, B);
        Aron.printArray(S);

        Aron.end();
    }

    static void test3_multiplynew(){
        Aron.beg();
		int[] A = {0};
		int[] B = {0};
	    int[] S = multiplynew(A, B);
        Aron.printArray(S);
        Print.p(0*0);

        Aron.end();
    }
    static void test4_multiplynew(){
        Aron.beg();
		int[] A = {9};
		int[] B = {9};
		int[] S = multiplynew(A, B);
        Aron.printArray(S);

        Aron.end();
    }
}
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

class Node
{
    int coeff;
    int power;
    String data;
    Node next;
    public Node(int coeff, int power, String data)
    {
        this.coeff = coeff;
        this.power = power;
        this.data = data;
        this.next = null;
    }
}

class SLinkedList
{
    Node head;
    public SLinkedList()
    {
        this.head = null;
    }
    public void add(Node node)
    {
        if(this.head == null)
        {
            this.head = node;
        }
        else
        {
            Node curr = this.head;
            while(curr.next != null)
            {
                curr = curr.next;
            }
            curr.next = node; 
        }
    }
    public void show()
    {
        Node curr = this.head;
        while(curr != null)
        {
            System.out.println("["+curr.coeff+"]["+curr.power+"]");
            curr = curr.next;
        }
    }
}

public class MultiplyPolynomial 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        SLinkedList poly1 = new SLinkedList();
        SLinkedList poly2 = new SLinkedList();
        poly1.add(new Node(1, 2, "x"));
        poly1.add(new Node(2, 3, "x"));
        poly2.add(new Node(4, 5, "x"));
        poly2.add(new Node(6, 7, "x"));
        poly1.show();
        System.out.println("================");
        poly2.show();
        System.out.println("================");
        multiply(poly1, poly2);
        System.out.println("================");
        add(poly1, poly2);
        System.out.println("================");
        TestPolyArray();
    }
    public static void TestPolyArray()
    {
        int[] p1 = {1, 2, 3};
        int[] p2 = {2, 0, 4, 5};
        int[] p = MultiplePolyArray(p1, p2);

        for(int i=0; i<p1.length; i++)
            System.out.print("p1["+p1[i]+"]");
        System.out.println();

        for(int i=0; i<p2.length; i++)
            System.out.print("p2["+p2[i]+"]");
        System.out.println();

        for(int i=0; i<p.length; i++)
            System.out.print("["+p[i]+"]");

        System.out.println();
    }
    public static SLinkedList add(SLinkedList poly1, SLinkedList poly2)
    {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        SLinkedList poly = new SLinkedList();
        if(poly1 != null && poly2 != null && poly1.head != null && poly2.head != null)
        {
            Node curr1 = poly1.head; 
            while(curr1 != null)
            {
                Integer coeff = (Integer)map.get(curr1.power);
                if(coeff != null)
                {
                    map.put(new Integer(curr1.coeff + coeff), new Integer(curr1.power));  
                }
                else
                {
                    map.put(new Integer(curr1.coeff), new Integer(curr1.power));
                }
                curr1 = curr1.next;
            }

            Node curr2 = poly2.head; 
            while(curr2 != null)
            {
                Integer coeff = (Integer)map.get(curr2.power);
                if(coeff != null)
                {
                    map.put(new Integer(curr2.coeff + coeff), new Integer(curr2.power));  
                }
                else
                {
                    map.put(new Integer(curr2.coeff), new Integer(curr2.power));
                }
                curr2 = curr2.next;
            }
            Set<Map.Entry<Integer, Integer>> set = map.entrySet();
            for(Map.Entry<Integer, Integer> entry : set)
            {
                Integer coeff = entry.getKey();
                Integer power = entry.getValue();
                poly.add(new Node(coeff, power, "x"));
            }
            poly.show();
        }
        return poly;
    }
    public static SLinkedList multiply(SLinkedList poly1, SLinkedList poly2)
    {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        SLinkedList poly = new SLinkedList();
        if(poly1 != null && poly2 != null && poly1.head != null && poly2.head != null)
        {
            Node curr1 = poly1.head; 
            Node curr2 = poly2.head;
            while(curr1 != null)
            {
                curr2 = poly2.head;
                while(curr2 != null)
                {
                    Node node = new Node(curr2.coeff*curr1.coeff, curr2.power+curr1.power, "x"); 
                    Integer coeff = (Integer)map.get(new Integer(node.power));
                    if(coeff != null)
                    {
                        map.put(new Integer(node.coeff + coeff), new Integer(node.power));  
                    }
                    else
                    {
                        map.put(new Integer(node.coeff), new Integer(node.power));
                    }
                    curr2 = curr2.next;
                }
                curr1 = curr1.next;
            }
        }
        Set<Map.Entry<Integer, Integer>> set = map.entrySet();
        for(Map.Entry<Integer, Integer> entry : set)
        {
            Integer coeff = entry.getKey();
            Integer power = entry.getValue();
            poly.add(new Node(coeff, power, "x"));
        }
        poly.show();
        return poly;
    }

    public static int[] MultiplePolyArray(int[] p1, int[] p2)
    {
        if(p1 != null && p2 != null)
        {
            int len1 = p1.length;
            int len2 = p2.length;
            if(len1 > 0 && len2 > 0)
            {
                int[][] p = new int[len1][len1+len2];
                for(int i=0; i<len1; i++)
                {
                   for(int j=0; j<len2; j++)
                   {
                       p[i][j+i] = p1[i]*p2[j];
                   } 
                }

                for(int j=0; j<len1+len2; j++)
                {
                    int s=0;
                    for(int i=0; i<len1; i++)
                    {
                        s += p[i][j];
                        if(i == len1-1)
                            p[i][j] = s;
                    }
                }
                return p[len1-1];
            }
        }
        return null;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;

public class MyDict{
    public static void main(String[] args) {
        //test0();
        Print.pbl("len=" + args.length);
        if(args.length > 0){
            Print.pbl("args[0]=" + args[0]);
            find(args[0]);
        }
        //test1();
    }
    public static void test0(){
        Aron.beg();
        String file = "/Users/cat/myfile/github/java/text/mydict.txt";
        List<ArrayList<String>> list2d = Aron.readFileSaperater(file);
        Aron.printList2dArr(list2d);

        Aron.end();
    }

    public static void find(String word){
        String pattern = "\\w+";
        Pattern r = Pattern.compile(word, Pattern.CASE_INSENSITIVE);

        String file = "/Users/cat/myfile/github/java/text/mydict.txt";
        List<ArrayList<String>> list2d = Aron.readFileSaperater(file);
        for(ArrayList<String> list : list2d){
            String[] arr = list.get(0).split("\\s+");

            Matcher mat = r.matcher(arr[0]);
            if(mat.find()){
                Print.pbl("w=" + arr[0] + " " + list);
            }
        }
        //Aron.printList2dArr(list2d);
    } 
    public static void test1(){
        Aron.beg();
        find("abacus");
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

class GNode{
    int data;
    GNode next;
}

class Graph{
    private Map<GNode, GNode> map = new HashMap<GNode, GNode>();
    private Set<GNode> set = new HashSet<GNode>();
    public Graph(){
    }
    public void addNode(GNode node){
        set.add(node);
    }
    public void deleteNode(GNode node){
        set.remove(node);
        GNode curr = map.get(node);
        if(curr != null){
           map.put(curr, null);
        }
    }
    public void addEdge(GNode fromNode, GNode toNode){
        GNode curr = map.get(fromNode);        
        if(curr != null){
            while(curr.next != null ){
                curr = curr.next;
            }
            curr.next = toNode;
        }
    }

    public void removeEdge(){
    }

    public List<GNode> adjacentNode(GNode node){
        List<GNode> list = new ArrayList<GNode>(); 
        GNode curr = map.get(node);

        while(curr != null){
            list.add(curr);
            curr = curr.next;
        }
        return list; 
    }
}

public class MyGraph{
    public static void main(String[] args) {
    }
    static void test0(){
        Aron.beg();
        Aron.end();
    }
} 
import java.util.*;
import java.io.*;
import classfile.*;

//[ file=hashmap1.html title=""
class Entry{
    public String key;
    public Object value;
    public Entry next;
    public Entry(String key, Object value){
        this.key = key;
        this.value = value;
    }
}

class Hash{
    public Entry[] arr;
    public int max;
    public int count = 0;
    public Hash(int max){
        this.max = max;
        arr = new Entry[max];
    }

    public Node get(String key){
        int hash = key.hashCode() % max;
        return (Node)arr[hash].value;
    }
    public void delete(String key){
        if(key != null){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr != null){
                Entry prev = null;
                while(curr != null){
                    if(curr.key == key)
                        break;
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                if(prev == null){
                    arr[hash] = curr.next;
                    count--;
                }else{
                    if(curr != null){
                        prev.next = curr.next;
                        count--;
                    }
                }
            }
        }
    }
    public void put(String key, Node node){
        if(count < max){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr == null){
                arr[hash] = new Entry(key, node);
                count++;
            }
            else{
                Entry prev = null;
                while(curr != null){
                    if(curr.key.equals(key)){
                        // Replace with new value
                        curr.value = node;
                        break;
                    }
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                // No key is found
                if(curr == null){
                    prev.next = new Entry(key, node);
                    count++;
                }
            }
        }
        
    }
}
//]


public class MyHash{
    public static void main(String[] args) {
        test00_hash();
        test01_hash();
        test02_hash();
        test03_hash();
        test04_hash();
        test05_hash();
        test06_hash();
        test07_hash();
        test08_hash();
        test09_hash();
        test010_hash();
        test011_hash();
        test012_hash();
    }
    
        
    static void test00_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        Node node = (Node)hash.get("a");

        Test.f(node, null);
        Test.f(node, new Node(3));
        Test.t(node, new Node(1));

        Aron.end();
    }
    static void test01_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("a", new Node(2));
        Node node = (Node)hash.get("a");
        Test.t(node, new Node(2));

        Aron.end();
    }
    static void test02_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test03_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        hash.put("e", new Node(5));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test04_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.delete("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
        }

        Aron.end();
    }
    static void test05_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.delete("a");
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test06_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test07_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 1);

        Aron.end();
    }
    static void test08_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 0);

        Aron.end();
    }
    static void test09_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        Test.t(hash.count, 2);

        Aron.end();
    }
    static void test010_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        Test.t(hash.count, 1);

        Aron.end();
    }
    static void test011_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
    static void test012_hash(){
        Aron.beg();
        Hash hash = new Hash(3);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
}
class MyNode
{
	public MyNode left;
	public MyNode right;
	public int data;
	public MyNode(int n)
	{ data = n; left = null; right = null; }
	public MyNode left()
	{ return left; }
	public MyNode right()
	{ return right; }
	public void setLeft(MyNode l)
	{ left = l;}
	public void setRight(MyNode r)
	{ right = r;}

    public MyNode prev()
	{ return left;}
    public MyNode next()
    { return right;}

    public void setPrev(MyNode p){
        left = p;
    }
    public void setNext(MyNode n){
        right = n;
    }
    public int data(){
        return data;
    }
}


import java.util.*;
import java.io.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import classfile.*;

enum Type{
    MOTORCYCLE,
    COMPACT,
    BUS,
}

class Ticket{
    int id;
    double price;
    
    LocalDateTime startTime;
    LocalDateTime endTime;
    public Ticket(int id, int price,  LocalDateTime startTime, LocalDateTime endTime){
        this.id = id;
        this.price = price;
        this.startTime = startTime;
        this.endTime = endTime;
    }
}

class Parking{
    public Vehicle vehicle;
    public Parking(Vehicle v){
        vehicle = v;
    }
}

interface Vehicle{
    public Type getType();
}

class Motorcycle implements Vehicle{
    public Type type;
    public Motorcycle(Type type){
        this.type = type;
    }
    public Type getType(){
        return type;
    }
}

class Compact implements Vehicle{
    public Type type;
    public Compact(Type type){
        this.type = type;
    }
    public Type getType(){
        return type;
    }
}

class Bus implements Vehicle{
    public Type type;
    public Bus(Type type){
        this.type = type;
    }
    public Type getType(){
        return type;
    }
}

class ParkingLot{
    double total;
    Map<Ticket, Parking>  parkMap = new HashMap<Ticket, Parking>();
    int compactMax;
    int compactCount;
    int motorcycleMax;
    int motocycleCount;
    int busMax;
    int busCount;

    public ParkingLot(int cm, int mm, int bm){
        total = 0;
        compactMax = cm;
        motorcycleMax = mm;
        busMax = bm;
    }

    public int getTicket(LocalDateTime st, LocalDateTime et){
        int count = 0;
        for(Map.Entry<Ticket, Parking> entry : parkMap.entrySet()){
            count++;
        }
        return count;
    }

    public double ticketPrice(){
        return 1;
    }
    public void add(Ticket t, Parking p){
        if(!isFull()){
            if(p.vehicle.getType() == Type.COMPACT && compactCount < compactMax)
                compactCount++;
            else if(p.vehicle.getType() == Type.MOTORCYCLE && motocycleCount < motorcycleMax)
                motocycleCount++;
            else if(p.vehicle.getType() == Type.BUS && busCount < busMax)
                busCount++;

            parkMap.put(t, p);
        }
    }
    public void remove(Ticket t){
        Parking p = parkMap.get(t);
        if(p != null){
            if(p.vehicle.getType() == Type.COMPACT)
                compactCount--;

            if(p.vehicle.getType() == Type.MOTORCYCLE)
                motocycleCount--;

            if(p.vehicle.getType() == Type.BUS)
                busCount--;
            
            parkMap.remove(t);

            t.endTime = LocalDateTime.now();
            parkMap.put(t, p);
        }
    }
    public boolean isFullCompact(){
        return compactCount < compactMax;
    }
    public boolean isFullMotorcycle(){
        return motocycleCount < motorcycleMax;
    }
    public boolean isFullBus(){
        return busCount < busMax;
    }
    public boolean isFull(){
        return (compactCount + motocycleCount + busCount) < (compactMax + motorcycleMax + busMax) ? false : true;
    }
}


public class MyParking{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();

        ParkingLot pl = new ParkingLot(4, 5, 6);
        LocalDateTime time1 = LocalDateTime.parse("2007-12-03T10:15:30", DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        Ticket t1 = new Ticket(1, 100, time1, null);
        Parking park1 = new Parking(new Compact(Type.COMPACT));
        pl.add(t1, park1);
        System.out.println("compactCount[" + pl.compactCount + "]"); 
        System.out.println("motocycleCount[" + pl.motocycleCount+ "]"); 
        System.out.println("busCount[" + pl.busCount+ "]"); 
        
        pl.remove(t1);
        
        System.out.println("\n---------------------------------"); 

        System.out.println("compactCount[" + pl.compactCount + "]"); 
        System.out.println("motocycleCount[" + pl.motocycleCount+ "]"); 
        System.out.println("busCount[" + pl.busCount+ "]"); 

        Aron.end();
    }
} 
interface Shape
{
    public double getArea();
}

class Circle implements Shape
{
    double x;
    double y;
    double radial;
    public Circle(double x, double y, double radial)
    {
        this.x = x;
        this.y = y;
        this.radial = radial;
    }
    public double getArea()
    {
        return 3.14*radial*radial;
    }
}

class Rectangle implements Shape
{
    double topx;
    double topy;
    double bottomx;
    double bottomy;
    public Rectangle(double topx, double topy, double bottomx, double bottomy)
    {
        this.topx = topx;
        this.topy = topy;
        this.bottomx= bottomx;
        this.bottomy= bottomy;
    }
    public double getArea()
    {
        return Math.abs(bottomx - topx)*Math.abs(bottomy - topy);
    }
}


public class MyShape 
{
    public static void main(String[] args)
    {
        Shape s1 = new Circle(3.0, 4.0, 5.0); 
        Shape s2 = new Rectangle(3.0, 4.0, 5.0, 6.0); 
        System.out.println("s1=" + s1.getArea());
        System.out.println("s2=" + s2.getArea());
    }
}
import classfile.*;

class StopWatch {
    private long startTime = 0;
    private long stopTime = 0;
    private boolean running = false;

    public void StopWatch(){
        this.startTime = System.currentTimeMillis();
        this.running = true;
    }
    

    public void start() {
        this.startTime = System.currentTimeMillis();
        this.running = true;
    }

    public void stop() {
        this.stopTime = System.currentTimeMillis();
        this.running = false;
        long elapsed = ((System.currentTimeMillis() - startTime) / 1000000);
        Print.pbl(elapsed);
        Print.pbl("startTime=" + startTime);
        Print.pbl("stopTime=" + stopTime);
        Print.pbl("diff=" + (startTime - stopTime));
    }

    //elaspsed time in milliseconds
    public long getElapsedTime() {
        long elapsed;
        if (running) {
            elapsed = (System.currentTimeMillis() - startTime);
        } else {
            elapsed = (stopTime - startTime);
        }
        return elapsed;
    }

    public void diff() {
        Print.pbl(getElapsedTime());
    }

    //elaspsed time in seconds
    public long getElapsedTimeSecs() {
        long elapsed;
        if (running) {
            elapsed = ((System.currentTimeMillis() - startTime) / 1000);
        } else {
            elapsed = ((stopTime - startTime) / 1000);
        }
        return elapsed;
    }
}

public class MyStopWatch {
    public static void main(String[] args) {
        StopWatch sw = new StopWatch();
        for(int i=0; i < 100; i++)
            System.out.println(i);
        sw.stop();
    }
}

import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class TNode {
    boolean isWord;
    TNode[] array = new TNode[26];
}

class Tries {
    TNode root;
    public Tries() {
        root = new TNode();
        root.isWord = true;
    }
    public int map(char ch) {
        return (int)ch - 'a';
    }

    //[ file=newtries.html title=""
    public  void add(TNode r, int[] arr, int k) {
        if( k < arr.length) {
            if(r.array[arr[k]] == null)
                r.array[arr[k]] = new TNode();

            add(r.array[arr[k]], arr, k+1);
        }else if(k == arr.length){
            r.isWord = true;
        }
    }

    public  boolean contains(TNode r, int[] arr, int k) {
        if(r != null){
            if(k < arr.length) {
                return contains(r.array[arr[k]], arr, k+1);
            }else if (k == arr.length){
                return r.isWord;
            }
        }
        return false;
    }
    public  void addWord(TNode r,  String word, int k) {
        if( k < word.length()) {
            if(r.array[map(word.charAt(k))] == null)
                r.array[map(word.charAt(k))] = new TNode();

            addWord(r.array[map(word.charAt(k))], word, k+1);
        }else{
            r.isWord = true;
        }
    }
    public  boolean containsWord(TNode r, String word, int k) {
          if(r != null){
              if(k == word.length())
                  return r.isWord;
              else if(k < word.length()){
                  return containsWord(r.array[map(word.charAt(k))], word, k+1);
              }
          }
          return false;
    }
    //]
}

class MyTries {
    public static void main(String args[]) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();

        test11();
        test12();
        test13();
        test14();
        test15();
    }
    
    public static void test0() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test1() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test2() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0, 0, 1};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0, 0, 1};
        int[] arr1 = {0, 0};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test4() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0};
        int[] arr1 = {0,0};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test5() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr1 = {0,0,0};
        int[] arr3 = {0};
        add(t.root, arr1, k);
        add(t.root, arr3, k);

        int[] arr2 = {0,0};
        System.out.println("[" + (t.contains(t.root, arr1, h) == true)+ "]"); 
        System.out.println("[" + (t.contains(t.root, arr2, h) == false)+ "]"); 
        System.out.println("[" + (t.contains(t.root, arr3, h) == true)+ "]"); 

        Aron.end();
    }
    // 'a'-> 0
    // 'b'-> 1
    // 'z'-> 25
    public static int map(char ch) {
        return (int)ch - 'a';
    }
    public static void add(TNode r, int[] arr, int k) {
        if( k < arr.length) {
            if(r.array[arr[k]] == null)
                r.array[arr[k]] = new TNode();
            add(r.array[arr[k]], arr, k+1);
        }else{
            r.isWord = true;
        }
    }

    public static void test11() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "abc";
        t.addWord(t.root, word, k);
        System.out.println("[" + (t.containsWord(t.root, word, h) == true ) + "]"); 
        Aron.end();
    }
    public static void test12() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "abc";
        t.addWord(t.root, word, k);
        String word1 = "ab";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == false) + "]"); 
        Aron.end();
    }
    public static void test13() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "a";
        t.addWord(t.root, word, k);
        String word1 = "a";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == true) + "]"); 

        Aron.end();
    }
    public static void test14() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "a";
        t.addWord(t.root, word, k);
        String word1 = "aa";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == false) + "]"); 

        Aron.end();
    }
    public static void test15() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "a";
        t.addWord(t.root, word, k);
        String word1 = "";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == true) + "]"); 

        Aron.end();
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

class MyNode{
    String data;
    int count;
    public MyNode(String data, int count){
        this.data = data;
        this.count = count;
    }
}

class TextMap{

    public TextMap(){
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }
}

public class AnimalLogic{
    public static void main(String[] args) {
//        test0();
//        test1();
        //test2();
//        test3();
//        test4();
//        test5();
//        test00();
//        test11();
//        test12();
        test13();
    }

    static void test00(){
        Aron.beg();
        
        int n = random(1);
        Print.pbl("n=" + n);

        for(int i=0; i<10; i++){
            int n1 = random(2);
            Print.pbl("n1=" + n1);
        }

        Aron.end();
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public static void test12(){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }

    public static void test13(){
        Aron.beg();

        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        Map<Map<String, String>, Map<Integer, String>> revMap = createBiMap(map);

        String seedFirst = "one";
        String seedSecond = "two";
        int numWords = 10;
        List<String> wordList = generateText(numWords, seedFirst, seedSecond, map, revMap);
        Aron.printList(wordList);
    }

    public static List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }

//    public static Map<String, String> newKeyMap(Map<String, String> map, String newWord){
//        map.get
//    }

    public static Map<Map<String, String>, Map<Integer, String>> createBiMap(Map<Map<String, String>, Map<String, Integer>> map){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 
        return revMap;
    }

    public static void test11(){
        Aron.beg();
        String[] arr = {"dog", 
                        "cat", 
                        "cow", 
                        "dog", 
                        "cat", 
                        "cow", 
                        "rat", 
                        "pig"}; 

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();

        List<String> list = getWords("./text/animal_logic.txt"); 
        //Map<Map<String, String>, Map<String, Integer>> map = createMap(arr); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }


    public static Map<Map<String, String>, Map<String, Integer>> createMap(List<String> list){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        for(int i=0; i<list.size() - 2; i++){
            Map<String, String> key = new HashMap<String, String>(); 
            Map<String, Integer> value = new HashMap<String, Integer>(); 
            key.put(list.get(i), list.get(i+1)); 
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key); 
            if(v == null){
                map.put(key, value);
            }else{
                Integer n = v.get(list.get(i+2));
                if(n == null){
                    v.put(list.get(i+2), 1);
                }else{
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    public static Map<Map<String, String>, Map<String, Integer>> createMap(String[] arr){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        List<String> list = Arrays.asList(arr); 
        map = createMap(list);
        return map;
    }
    public static void test0(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");

        String fileName = "text/myfile.txt";
        List<String> list = getWords(fileName); 

        for(String s : list){
            List<String> pairList = pair(s); 
            for(String k : pairList){
                if(map.containsKey(k)){
                    int count = map.get(k);
                    count++;
                    map.put(k, count);
                }else{
                    map.put(k, 1);
                }
            }
        }
        
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " , " + entry.getValue() + "]");
        } 
        
        Aron.printList(list);

        Aron.end();
    }
    public static List<String> pair(String s){
        List<String> list = new ArrayList<String>(); 
        if(s.length() > 1){
            for(int k=0; k < s.length(); k++){
                for(int i=0; i < s.length()-(1 + k); i++){
                    list.add(s.substring(i, i+(2 + k)));
                }
            }
        }
        return list;
    }

    // read a text file capture all words
    // word: non-whitespace char 
    public static List<String> getWordsNonWhiteSpace(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)\\S+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // read a text file and capture all words
    // word: a-z char
    public static List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }
    public static void test1(){
        Aron.beg();
        
        String[] arr = {
            "dog",
            "cat",
            "key-value"
        };
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");
        for(String s : arr){
            Matcher matcher = pattern.matcher(s);
            if(matcher.find()){
                Print.pbl("match word=" + matcher.group());
            }
        }

        Aron.end();
    }

    public static void test2(){
        Aron.beg();
                
        String fileName = "text/textfile.txt";
        List<String> list = getWordsNonWhiteSpace(fileName);
        Aron.printList(list);

        Aron.end();
    }

    public static void test3(){
        Aron.beg();
        String s = "abc";                
        int len = s.length();

            // "abc" [ "" -> "abc"]
            //       [ "a" -> "bc"]
            //       [ "ab"-> "c" ]
            for(int j=0; j<len-1; j++){
                    String prefix = s.substring(0, j);
                    String suffix = s.substring(j, len);
                    Print.pbl("prefix=" + prefix);
                    Print.pbl("suffix=" + suffix);
            }

        Aron.end();
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public static Map<Integer, String> inverseMap(Map<String, Integer> map){

        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        return revMap;
    }
    public static void test5(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        Map<Integer, String> revMap = inverseMap(map); 

        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        Aron.end();
    }

    public static void test4(){
        Aron.beg();
        String s = "abc";                
        
        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        
        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        // 1 -> k1
        // 2 -> k2
        // 3 -> k2

        Aron.end();
    }
} 

import java.io.File;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextAreaBuilder;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBoxBuilder;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Dialog;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;

import classfile.*;

final class TextMap {
    String fileName;
    Map<List<String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
    Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
    public TextMap() {
    }
    public TextMap(String fileName) {
        this.fileName = fileName;
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords() {
        //Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");

        List<String> wordList = new ArrayList<String>();
        List<String> list = Aron.readFile(fileName);
        for(String s : list) {
            String[] arr = s.split("\\s+");
            for(String str : arr) {
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()) {
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    public Map<List<String>, Map<String, Integer>> prefixSuffixMap(List<String> list) {
        Map<List<String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
        for(int i=0; i<list.size() - 2; i++) {
            List<String> key = new HashMap<String, String>();
            Map<String, Integer> value = new HashMap<String, Integer>();
            key.add(list.get(i));
            key.add(list.get(i+1));
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key);
            if(v == null) {
                map.put(key, value);
            } else {
                Integer n = v.get(list.get(i+2));
                if(n == null) {
                    v.put(list.get(i+2), 1);
                } else {
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    // generate number [1...n]
    public int random(int n) {
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String prefix, String suffix, Map<List<String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> reverseFreMap) {

        List<String> list = new ArrayList<String>();


        // clean up prefix and suffix, e.g. trim white-space
        String[] arr = prefix.split("\\s+");
        List<String> inputList = new ArrayList<String>();
        for(String s : arr) {
            if(s.trim().length() > 0)
                inputList.add(s);
        }

        String inputSuffix = suffix.trim();
        if(inputList.size() == 2) {
            String firstPrefix = inputList.get(0);
            String secondPrefix = inputList.get(1);
            list.add(firstPrefix);
            list.add(secondPrefix);
            list.add(inputSuffix);

            Print.pbl("firstPrefix =" + firstPrefix);
            Print.pbl("secondPrefix=" + secondPrefix);
            Print.pbl("inputSuffix=" + inputSuffix);

            firstPrefix = secondPrefix;
            secondPrefix = inputSuffix;
              while(true){
                Map<String, String> key = new  HashMap<String, String>();
                key.put(firstPrefix, secondPrefix);

                Map<String, Integer> value = map.get(key);

                if(value != null) {
                    Map<Integer, String> revValueMap = reverseFreMap.get(key);
                    if(revValueMap != null) {

                        int ranKey = random(revValueMap.size());

                        String newSuffix = revValueMap.get(ranKey);
                        Print.pbl("newSuffix=" + newSuffix + " " + "ranKey=" + ranKey);
                        firstPrefix = secondPrefix;
                        secondPrefix= newSuffix;
                        list.add(newSuffix);

                        if(list.size() >= numWords){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }
        return list;
    }
    public Map<Map<String, String>, Map<Integer, String>>  reverseFrequencyMap(Map<List<String>, Map<String, Integer>> map) {

        Map<Map<String, String>, Map<Integer, String>> tableMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<List<String>, Map<String, Integer>> entry : map.entrySet()) {

            List<String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                tableMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()) {
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        }
        return tableMap;
    }

    public List<String> textGeneMap() {

        List<String> list = getWords();
        map = prefixSuffixMap(list);
        // Map<List<String>, Map<String, Integer>> 

        List<String> retList = new ArrayList<String>();
        for(Map.Entry<List<String>,  Map<String, Integer>> entry : map.entrySet()) {
            List<String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            String str = "";

                for(String s : key){
                    Print.pp(s + " ");
                    str += s + " ";
                }
                str += "=>"

//                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "[" + valueEntry.getValue() + "]");
                    str += valueEntry.getKey()  + "[" + valueEntry.getValue() + "] ";
                }
                Ut.l();
                str += "\n";
                Print.pp("\n");
            }
            retList.add(str);
            Ut.l();
        }
        return retList;
    }

    public List<String> processFile(int maxWords, String prefix, String suffix) {
        Aron.beg();

        revMap = reverseFrequencyMap(map);
        List<String> listWords= generateText(maxWords, prefix, suffix, map, revMap);
        return listWords;
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public Map<Integer, String> inverseMap(Map<String, Integer> map) {

        Map<Integer, String> rMap = new HashMap<Integer, String>();
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            Integer n = entry.getValue();

            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n) {
                rMap.put(k, entry.getKey());
                k++;
            }
        }
        return rMap;
    }
}

public class OpenFileFX extends Application {
    String fileName = null;
    TextMap textMap = new TextMap();
    final int numCharLine = 10;
    public static void main(String[] args) {
        launch(args);
    }

    public boolean isNumeric(String str) {
        return str.matches("[1-9][0-9]*|0");
    }
    @Override
    public void start(final Stage primaryStage) {
        Group root = new Group();

        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("Error");


        TextArea textArea = new TextArea();
        TextArea textTable = new TextArea();
        textArea.setMinSize(500,500);
        textTable.setMinSize(500,500);

        TextField selectedFileTF = new TextField();
        selectedFileTF.setEditable(false);
        selectedFileTF.setPrefWidth(200);
        Button buttonLoad = new Button("Select File");
        Button buttonGeneText= new Button("Generate Text");

        HBox hboxField = new HBox();
        hboxField.setAlignment(Pos.CENTER);
        hboxField.setPadding(new Insets(1, 1, 1, 1));
        hboxField.getChildren().add(textTable);
        hboxField.getChildren().add(textArea);

        VBox box = new VBox();
        box.setAlignment(Pos.TOP_CENTER);
        box.setSpacing(5);
        box.getChildren().add(hboxField);

        HBox hboxTextField1 = new HBox();
        HBox hboxtextField2 = new HBox();
        hboxTextField1.setAlignment(Pos.CENTER);
        hboxTextField1.setSpacing(20);

        Label prefixLable = new Label("Prefix:");
        Label suffixLable = new Label("Suffix:");
        Label maxWordsLable = new Label("Maximum Words:");

        TextField prefixTF = new TextField ();
        TextField suffixTF = new TextField ();
        TextField maxWordsTF = new TextField ();


        buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                FileChooser fileChooser = new FileChooser();
                FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("TXT files (*.txt)", "*.txt");
                fileChooser.getExtensionFilters().add(extFilter);

                File file = fileChooser.showOpenDialog(primaryStage);

                Print.pbl("file =" + file);
                if(file != null) {
                    fileName = file.getAbsolutePath();

                    if(fileName != null) {
                        textMap = new TextMap(fileName);
                        selectedFileTF.setText(file.getName());

                        List<String> textList = textMap.textGeneMap();
                        textTable.clear();
                        for(String s : textList) {
                            Print.pbl("s=" + s);
                            textTable.appendText(s + " ");
                        }
                    }
                } 
            }
        });

        buttonGeneText.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                Aron.beg();

                if(fileName != null) {
                    List<String> list = Aron.getWords(fileName);
                    Aron.printList(list);

                    if(prefixTF.getText().length() > 0 && prefixTF.getText().length() > 0) {
                        Print.pbl("prefixTF=" + prefixTF.getText());
                        Print.pbl("suffixTF=" + suffixTF.getText());
                        Print.pbl("maxWordsLable=" + maxWordsLable.getText());

                        if(isNumeric(maxWordsTF.getText().trim())) {
                            Integer maxWords = Integer.valueOf(maxWordsTF.getText().trim());
                            Print.pbl("maxWords=" + maxWords);
                            List<String> wlist = textMap.processFile(maxWords, prefixTF.getText(), suffixTF.getText());

                            textArea.clear();

                            int count = 0;
                            for(String s : wlist) {
                                Print.pbl("s=" + s);
                                if((count % numCharLine)  + 1 == numCharLine)
                                    textArea.appendText(s + "\n");
                                else
                                    textArea.appendText(s + " ");

                                count++;
                            }

                        } else {
                            alert.setHeaderText("Maximum Words: invalid input");
                            alert.setContentText("Maximum Words field must be an integer.");
                            alert.showAndWait();
                        }

                    }else{
                        alert.setHeaderText("Invalid Prefix or Suffix");
                        alert.setContentText("Prefix must be two words\n Suffix must be one word");
                        alert.showAndWait();
                    }
                }else{
                    alert.setHeaderText("Invalid file");
                    alert.setContentText("Please select a valid text file.");
                    alert.showAndWait();
                }

            }
        });

        HBox lbtTFBox1 = new HBox();
        HBox lbtTFBox2 = new HBox();
        HBox lbtTFBox3 = new HBox();

        lbtTFBox1.getChildren().addAll(prefixLable, prefixTF);
        lbtTFBox1.setSpacing(2);
        lbtTFBox1.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox1.setStyle("-fx-background-color: #EEEEEE;");


        lbtTFBox2.getChildren().addAll(suffixLable, suffixTF);
        lbtTFBox2.setSpacing(2);
        lbtTFBox2.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox2.setStyle("-fx-background-color: #EEEEEE;");

        lbtTFBox3.getChildren().addAll(maxWordsLable, maxWordsTF);
        lbtTFBox3.setSpacing(2);
        lbtTFBox3.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox3.setStyle("-fx-background-color: #EEEEEE;");

        hboxTextField1.getChildren().addAll(lbtTFBox1);
        hboxTextField1.getChildren().addAll(lbtTFBox2);
        hboxTextField1.getChildren().addAll(lbtTFBox3);

        box.getChildren().addAll(hboxTextField1);

        HBox fileBox = new HBox();
        fileBox.setAlignment(Pos.CENTER);
        fileBox.setSpacing(2);
        fileBox.getChildren().addAll(buttonLoad, selectedFileTF);
        box.getChildren().add(fileBox);

        box.getChildren().add(buttonGeneText);
        primaryStage.setScene(new Scene(box, 800, 600));
        primaryStage.show();
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class NimGame{
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();
        int num = 8;
        List<Integer> list = new ArrayList<Integer>(); 
        list.add(num);
        boolean flag = false;
        boolean boo = nim(num, num, flag, list);
        System.out.println("nim[" + boo + "]"); 
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        int num = 1;
        List<Integer> list = new ArrayList<Integer>(); 
        list.add(num);
        boolean flag = false;
        boolean boo = nim(num, num, flag, list);
        System.out.println("nim[" + boo + "]"); 
        Aron.end();
    }
    // Init level = 0 
    public static boolean nim(int n, int prev, boolean flag, List<Integer> list){
        boolean ret = false;
        if(n == 0){
            if(prev == 1 && flag){
                for(Integer item : list){
                    System.out.println("item[" + item + "]"); 
                }
                ret = true;
            }
        }else if(n > 0){
            for(int i=1; i<=3; i++){
                list.add(n-i);
                System.out.println("[" + n + "]->(" + i + ")[" + (n-i) + "] flag[" + flag + "] prev[" + prev + "] i[" + i + "]"); 
                ret = nim(n-i, n, !flag, list);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }
        }
        return ret;
    } 
}

import java.util.*;
import java.io.*;
import classfile.*;

public class NonConsecutive{
    public static void main(String[] args) {
         test00_maxNonConsecutiveSum();
         test01_maxNonConsecutiveSum();
         test02_maxNonConsecutiveSum();
         test03_maxNonConsecutiveSum();
         test04_maxNonConsecutiveSum();
    }

    //[file=nonconsecutive.html title="maximum consecutive sum"
    // [ ] {4} 5
    // 
    // [4, 7]
    // m = 4
    // curr = 7 
    // max = 4 
    // => max = 7
    // --------------- 
    // [4, 7, 5]
    // m = 4 
    // curr = 7
    // max = 4
    // ------
    // m = 7
    // curr = 4 + 5 
    // max = 7
    // => max(9, 7) = 9
    // ---------------
    public static int maxNonConsecutiveSum(int[] arr){
        int max = 0;
        if(arr != null && arr.length > 0){
            int len = arr.length;
            int pmax = 0;
            max = arr[0];
            for(int i=1; i<len; i++){
                int m1 = Math.max(pmax + arr[i], arr[i]);
                int m2 = Math.max(max, arr[i]);
                pmax = max;
                max = Math.max(m1, m2);
            } 
        }
        return max;
    }
    //]

    static void test00_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 4);
        Aron.end();
    }
    static void test01_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 7);
        Aron.end();
    }
    static void test02_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7, 5}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 9);
        Aron.end();
    }
    static void test03_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7, 5, 9, 1, 2, -4, 20}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 38);
        Aron.end();
    }
    static void test04_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7, 5, 9, 90, 100}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 116);
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;


class Node {
    public Node left;
    public Node right;
    public Node next;
    public Character data;
    public boolean isVisited;
    public Node(Character n) {
        left = right = null;
        data = n;
        isVisited = false;
    }
}


public class NonRepeatingChar{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
    }

    static void test0(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a'}; 

        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 1;
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    static void test1(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a', 'c'}; 
        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 9;
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a', 'b', 'e', 'b'}; 
        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 2;
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    static void test3(){
        Aron.beg();
        Character[] arr = {'a'}; 
        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 'a';
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    static void test4(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a'}; 
        int len = arr.length;
        Character value = 'b';
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }
    static void test5(){
        Aron.beg();
        Character[] arr = {'a', 'a', 'a', 'b', 'a'}; 
        int len = arr.length;
        Character value = 'b';
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    //[ file=nonrepeatingchar.html title=""
    static Character nonRepeatingChar(Character[] arr, int index){
        List<Node> list =  new LinkedList<Node>();
        if(arr != null){
            Map<Character, Node> map = new HashMap<Character, Node>();

            for(int i=0; i<arr.length; i++){
                if(i <= index){
                    Character ch = arr[i];
                    if(!map.containsKey(ch)){
                        Node node = new Node(ch);
                        list.add(node);
                        map.put(ch, node);
                    }else{
                        Node vNode = map.get(ch);
                        if(vNode != null){
                            list.remove(vNode);
                            map.put(ch, null);
                        }
                    }
                }else{
                    break;
                }
            }
        }
        if(list.size() > 0)
            return list.get(0).data;
        else
            return null;
    }
    //]
} 
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.List;

public class NumOperator{
    public static void main(String[] args) {
        System.out.println("Hello World!");
        test();
    }
    static int numOperator(int n){
        List<Integer> list = new ArrayList<Integer>();
        if(n == 0)
            list.add(0);
        else if(n > 0){
            while(n > 0){
                int r = n % 2;
                list.add(r);
                n = n/2;
            }
        }

        int sum = 0;
        for(int i=0; i<list.size(); i++){
            if(list.get(i) == 1)
                sum += i+1;
        }
        return sum;
    }
    static void test(){
        System.out.println(numOperator(5));
        System.out.println(numOperator(3));
    }
}
import java.util.*;

//Convert numerical number to English spoken words
class ConvertNumberToEnglish
{
    Map<Integer, String> map = new HashMap<Integer, String>();
    public ConvertNumberToEnglish()
    { }
    public void InitMap()
    {
        map.put(0, "[zero]");
        map.put(1, "[one]");
        map.put(2, "[two]");
        map.put(3, "[three]");
        map.put(4, "[four]");
        map.put(5, "[five]");
        map.put(6, "[six]");
        map.put(7, "[seven]");
        map.put(8, "[eight]");
        map.put(9, "[nine]");

        map.put(10, "[ten]");
        map.put(11, "[eleven]");
        map.put(12, "[twelve]");
        map.put(13, "[thirteen]");
        map.put(15, "[fifteen]");
        map.put(16, "[sixteen]");
        map.put(17, "[seventeen]");
        map.put(18, "[eighteen]");
        map.put(19, "[nineteen]");

        map.put(20, "[twenty]");
        map.put(30, "[thirty]");
        map.put(40, "[forty]");
        map.put(50, "[fifty]");
        map.put(60, "[sixty]");
        map.put(70, "[seventy]");
        map.put(80, "[eighty]");
        map.put(90, "[ninety]");

        map.put(100, "[hundred]");
        map.put(1000, "[thousand]");
        map.put(1000000, "[million]");
        map.put(1000000000, "[billion]");
    }
    public void convert(int num)
    {
        System.out.print("{"+num+"}=");
        if(num == 0)
            System.out.print(map.get(num));
        else if(num > 0)
        {
            int[][] array = table(num);
            int len = array.length;
            String s = "";
            for(int c=0; c < array.length; c++)
            {
                s = processRow(array[c], c) + s;
            }
            System.out.print(s);
        }
    }
    public int[][] table(int num)
    {
        int numRow = 0;
        if(num > 0)
            numRow = (int)(Math.log(num)/Math.log(1000)) + 1;

        int[][] array = new int[numRow][3];
        int col = 0;
        while(num > 0)
        {
           int r = num % 1000; 
           num /= 1000;
           int row = 0;
           while(r > 0)
           {
                int rr = r % 10;
                r /= 10;
                array[col][row] = rr;
                row++;
           }
           col++;
        }
        return array;
    }
    public String processRow(int[] row, int pow)
    {
        String first = "";
        String second = "";
        String third = "";
        String s ="";
        if(row[0] != 0 || row[1] != 0 || row[2] != 0)
        {
            if(row[0] > 0)
            {
                first = map.get(row[0]);
            }
            if(row[1] > 0)
            {
                second = map.get(row[1]*10);
            }
            if(row[2] > 0)
            {
                int r = row[2] % 100;
                third = map.get(r) + map.get(100);
            }
            if(pow > 0)
                s = third + second + first + map.get((int)Math.pow(1000, pow));
            else 
                s = third + second + first;
        }
        return s;
    }
}

public class NumberToWord
{
    public static void main(String[] args)
    {
        System.out.println("Convert Number to English Words");
        ConvertNumberToEnglish con = new ConvertNumberToEnglish();
        con.InitMap();
        con.convert(0);
        System.out.println();
        con.convert(123);
        System.out.println();
        con.convert(20004);
        System.out.println();
        con.convert(200005);
        System.out.println();
        con.convert(123346789);
        System.out.println();
        con.convert(987654321);
        System.out.println();
        con.convert(90000001);
        System.out.println();
        con.convert(100000000);
        System.out.println();
    }
}
import java.io.File;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextAreaBuilder;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBoxBuilder;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Dialog;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;

import classfile.*;

final class TextMap {
    String fileName;
    Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
    Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
    public TextMap() {
    }
    public TextMap(String fileName) {
        this.fileName = fileName;
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords() {
        //Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");

        List<String> wordList = new ArrayList<String>();
        List<String> list = Aron.readFile(fileName);
        for(String s : list) {
            String[] arr = s.split("\\s+");
            for(String str : arr) {
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()) {
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    public Map<Map<String, String>, Map<String, Integer>> prefixSuffixMap(List<String> list) {
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
        for(int i=0; i<list.size() - 2; i++) {
            Map<String, String> key = new HashMap<String, String>();
            Map<String, Integer> value = new HashMap<String, Integer>();
            key.put(list.get(i), list.get(i+1));
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key);
            if(v == null) {
                map.put(key, value);
            } else {
                Integer n = v.get(list.get(i+2));
                if(n == null) {
                    v.put(list.get(i+2), 1);
                } else {
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    // generate number [1...n]
    public int random(int n) {
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String prefix, String suffix, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> reverseFreMap) {

        List<String> list = new ArrayList<String>();


        // clean up prefix and suffix, e.g. trim white-space
        String[] arr = prefix.split("\\s+");
        List<String> inputList = new ArrayList<String>();
        for(String s : arr) {
            if(s.trim().length() > 0)
                inputList.add(s);
        }

        String inputSuffix = suffix.trim();
        if(inputList.size() == 2) {
            String firstPrefix = inputList.get(0);
            String secondPrefix = inputList.get(1);
            list.add(firstPrefix);
            list.add(secondPrefix);
            list.add(inputSuffix);

            Print.pbl("firstPrefix =" + firstPrefix);
            Print.pbl("secondPrefix=" + secondPrefix);
            Print.pbl("inputSuffix=" + inputSuffix);

            firstPrefix = secondPrefix;
            secondPrefix = inputSuffix;
              while(true){
                Map<String, String> key = new  HashMap<String, String>();
                key.put(firstPrefix, secondPrefix);

                Map<String, Integer> value = map.get(key);

                if(value != null) {
                    Map<Integer, String> revValueMap = reverseFreMap.get(key);
                    if(revValueMap != null) {

                        int ranKey = random(revValueMap.size());

                        String newSuffix = revValueMap.get(ranKey);
                        Print.pbl("newSuffix=" + newSuffix + " " + "ranKey=" + ranKey);
                        firstPrefix = secondPrefix;
                        secondPrefix= newSuffix;
                        list.add(newSuffix);

                        if(list.size() >= numWords){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }
        return list;
    }
    public Map<Map<String, String>, Map<Integer, String>>  reverseFrequencyMap(Map<Map<String, String>, Map<String, Integer>> map) {

        Map<Map<String, String>, Map<Integer, String>> tableMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                tableMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()) {
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        }
        return tableMap;
    }

    public List<String> textGeneMap() {

        List<String> list = getWords();
        map = prefixSuffixMap(list);

        List<String> retList = new ArrayList<String>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            String str = "";
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");
                str += keyEntry.getKey() + " " + keyEntry.getValue() + " => ";

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "[" + valueEntry.getValue() + "]");
                    str += valueEntry.getKey()  + "[" + valueEntry.getValue() + "] ";
                }
                Ut.l();
                str += "\n";
                Print.pp("\n");
            }
            retList.add(str);
            Ut.l();
        }
        return retList;
    }

    public List<String> processFile(int maxWords, String prefix, String suffix) {
        Aron.beg();

        revMap = reverseFrequencyMap(map);
        List<String> listWords= generateText(maxWords, prefix, suffix, map, revMap);
        return listWords;
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public Map<Integer, String> inverseMap(Map<String, Integer> map) {

        Map<Integer, String> rMap = new HashMap<Integer, String>();
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            Integer n = entry.getValue();

            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n) {
                rMap.put(k, entry.getKey());
                k++;
            }
        }
        return rMap;
    }
}

public class OpenFileFX extends Application {
    String fileName = null;
    TextMap textMap = new TextMap();
    final int numCharLine = 10;
    public static void main(String[] args) {
        launch(args);
    }

    public boolean isNumeric(String str) {
        return str.matches("[1-9][0-9]*|0");
    }
    @Override
    public void start(final Stage primaryStage) {
        Group root = new Group();

        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("Error");


        TextArea textArea = new TextArea();
        TextArea textTable = new TextArea();
        textArea.setMinSize(500,500);
        textTable.setMinSize(500,500);

        TextField selectedFileTF = new TextField();
        selectedFileTF.setEditable(false);
        selectedFileTF.setPrefWidth(200);
        Button buttonLoad = new Button("Select File");
        Button buttonGeneText= new Button("Generate Text");

        HBox hboxField = new HBox();
        hboxField.setAlignment(Pos.CENTER);
        hboxField.setPadding(new Insets(1, 1, 1, 1));
        hboxField.getChildren().add(textTable);
        hboxField.getChildren().add(textArea);

        VBox box = new VBox();
        box.setAlignment(Pos.TOP_CENTER);
        box.setSpacing(5);
        box.getChildren().add(hboxField);

        HBox hboxTextField1 = new HBox();
        HBox hboxtextField2 = new HBox();
        hboxTextField1.setAlignment(Pos.CENTER);
        hboxTextField1.setSpacing(20);

        Label prefixLable = new Label("Prefix:");
        Label suffixLable = new Label("Suffix:");
        Label maxWordsLable = new Label("Maximum Words:");

        TextField prefixTF = new TextField ();
        TextField suffixTF = new TextField ();
        TextField maxWordsTF = new TextField ();


        buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                FileChooser fileChooser = new FileChooser();
                FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("TXT files (*.txt)", "*.txt");
                fileChooser.getExtensionFilters().add(extFilter);

                File file = fileChooser.showOpenDialog(primaryStage);

                Print.pbl("file =" + file);
                if(file != null) {
                    fileName = file.getAbsolutePath();

                    if(fileName != null) {
                        textMap = new TextMap(fileName);
                        selectedFileTF.setText(file.getName());

                        List<String> textList = textMap.textGeneMap();
                        textTable.clear();
                        for(String s : textList) {
                            Print.pbl("s=" + s);
                            textTable.appendText(s + " ");
                        }
                    }
                } 
            }
        });

        buttonGeneText.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                Aron.beg();

                if(fileName != null) {
                    List<String> list = Aron.getWords(fileName);
                    Aron.printList(list);

                    if(prefixTF.getText().length() > 0 && prefixTF.getText().length() > 0) {
                        Print.pbl("prefixTF=" + prefixTF.getText());
                        Print.pbl("suffixTF=" + suffixTF.getText());
                        Print.pbl("maxWordsLable=" + maxWordsLable.getText());

                        if(isNumeric(maxWordsTF.getText().trim())) {
                            Integer maxWords = Integer.valueOf(maxWordsTF.getText().trim());
                            Print.pbl("maxWords=" + maxWords);
                            List<String> wlist = textMap.processFile(maxWords, prefixTF.getText(), suffixTF.getText());

                            textArea.clear();

                            int count = 0;
                            for(String s : wlist) {
                                Print.pbl("s=" + s);
                                if((count % numCharLine)  + 1 == numCharLine)
                                    textArea.appendText(s + "\n");
                                else
                                    textArea.appendText(s + " ");

                                count++;
                            }

                        } else {
                            alert.setHeaderText("Maximum Words: invalid input");
                            alert.setContentText("Maximum Words field must be an integer.");
                            alert.showAndWait();
                        }

                    }else{
                        alert.setHeaderText("Invalid Prefix or Suffix");
                        alert.setContentText("Prefix must be two words\n Suffix must be one word");
                        alert.showAndWait();
                    }
                }else{
                    alert.setHeaderText("Invalid file");
                    alert.setContentText("Please select a valid text file.");
                    alert.showAndWait();
                }

            }
        });

        HBox lbtTFBox1 = new HBox();
        HBox lbtTFBox2 = new HBox();
        HBox lbtTFBox3 = new HBox();

        lbtTFBox1.getChildren().addAll(prefixLable, prefixTF);
        lbtTFBox1.setSpacing(2);
        lbtTFBox1.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox1.setStyle("-fx-background-color: #EEEEEE;");


        lbtTFBox2.getChildren().addAll(suffixLable, suffixTF);
        lbtTFBox2.setSpacing(2);
        lbtTFBox2.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox2.setStyle("-fx-background-color: #EEEEEE;");

        lbtTFBox3.getChildren().addAll(maxWordsLable, maxWordsTF);
        lbtTFBox3.setSpacing(2);
        lbtTFBox3.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox3.setStyle("-fx-background-color: #EEEEEE;");

        hboxTextField1.getChildren().addAll(lbtTFBox1);
        hboxTextField1.getChildren().addAll(lbtTFBox2);
        hboxTextField1.getChildren().addAll(lbtTFBox3);

        box.getChildren().addAll(hboxTextField1);

        HBox fileBox = new HBox();
        fileBox.setAlignment(Pos.CENTER);
        fileBox.setSpacing(2);
        fileBox.getChildren().addAll(buttonLoad, selectedFileTF);
        box.getChildren().add(fileBox);

        box.getChildren().add(buttonGeneText);
        primaryStage.setScene(new Scene(box, 800, 600));
        primaryStage.show();
    }
}
import java.util.*;
import java.io.*;
import classfile.*;
import org.apache.commons.lang3.StringUtils;

// padding example 
// use apache common lib
// jar file /Users/cat/myfile/github/JavaLib/commons-lang3-3.5.jar
public class PaddingExample{
    public static void main(String[] args) {
        String s1 = StringUtils.leftPad("reccoon", 10, '-');
        Print.pbl(s1);
        String s2 = StringUtils.leftPad("bat", 5, '=');
        Print.pbl(s2);
    }
}

public class PalindromeSpace
{
    public static void main(String[] args)
    {
        System.out.println("Palindrome With Space");
        
        boolean ret0 = isPalindrome(null);
        boolean ret1 = isPalindrome("");
        boolean ret2 = isPalindrome(" ");
        boolean ret3 = isPalindrome(" a");
        boolean ret4 = isPalindrome("a ");
        boolean ret5 = isPalindrome("ab");
        boolean ret6 = isPalindrome("aa");
        boolean ret7 = isPalindrome("a a");
        boolean ret8 = isPalindrome("a b");
        boolean ret9 = isPalindrome("a b ba");
        System.out.println("[null]["+ret0+"] []["+ret1+"] [ ]["+ret2+"] [ a]["+ret3+"] [a ]["+ret4+"] [ab]["+ret5+"] [aa]["+ret6+"] [a a]["+ret7+"] [a b]["+ret8+"] [a b ba]["+ret9+"]");
    }
    public static boolean isPalindrome2(String str) 
    {
        if( str != null)
        {
            int len = str.length();
            int i=0;
            for(i=0; i<len && str.charAt(i) != str(len-1-i); i++);
            return i == len;
        }
    }
    public static boolean isPalindrome(String str)
    {
        boolean ret = true;
        boolean done = false;
        if(str != null && str.length() > 1)
        {
            int len = str.length();
            int i = 0; 
            int j = len - 1;
            while(!done && ret)
            {
                if(str.charAt(i) == str.charAt(j)) 
                {
                    if(i == j || i == j - 1)
                        done = true;
                    else
                    {
                        if(i < len - 1)
                            i++;
                        if(j > 0)
                            j--;
                    }
                }
                else
                {
                    if(str.charAt(i) == ' ')
                    {
                        if(i < len - 1)
                            i++;
                    }
                    else if(str.charAt(j) == ' ') 
                    {
                        if(j > 0)
                            j--;
                    }
                    else
                    {
                        ret = false;
                    }
                }
            }
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;
import classfile.*;

enum Type{
    OPEN,
    CLOSE,
    ITEM,
    NONE
}

public class ParseBracketTree{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    public static void test0(){
        Aron.beg();

        String str = "[ 1 ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        Iterator<String> ite = list.iterator(); 
        Node root = buildTree(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);

        Aron.printList(list);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        String str = "[ 1"
                    +" [ 12 ]"
                    +" [ 13 ]"
                    +" ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        Iterator<String> ite = list.iterator(); 
        Node root = buildTree(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        String str = "[ 1"
                    +" [ 12 ]"
                    +" [ 13 ]"
                    +" [ 14 ]"
                    +"  [ 111 "
                         +" [ 112 ]"
                         +" [ 113 ]"
                    +"  ]"
                    +" ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        Iterator<String> ite = list.iterator(); 
        Node root = buildTree(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        String str = "[ 1 ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        List<String> list2 = new ArrayList<String>(); 

        for(String s : list){
            if(getTokenType(s) != Type.OPEN)
                list2.add(s);
        }
        
        Iterator<String> ite = list2.iterator(); 
        Node root = buildTreeRecursion(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static void test4(){
        Aron.beg();
        String str = "[ 1"
                    +" [ 12 ]"
                    +" [ 13 ]"
                    +" [ 14 ]"
                    +"  [ 111 "
                         +" [ 112 ]"
                         +" [ 113 ]"
                    +"  ]"
                    +" ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        List<String> list2 = new ArrayList<String>(); 

        for(String s : list){
            if(getTokenType(s) != Type.OPEN)
                list2.add(s);
        }

        Aron.printList(list2, "(");
        
        Iterator<String> ite = list2.iterator(); 
        Node root = buildTreeRecursion(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static boolean validate(String fname){
        try{
            BufferedReader br = new BufferedReader(new FileReader(fname));
            String line = null;
            while( (line = br.readLine()) != null){
                Print.pbl(line);
            }
        }
        catch(IOException e){
            e.printStackTrace();
        }
        return true;
    }

    public static Node buildTree(Iterator<String> ite){
        Stack<Node> stack = new Stack<>();

        while(ite.hasNext()){
            String item = ite.next();
            if(getTokenType(item) == Type.ITEM){
                stack.push(new Node(item));
            }else if(getTokenType(item) == Type.CLOSE){
                if(stack.size() > 1){
                    Node node = stack.pop();
                    stack.peek().list.add(node);
                }
            }
        }
        return stack.peek();
    }
    public static Node buildTreeRecursion(Iterator<String> ite){
        Node root = null;
        if(ite.hasNext()){
            String item = ite.next();
            if(getTokenType(item) == Type.ITEM){
                root = buildTreeRecursion(ite);
            }else if(getTokenType(item) == Type.CLOSE){
                Node ret = buildTreeRecursion(ite);     
            }
        }
        return root;
    }

    public static Type getTokenType(String str){
        Pattern r = Pattern.compile("\\d+");
        if(str.equals("[")){
            return Type.OPEN;
        }else if(str.equals("]")){
            return Type.CLOSE;
        }else if(r.matcher(str).find()){
            return Type.ITEM;
        }
        return Type.NONE;
    }
    
    static void test9(){
        Aron.beg();
        Type type1 = getTokenType("[");
        Type type2 = getTokenType("]");
        Type type3 = getTokenType("123");
        Print.pbl(type1);
        Print.pbl(type2);
        Print.pbl(type3);
        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class Partition 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		int[] Arr = {1, 7};
		int left = 0;
		int right = Arr.length - 1;
		int piv = partition(Arr, left, right);
		System.out.println("piv=" + piv);
	}
	public static int partition(int[] Arr, int left, int right)
	{
		int ret = -1;
		if(Arr != null)
		{
			int len = Arr.length;
			if(len == 1)
				ret = 0;
			else if(len > 1)
			{
				int i=left;
				int j=len - 1;
				int pivot = Arr[left];
				while(i<j)
				{
					while(Arr[i] <= pivot && i < len-1) i++;
					while(Arr[j] > pivot && j > 0) j--;
					if(i < j)
					{
						int tmp = Arr[i];
						Arr[i] = Arr[j];
						Arr[j] = tmp;
					}
				}
				int t = Arr[left];
				Arr[left] = Arr[j];
				Arr[j] = t;
				ret = j;

				for(int k=0; k<len; k++)
				{
					System.out.println("Arr[" + k + "]=" + Arr[k]);
				}

			}
		}
		return ret;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

public class PartitionArray{
    public static void main(String[] args) {
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    
    static void test3(){
        Aron.beg();
        Integer[] arr = {2, 0, 3, 0};
        partition(arr);
        Aron.printArray(arr);
        Aron.end();
    } 
    static void test4(){
        Aron.beg();
        Integer[] arr = {2, 0, 3};
        partition(arr);
        Aron.printArray(arr);
        Aron.end();
    }
    static void test5(){
        Aron.beg();
        Integer[] arr = {0, 0, 2, 0, 0, 3, 2, 0, 3};
        partition(arr);
        Aron.printArray(arr);
        Aron.end();
    }
    static void test6(){
        Aron.beg();
        Integer[] arr = {0, 0, 0, 0, 0};
        Aron.printArray(arr);
        Aron.end();
    } 
    static void test7(){
        Aron.beg();
        Integer[] arr = {2, 3};
        Aron.printArray(arr);
        Aron.end();
    } 

    //[ file=partitionarray.html title=""
    static void partition(Integer[] arr){
        if(arr != null){
            int len = arr.length;
            int nonzero = len-1;
            for(int i=len-1; i >= 0; i--){
                if(arr[i] == 0){
                    int tmp = arr[i];
                    arr[i] = arr[nonzero];
                    arr[nonzero] = tmp;
                    nonzero--;
                }
            }
        }
    }
    //]
}
import java.util.*;
import java.io.*;
import classfile.*;

public class PartitionFB{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    public static void test0() {
        Aron.beg();

        Integer[] arr = {0, 2}; 
        Integer[] expectedArray = {2, 0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();

        Integer[] arr = {0}; 
        Integer[] expectedArray = {0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();

        Integer[] arr = {1}; 
        Integer[] expectedArray = {1}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();

        Integer[] arr = {1, 0}; 
        Integer[] expectedArray = {1, 0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test4() {
        Aron.beg();

        Integer[] arr = {0, 2, 0, 3, 0}; 
        Integer[] expectedArray = {2, 3, 0, 0, 0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void swap(Integer[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    //[ file=part3.html title=""
    // move all zeros to the right side of array
    // [1, 0, 3, 0] => [1, 3, 0, 0]
    public static void partition(Integer[] arr){
        if(arr != null){
            int zeroIndex = 0;
            int len = arr.length;
            for(int i=0; i<len; i++){
                if(arr[i].intValue() > 0){
                    if(i != zeroIndex)
                        swap(arr, i, zeroIndex);
                    // make sure the zeroIndex is not out of bounds
                    if(zeroIndex < len-1)
                        zeroIndex++;
                }
            }
        }
    }
    //]
}

import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}

//Find the node from the Binary Tree and return the path from the current node
//to root
//The algorithm is similar to isBST() and use inorder traveral to walk through
//all the nodes, once the node is found, then recursion is terminated 
class PathToKBinarySearch 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(10);
		b1.Insert(5);
		b1.Insert(15);
        
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
        
        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        //swap(5, 15, b1.getRoot(), first, second);
        
        inorder(b1.getRoot());
		
        System.out.println("");
        PathToK(b1.getRoot(), 199);
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            else if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
		        System.out.println(node.data);
            inorder(node.right);
        }
    }

    public static boolean PathToK(Node node, int k)
    {
        if(node != null)
        {
            if(PathToK(node.left, k))
            {
		        System.out.println(node.data);
                return true;
            }
            if(node.data == k)
            {
		        System.out.println(node.data);
                return true;
            }
            if(PathToK(node.right, k))
            {
		        System.out.println(node.data);
                return true;
            }
        }
        return false;
    }
}
public class PatternMatch 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    //"ab?"
    //Generate table for "ab?" pattern
    public static boolean match(String pattern, String str)
    {
        Map<Integer, Map<String, Integer>> map = new HashMap<Integer, Map<String, Character>>();

        /*
        for(int i=0; i<pattern.length(); i++)
        {
            char currChar = pattern.charAt(i);
            char nextChar = '0';
            if(i+1 < pattern.length())
                char nextch = pattern.charAt(i+1);
            //if(nextChar == '?')
            //else


        }
        */
    }
}
import java.io.*;
import java.lang.String;
import classfile.*; 

class PermRecursive {
    public static void main(String args[]) {
        test0_permutation();
        test1_permutation();
        test2_permutation();
        test0_permutationPrefix();
        test1_permutationPrefix();
        test2_permutationPrefix();
        test3_permutationPrefix();
        //test1();
        //test2();
    }
    
    static void test0_permutation(){
        Aron.beg();
        char[] charArr= {'a'};
        int index = 0;
        permutation(charArr, index);
        Aron.end();
    }
    static void test1_permutation(){
        Aron.beg();
        char[] charArr= {'a', 'b'};
        int index = 0;
        permutation(charArr, index);
        Aron.end();
    }
    static void test2_permutation(){
        Aron.beg();
        char[] charArr= {'a', 'b', 'c'};
        int index = 0;
        permutation(charArr, index);
        Aron.end();
    }
    static void test0_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    static void test1_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "a";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    static void test2_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "ab";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    static void test3_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "abc";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    public static void test1() {
        char[] charArr= {'a', 'b', 'c'};
        int[] arr = {100};
        int inx = 0;

        System.out.println("digraph G {\n");
        permu_Graph(charArr, inx, arr);
        System.out.println("}\n");
    }
    public static void test2() {
        // Print the content on the console
        //System.out.println ("cool");
        int inx=0;
        char[] charArr= {'a', 'b', 'c'};
        //char[] charArr={};
        //permu(charArr, inx);
        //String s = removeChar("abcde", 2);
        //System.out.println ("s=" + s);

        int[][] array = { {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        int col = 0;
        printUpperTriangle(array, col);
    }

    public static void permu(char[] charArr, int inx) {
        if( charArr != null) {
            if(charArr.length == inx) {
                for(int i=0; i<charArr.length; i++)
                    System.out.print(charArr[i]+" ");
                System.out.println();
            } else
                for(int i=inx; i<charArr.length; i++) {
                    char tmp = charArr[i];

//                    charArr[i] = charArr[inx];
//                    charArr[inx] = tmp;
//                    permu(charArr, inx+1);
                    Aron.swap(charArr, i, inx);

                    tmp = charArr[i];
                    charArr[i] = charArr[inx];
                    charArr[inx] = tmp;
                }
        }
    }

    public static void permu_Graph(char[] charArr, int inx, int[] arr) {
        if( charArr != null) {
            if(charArr.length == inx) {
                for(int i=0; i<charArr.length; i++)
                    System.out.print(charArr[i]+" ");
                System.out.println();
            } else {
                for(int i=inx; i<charArr.length; i++) {
                    char tmp = charArr[i];
                    charArr[i] = charArr[inx];
                    charArr[inx] = tmp;

                    permu_Graph(charArr, inx+1, arr);

                    tmp = charArr[i];
                    charArr[i] = charArr[inx];
                    charArr[inx] = tmp;
                }
            }
        }
    }
    public static void printUpperTriangle(int[][] array, int col) {
        for(int row=col; row<array.length; row++) {
            printUpperTriangle(array, col+1);
            System.out.println("[" + col + "][" + row+ "]=" + array[col][row]);
        }
    }

    //[ file=permuteJava.html title=" Generate permutation for n characters"
    // generate all permutation from given char[], e.g. ['a', 'b']
    //
    public static void permutation(char[] arr, int index){
        if(index == arr.length){
            Aron.printArray(arr);
        }else{
            if(arr != null){
                int len = arr.length;
                for(int i=index; i<len; i++){
                    Aron.swap(arr, i, index);
                    permutation(arr, index + 1);
                    Aron.swap(arr, i, index);
                } 
            }
        }
    }
    //]

    
    //[ file=permutationprefix.html title=" Generate all permutation in sorted order"
    // permutations are in sorted ordering in lexicographically
    public static void permutationPrefix(String prefix, String str){
        if(str != null){
            if(str.length() == 0){
                Print.p(prefix);
            }else{
                int len = str.length();
                for(int i=0; i<len; i++){
                    String s = str.charAt(i) + "";
                    permutationPrefix(prefix + s, remove(str, i));
                } 
            }
        }
    }
    public static String remove(String str, int index){
        String s = "";
        for(int i=0; i<str.length(); i++){
            if(i != index)
                s += str.charAt(i) + "";
        } 
        return s;
    }
    //]
}
import java.util.*;
public class PermRepeated 
{
    public static void main(String[] args)
    {
        System.out.println("Print all permuation character with repeating character!");
        String s = "ABC";
        char[] array = new char[s.length()];
        int depth = 0;
        Set<Character> map = new LinkedHashSet<Character>();
        //permRepeated(s, array, depth);
        //perm(s, array, depth, map);

        int k=2;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i);

        test1();
    }

    public static void ExcelSheetRowNumber(String s)
    {
        char[] array = new char[s.length()];
        int depth = 0;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i);
    }


    //Given string character array and integer k,
    //print all permutation with repeatation string length k 
    public static void permRepeatedChooseK(String s, char[] array, int depth, int k)
    {
        if(depth == k)
        {
            for(int i=0; i<depth; i++)
            {
                System.out.print("["+array[i]+"]");
            }
            System.out.println();
        }
        else 
        {
            if(array != null && s != null)
            {
                for(int i=0; i<s.length(); i++)
                {
                    array[depth] = s.charAt(i);
                    permRepeatedChooseK(s, array, depth+1, k);
                }
            }
        }
    }

    public static void permRepeated(String s, char[] array, int depth)
    {
        if(s != null)
        {
            if(s.length() == depth)
            {
                for(int i=0; i<depth; i++)
                {
                    System.out.print("["+array[i]+"]");
                }
                System.out.println();
            }
            else
            {
                for(int i=0; i<s.length(); i++)
                {
                    array[depth] = s.charAt(i);
                    permRepeated(s, array, depth+1);
                }
            }
        }
    }
    public static void permRepeatingChar(Character[] array, int depth, Set<String> set)
    {
        if(depth == array.length)
        {
            String s="";
            for(Character ch:array)
                s += ch.toString();

            if(!set.contains(s))
                set.add(s);
        }
        else
        {
            for(int i=depth; i<array.length; i++)
            {
                Aron.swap(array, i, depth);
                permRepeatingChar(array, depth+1, set);
                Aron.swap(array, i, depth);
            }
        }
    }
    public static void perm(String s, char[] array, int depth, Set<Character> map)
    {
        if(s != null)
        {
            if(s.length() == depth)
            {
                for(Character ch: map)
                    System.out.print(ch);
                System.out.println();
            }
            else
            {
                for(int i=0; i<s.length(); i++)
                {
                    Character ch = new Character(s.charAt(i));
                    if(!map.contains(ch))
                    {        
                        map.add(ch);
                        perm(s, array, depth+1, map);
                        map.remove(ch);
                    }
                } 
            }
        }
    }
    public static void test1()
    {
        Character[] array = {'a', 'b', 'b'};
        int depth = 0;
        Set<String> set = new LinkedHashSet<String>();
        permRepeatingChar(array, depth, set);
        for(String item: set)
            System.out.println(item);
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Permu2
{
	public static void main(String args[])
	{
		per("abcd");
	}
	public static void per(String str)
	{
		Vector<String> vet = new Vector<String>();
		if(str != null)
		{
			int len = str.length();
			if(len > 0)
			{
				vet.add(str.charAt(0) + "");
				Vector<String> vet2 = new Vector<String>();
				for(int j = 1; j < len; j++)
				{
					for(int i = 0; i < vet.size(); i++)
					{
						Vector<String> vet1 = new Vector<String>();
						vet1 = Combin2(vet.get(i), str.charAt(j) + "");	

						for(int k=0; k<vet1.size(); k++)
							vet2.add(vet1.get(k));
					}	
					vet.clear();

					for(int x=0; x<vet2.size(); x++)
						vet.add(vet2.get(x));
					vet2.clear();

				}
				for(int i = 0; i < vet.size(); i++)
				{
					System.out.println(vet.get(i));
				}
			}
		}	
	}

	public static Vector<String>  Combin2(String str, String ch)
	{
		Vector<String> vet = new Vector<String>();
		for(int i = 0; i < str.length() + 1; i++)
		{
			StringBuffer sb = new StringBuffer(str);
			sb.insert(i, ch);
			vet.add(sb.toString());
		}
		return vet;
	}
	public static Vector<String>  Combin(String str, String ch)
	{
		Vector<String> vet = new Vector<String>();
		int i = 0;
		for(i = 0; i < str.length() + 1; i++)
		{
			String s = "";
			for(int j = 0; j < str.length(); j++)
			{
				if(i == j)
					s = s + ch; 
				s = s + str.charAt(j);
			}	
			if(i == str.length())
				s = s+ch;
			System.out.println (s);
		}
		return vet;
	}
}
import java.io.*;
import java.util.*;

//a1b -> a1b, A1b, a1B, A1B
//permut upper and lower cases

class PermuBin
{
	public static void main(String args[])
	{
		System.out.println("cool");
		Vector<String> v = perm("1");
		for(int i=0; i<v.size(); i++)
			System.out.println(v.get(i));
	}
	public static Vector<String> perm(String str)
	{ Vector<String> v = new Vector<String>();
		Vector<String> vet = new Vector<String>();
		v.add("$");
		if( str != null && str.length() > 0)
		{ 
			for(int j=0; j<str.length(); j++)
			{
				char ch = str.charAt(j);
				for(int i=0; i<v.size(); i++)
				{ String s="";
					if('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z')			
					{ if(j != 0 || i != 0)
						{
							s = v.get(i) + Character.toUpperCase(ch); 
							vet.add(s);
							s = v.get(i) + Character.toLowerCase(ch); 
							vet.add(s);
						}
						else
						{ 
							vet.add(Character.toUpperCase(ch)+"");
							vet.add(Character.toLowerCase(ch)+"");
						}
					}
					else
					{ if(j != 0 || i != 0)
						{ s = v.get(i) + ch; 
							vet.add(s);
						}
						else
						{ s = ch + ""; 
							vet.add(s);
						}
					}
				}
				v.clear();
				for(int i=0; i<vet.size(); i++)
					v.add(vet.get(i));
				vet.clear();
			}
		}
		return v;
	}
}
public class PermutationPrefix {
    public static void main(String[] args) {
        permute("", "abc");
    }
    public static void permute(String prefix, String s) {
        if(s.length() == 0)
            System.out.println(prefix);
        else {
            for(int i=0; i< s.length(); i++) {
                permute(prefix + (s.charAt(i) + ""), remove(s, i));
            }
        }
    }
    public static String remove(String s, int index) {
        String ret = "";
        for(int i=0; i<s.length(); i++) {
            if(i != index)
                ret += s.charAt(i) + "";
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class Pi{
    public static void main(String[] args) {
        test0();
        test1();
    }

    public static double calculatePI(int nStep){
       double pi = 1.0;
       for(int i=1; i<nStep; i++){
           if(i % 2 == 1)
               pi += (double)-1/(2*i + 1);
           else
               pi += (double)1/(2*i + 1);
       } 
       Print.pbl(4*pi);
       return 4*pi;
    }
    public static void test0(){
        Aron.beg();
        int nStep = 1000;
        calculatePI(nStep);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class Pill{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();
        int x = 4;
        int y = 5;
        pill(x, y);
        Aron.end();
    }
    static void pill(int x, int y){
        if(x > 0 && y > 0){
            System.out.println("[" + x + " " + (y-1) + "]"); 
            pill(x, y-1);
            System.out.println("[" + (x-1) + " " + y + "]"); 
            pill(x-1, y);
        }
    }
} 
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class PreOrderToTree 
{
	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();
		
		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);
		/*
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
		*/

		Node r = b1.getRoot();
		//PreOrder(r);

		int[] Arr = {10, 1, 12};
		ArrayList<Integer> leftArr = new ArrayList<Integer>();
		ArrayList<Integer> rightArr = new ArrayList<Integer>();

		//splitInOrder(Arr, leftArr, rightArr);

		Node myroot= PreOrderToTree(Arr);
		PreOrder(myroot);
	}
	
	public static Node PreOrderToTree(int[] Arr)
	{
		ArrayList<Integer> leftList = new ArrayList<Integer>();
		ArrayList<Integer> rightList = new ArrayList<Integer>();
		Node root=null;
		if(Arr != null && Arr.length > 0)
		{
			root = new Node(splitInOrder(Arr, leftList, rightList));

			int[] leftArr = new int[leftList.size()];
			int[] rightArr = new int[rightList.size()];
			for(int i=0; i<leftList.size(); i++)
				leftArr[i] = leftList.get(i);

			for(int i=0; i<rightList.size(); i++)
				rightArr[i] = rightList.get(rightList.size()-1 - i); //keep the order: [root] [ left subtree] [ right subtree]

			root.left = PreOrderToTree(leftArr);	
			root.right = PreOrderToTree(rightArr);
		}
		return root;
	}
	public static int splitInOrder(int[] Arr, ArrayList<Integer> leftList, ArrayList<Integer> rightList)
	{
		int rootNum=0;
		if( Arr != null && Arr.length > 0 && leftList != null && rightList != null)
		{
			int len = Arr.length;
			rootNum = Arr[0];

			if( len > 1)
			{
				int i=1;
				int j=len-1;

				int nl = 0, nr = 0;
				while(i <= j)
				{
					while(i < len && rootNum > Arr[i]) 
						leftList.add(Arr[i++]); 

					while(j > 0 && rootNum < Arr[j])
						rightList.add(Arr[j--]);
				}
				
				for(i=0; i<leftList.size(); i++)
				{ System.out.println(leftList.get(i)); }

				System.out.println(); 
				for(i=0; i<rightList.size(); i++)
				{ System.out.println(rightList.get(i)); }
			}
		}
		return rootNum;
	}
	public static void PreOrder(Node root)
	{
		if(root != null)
		{
			System.out.println("pre=" + root.data);
			PreOrder(root.left);
			PreOrder(root.right);
		}
	}
}
import java.io.IOException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;
import java.util.*;

import classfile.*;

           
//         4
//      2     5
//    1   3
//    pre [4 2 1 3 5]
//    post[1 3 2 5 4]
//
//[test0]
//--------------------------------------------------------------------------
//[4][2][1][3][5]
//--------------------------------------------------------------------------
//[1][3][2][5][4]
//--------------------------------------------------------------------------
//----------------------------------------------------------------------------------------
public class PrePostTree{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();
        List<Integer> preList = Arrays.asList(4, 2, 1, 3, 5);
        List<Integer> postList = Arrays.asList(1, 3, 2, 5, 4);

        Node r = buildTreePrePost(preList, postList);
        Aron.preorder(r);
        Ut.l();
        Aron.postorder(r);
        Ut.l();
        Aron.end();
    }

//pre order [r][left][right]
//post order[left][right][r]

// [1, 2, 3, 4]
    public static Node buildTreePrePost(List<Integer> preList, List<Integer> postList) {
        Node parent = null;
        if(preList != null || postList != null) {
            if(preList.size() == postList.size() && preList.size() > 0) {
                parent = new Node(preList.get(0));
                List<Integer> subPreList = preList.subList(1, preList.size());
                List<Integer> subPostList = postList.subList(0, postList.size()-1);
                if(subPreList.size() == subPostList.size() && subPreList.size() > 0) {
                    Integer subRoot = subPreList.get(0);
                    List<Integer> leftPostList  = postLeft(subPostList, subRoot);
                    List<Integer> rightPostList = postRight(subPostList, subRoot);
                    List<Integer> leftPreList   = preLeft(subPreList, rightPostList);
                    List<Integer> rightPreList  = preRight(subPreList, leftPostList);
                    parent.left = buildTreePrePost(leftPreList, leftPostList);
                    parent.right = buildTreePrePost(rightPostList, rightPostList);
                }
            }
        }
        return parent;
    }
    public static List<Integer> preRight(List<Integer> list, List<Integer> leftList) {
        List<Integer> rightList = new ArrayList<Integer>(); 
        Set<Integer> set = new HashSet<Integer>(leftList);
        for(Integer n: list){
            if(!set.contains(n)){
                rightList.add(n);
            }
        }
        return rightList;
    }
    public static List<Integer> preLeft(List<Integer> list, List<Integer> rightList) {
        List<Integer> leftList = new ArrayList<Integer>(); 
        Set<Integer> set = new HashSet<Integer>(rightList);
        for(Integer n: list){
            if(!set.contains(n)){
                leftList.add(n);
            }
        }
        return leftList;
    }

    public static List<Integer> postRight(List<Integer> list, Integer r) {
        List<Integer> rightList = new ArrayList<Integer>(); 
        boolean equal = false;
        for(Integer n : list) {
            if(equal)
                rightList.add(n);

            if(n.intValue() == r.intValue())
                equal = true;
        }
        return rightList;
    }
    public static List<Integer> postLeft(List<Integer> list, Integer r) {
        List<Integer> leftList = new ArrayList<Integer>(); 
        for(Integer n : list) {
            if(n.intValue() != r.intValue())
                leftList.add(n);
        }
        return leftList;
    }
}


import java.util.*;

class Node {
    Node next;
    String key;
    String word;
    public Node(String key, String word) {
        this.key = key;
        this.word = word;
    }
}

public class PrefixMap {
    public static void main(String[] args) {
        test1();
        test2();
    }
    public static void test1() {
        String s = "abc";
        for(int i=0; i<s.length(); i++) {
            String str = s.substring(0, i+1);
            System.out.println("str="+str);
        }
    }
    public static void test2() {
        String str = "My dog is god and done what the hell is going on yep this sucks what the hell is going on yep this sucks";
        String[] array = str.split(" ");
        List<String> list = Arrays.asList(array);
        Map<String, Node> map = buildMap(list);
        for(String key:map.keySet()) {
            Node curr = map.get(key);
            System.out.print("{"+key+"}");
            while(curr != null) {
                System.out.print("->["+curr.word+"]");
                curr = curr.next;
            }
            System.out.println();
        }
    }
    public static Map<String, Node> buildMap(List<String> list) {
        Map<String, Node> map = new HashMap<String, Node>();
        for(String word:list) {
            prefixWord(word, map);
        }
        return map;
    }
    public static void prefixWord(String word, Map<String, Node> map) {
        for(int i=0; i<word.length(); i++) {
            String key = word.substring(0, i+1);
            if(map.containsKey(key)) {
                Node curr = map.get(key);
                Node prev = null;
                while(curr != null) {
                    if(curr.word.equals(word))
                        break;
                    else {
                        prev = curr;
                        curr = curr.next;
                    }
                }
                if(curr == null)
                    prev.next = new Node(key, word);
            } else {
                map.put(key, new Node(key, word));
            }
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class PreorderIteration
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();


		b1.Insert(15);
		
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
		
		
		PreorderIteration(b1.getRoot());
		System.out.println();
		Inorder(b1.getRoot());
	}
	//in order traversal using iteration
	public static void InorderIteration(Node r)
	{
		Stack<Node> st = new Stack<Node>();
		Node cur = r;

		if( cur != null)
		{ 
			while(!st.empty() || cur != null)
			{
				if(cur != null)
				{
					st.push(cur);
					cur = cur.left;
				}
				else 
				{ Node no = st.pop();
					System.out.println("no.data=" + no.data);
					cur = no.right;
				}
			}
		}
	}

	public static void PreorderIteration(Node r)
	{
		Stack<Node> st = new Stack<Node>();
		Node cur = r;

		if( cur != null)
		{ 
			while(!st.empty() || cur != null)
			{
				if(cur != null)
				{
					System.out.println("cur.data=" + cur.data);
					st.push(cur);
					cur = cur.left;
				}
				else 
				{ Node no = st.pop();
					cur = no.right;
				}
			}
		}
	}	
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

class PrettyBinPrint {
    public static Node prev = null;
    public static void main(String args[]) {
       test0(); 
       //test1(); 
    }
    
    static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(14);
        b1.insert(17);
        b1.insert(19);

        b1.insert(16);
        b1.insert(10);
//        b1.insert(18);
//        b1.insert(60);
//        b1.insert(2);
//        b1.insert(8);
//        b1.insert(70);

        int[] Arr = new int[100];
        int len=0;
        Node r = b1.root;

        Aron.levelOrder(r); 

        System.out.println(contain(r, 15));
        System.out.println();
        int indent=1;
        Aron.prettyPrint(r, indent);
        System.out.println();

        Aron.binImage(r);
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);

        int[] arr = new int[20]; 
        int index = 0;
        Aron.printAllPath(b1.root, arr, index); 

        Aron.binImage(b1.root);
        Aron.end();
    } 

    public static int MaxDepth(Node r) {
        if( r != null) {
            int nl = MaxDepth(r.left);
            int nr = MaxDepth(r.right);

            return (nl>nr?nl:nr)+1;
        }
        return 0;
    }

    public static boolean contain(Node r, int value) {
        if( r != null) {
            if(contain(r.left, value))
                return true;
            if(r.data == value)
                return true;
            if(contain(r.right, value))
                return true;
        }
        return false;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class PreviousNumberBin{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test_next();
    }
    public static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 7;
        Node prev = null;
        Print.pbl("curr=" + n);
        previous(b1.root, n, prev);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 1;
        Node prev = null;
        Print.pbl("curr=" + n);
        previous(b1.root, n, prev);
        Aron.end();
    }

    public static void test2(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 15;
        Node prev = null;
        Print.pbl("curr=" + n);
        previous(b1.root, n, prev);
        Aron.end();
    }

    // print previous number, previous element, previous node 
    // previous num in binary tree, previous n in binary tree, previous n in binarytree
    // microsoft interview, ms inerview, MS interview
    public static boolean previous(Node r, int n, Node prev){
        if( r != null){
            if(previous(r.left, n, prev))
                return true;
            if(r.data == n){
                if(prev == null)
                    Print.pbl(-1);
                else
                    Print.pbl(prev.data);
                return true;
            }
            if(previous(r.right, n, r))
                return true;
        }
        return false;
    }
    
    static void test_next(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 5;
        if(!next(b1.root, n)){
            Print.pp("null");
        }

        Aron.end();
    }

    // print the next node, next node,
    // next node from binary tree, next node binary tree
    static Node nextNode = null;
    public static boolean next(Node r, int n){
        if(r != null){
            if(next(r.left, n))
               return true;

            if(nextNode != null){
                Print.pb("next node=" + r.data);
                return true;
            }

            if(r.data == n){
                nextNode = r;
            }

            if(next(r.right, n))
                return true;
        }
        return false;
    }
} 

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 
import classfile.*;

public class Prime {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        long startTime = System.currentTimeMillis();
        Prime(100000);
        long endTime = System.currentTimeMillis();
        long diff = endTime - startTime;
        System.out.println("diff=" + diff);
    }
    

    //Find all the primes from 2 to n
    public static void Prime(int n) {
        boolean[] prime = new boolean[n];
        for(int i=0; i<n; i++)
            prime[i] = true;

        for(int i=2; i<n; i++) {
            for(int j=2; j<i && prime[i]; j++) {
                if(prime[j] && (i % j) == 0)
                    prime[i] = false;
            }
        }
        for(int i=2; i<n; i++) {
            System.out.println("[" + i + "]=" + prime[i]);
        }
    }

    // generate n primes
    public static List<Integer> nPrime(int n) {
        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        int count = 1;
        int num = 3;
        while(count <= n) {
            boolean isPrime = true;
            for(Integer p : list) {
                if(num % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime) {
                list.add(num);
                count++;
            }
            num++;
        }
        return list;
    }
    //[ file=allprime.html title=""
    // generate all prime are up to n
    public static List<Integer> allPrime(int n) {
        List<Integer> list = new ArrayList<Integer>();
        if(n > 1) {
            list.add(2);
            for(int i=3; i<=n; i++) {
                boolean isPrime = true;
                for(int j=0; j<list.size() && isPrime; j++) {
                    if(i % list.get(j) == 0)
                        isPrime = false;
                }
                if(isPrime)
                    list.add(i);
            }
        }
        return list;
    }
    //]

    //[file=checkprime.html title=""
    public static boolean prime(int d, int n) {
        if(n == 2)
            return true;
        else if(n % d == 0)
            return false;
        else if(d*d <= n)
            return prime(d+1, n);
        else
            return true;
    }
    public static boolean isPrimeLoop(int n) {
        if( n == 2)
            return true;
        for(int d=2; d*d <= n; d++) {
            if(n % d == 0)
                return false;
        }
        return true;
    }
    //]
}
public class PrintTriangle 
{
    public static void main(String[] args)
    {
        int array[][] = new int[][]{
        { 0, 2, 3, 4, 5 },
        { 0, 0, 1, 2, 9 },
        { 0, 0, 0, 6, 5 },
        { 0, 0, 0, 0, 7 },
        { 0, 0, 0, 0, 0 }
        };
        System.out.println("Hello World!");
        int depth = 0;
        int max = Triangle(array, 0, 0);
        System.out.println("max="+max);
    }
    public static int Triangle(int[][] array, int row, int depth)
    {
        int max = 0;
        if(array != null)
        {
            int height = array.length;
            int width  = array[0] != null ? array[0].length : 0;
            //System.out.println("height="+height);
            //System.out.println("width ="+width);
            if(depth < width)
            {
                for(int i=0; i<width; i++)
                {
                    if(row < height && array[depth][i] != 0 && i != row)
                    {
                        int m = Triangle(array, i, depth+1) + array[depth][i];
                        max = max < m? m : max; 
                        System.out.println("["+depth+"]["+i+"]="+array[depth][i]);
                    }
                }
            }
        }
        return max;
    }
}
import java.util.*;
import classfile.*;

// priority heap compareto compareTo heapify heap
//[ file=priorityheap.html title=""
class Contact implements Comparable<Contact> {
    String name;
    String addr;
    int    age;
    public Contact(String name, String addr, int age) {
        this.name = name;
        this.addr = addr;
        this.age = age;
    }

    //Minimum heap
    public int compareTo(Contact c) {
        return this.age - c.age;
        //Maximum heap
        //return -(this.age - c.age);
    }

    public String toString() {
        return "["+name+"]["+addr+"]["+age+"]";
    }
}

public class PriorityQueueHeap {
    public static void main(String[] args) {
        test1();
    }
    public static void test1() {
        System.out.println("Minimum/Maximum Heap PriorityQueue");
        PriorityQueue<Contact> miniHeap = new PriorityQueue<Contact>();
        miniHeap.add(new Contact("David", "U.S", 3));
        miniHeap.add(new Contact("John", "U.S", 4));
        miniHeap.add(new Contact("Johnny", "U.S", 2));
        miniHeap.add(new Contact("Nathan", "U.S", 1));

        int k = 3;
        while(k > 0) {
            Print.p(miniHeap.remove().toString());
            k--;
        }
    }
}
//]
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.LineIterator;
import classfile.*;

// parse CVS file
public class ProcessCVS{
    public static void main(String[] args) {
        test0();
        //test1();
        //writeCrapToFile();
    }

    public static void test0() {
        long ti, tf;
        ti = System.currentTimeMillis();
        //String cvsFile = "/Users/cat/myfile/github/java/text/acl.cvs";
        String cvsFile = "/Users/cat/myfile/github/java/text/big.txt";
        String outFile = "/Users/cat/myfile/github/java/text/acl_out.txt";
        convertCVS(cvsFile, outFile);
        tf = System.currentTimeMillis();
        Print.pbl("Finish. Total time:" + (tf - ti)/1000.00); 
    }
    public static void test1() {
        long ti, tf;
        ti = System.currentTimeMillis();
        //String cvsFile = "/Users/cat/myfile/github/java/text/acl.cvs";
        String cvsFile = "/Users/cat/myfile/github/java/text/big.txt";
        String outFile = "/Users/cat/myfile/github/java/text/acl_out.txt";
        convertCVSList(cvsFile, outFile);
        tf = System.currentTimeMillis();
        Print.pbl("Finish. Total time:" + (tf - ti)/1000.00); 
    }

    public static String leftPad(String str, int max, int len) {
        int diff = max - len;
        if(diff > 0) {
            for(int i=0; i<diff; i++)
                str = " " + str;
        }
        return str;
    }
    public static String rightPad(String str, int max, int len) {
        int diff = max - len;
        if(diff > 0) {
            for(int i=0; i<diff; i++)
                str += " ";
        }
        return str;
    }

    // if str is a string, strim two double quotes. O.W return null
    public static String getString(String str) {
        if(str != null) {
            Pattern pattern = Pattern.compile("\"([^\"]*)\"");
            Matcher matcher = pattern.matcher(str);
            while(matcher.find()) {
                for(int i=1; i<=matcher.groupCount(); i++) {
                    if(matcher.group(i) != null)
                        return matcher.group(i);
                }
            }
        }
        return null;
    }

    public static int getMax(List<String> list) {
        int max = 0;
        for(String s : list) {
            if(getString(s) != null) {
                int l = s.length() - 2;
                if(l > max)
                    max = l;
            } else {
                if(s.length() > max)
                    max = s.length();
            }
        }
        return max;
    }

    public static void convertCVS(String cvsFile, String outFile) {

        // match string or number/decimal
        Pattern pattern = Pattern.compile("(\"[^\"]*\")|([0-9]*\\.?[0-9]+)");
        List<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();
        FileWriter fstream = null;
        BufferedWriter out = null;

        try {
            fstream = new FileWriter(outFile);
            out = new BufferedWriter(fstream);

            LineIterator it = FileUtils.lineIterator(new File(cvsFile), "UTF-8");
            while (it.hasNext()) {
                String s = it.next();
                Matcher matcher = pattern.matcher(s);
                int len = 0;
                List<String> row = new ArrayList<String>();
                while(matcher.find()) {
                    for(int i=1; i<= matcher.groupCount(); i++) {
                        if(matcher.group(i) != null && matcher.group(i).length() > 0) {
                            len = matcher.group(i).length();

                            String ss = matcher.group(i);
                            if(getString(ss) != null) {
                                // ss is string 
                                String str1 = ss.replace("\\r\\n", " ");
                                row.add(str1);
                            } else {
                                // ss is number or decimal 
                                row.add(matcher.group(i));
                            }
                        }
                    }
                }
                int max = getMax(row);

                for(int i=0; i<row.size(); i++){
                    String item = row.get(i);
                    String newStr = getString(item);
                    if(newStr != null) {
                        String paddedStr = rightPad(newStr, max, newStr.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }else{
                        String paddedStr = leftPad(item, max, item.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }
                }
                out.write("\r\n");
            }

            out.close();
        } catch(IOException e) {
            System.err.println(e.getMessage());
        }
    }

    public static void convertCVSList(String cvsFile, String outFile) {

        // match string or number/decimal
        Pattern pattern = Pattern.compile("(\"[^\"]*\")|([0-9]*\\.?[0-9]+)");
        List<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();
        FileWriter fstream = null;
        BufferedWriter out = null;

        try {
            fstream = new FileWriter(outFile);
            out = new BufferedWriter(fstream);

            List<String> list = Aron.readFile(cvsFile);
            for(String s : list) {
                Matcher matcher = pattern.matcher(s);
                int len = 0;
                List<String> row = new ArrayList<String>();
                while(matcher.find()) {
                    for(int i=1; i<= matcher.groupCount(); i++) {
                        if(matcher.group(i) != null && matcher.group(i).length() > 0) {
                            len = matcher.group(i).length();

                            String ss = matcher.group(i);
                            if(getString(ss) != null) {
                                // ss is string 
                                String str1 = ss.replace("\\r\\n", " ");
                                row.add(str1);
                            } else {
                                // ss is number or decimal 
                                row.add(matcher.group(i));
                            }
                        }
                    }
                }
                int max = getMax(row);

                for(int i=0; i<row.size(); i++){
                    String item = row.get(i);
                    String newStr = getString(item);
                    if(newStr != null) {
                        String paddedStr = rightPad(newStr, max, newStr.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }else{
                        String paddedStr = leftPad(item, max, item.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }
                }
                out.write("\r\n");
            }

            out.close();
        } catch(IOException e) {
            System.err.println(e.getMessage());
        }
    }
    public static void writeCrapToFile(){
        String fname = "./text/big.txt";
        List<String> list = new ArrayList<String>(); 
        for(int i=0; i<100000; i++){
            list.add("\"dog cat\"" + "," + "12334" + "," + "341.44" + "\n");
        } 
       Aron.writeFile(fname, list);
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

interface Publisher{
    public void publish(String msg);
}

class News implements Publisher{
    HashSet<Subscriber> set = new HashSet<Subscriber>();
    public void publish(String msg){
        for(Subscriber s : set){
            s.msgList.add(msg);
        }
    }

    public void addSub(Subscriber sub){
        set.add(sub);
    }
}

interface Subscriber{
    public void getPublisher();
}

class User1 implements Subscriber{
    Publisher pub;
    List<String> msgList = new ArrayList<String>();
    public Subscriber(Publisher pub){
        this.pub = pub;
    }
    public void getPublisher(){
        pub.publish();
    }
    public void add(String msg){
        msgList.add(msg);
    }
    public void show(){
        for(String s : msgList){
            Print.p(msg);
        }
    }
}


public class PublicSubscribe{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

/**
  * solve eight queen problem with backtrack 
  */
public class Queen 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        final int len = 4;
        int[][] board = new int[len][len];
        for(int i=0; i<len; i++)
            for(int j=0; j<len; j++)
                board[i][j] = i*len+j;

        int[] path = new int[len];
        int row = 0;
        queen(board, row, path);
    }
    public static void queen(int[][] board, int row, int[] path)
    {
        if(board != null && board[0] != null)
        {
            int len = board.length;
            for(int col = 0; col < len && row < len; col++)
            {
                if(consistent(path, row, col))
                {
                    path[row] = col;
                    queen(board, row+1, path);
                }
            }

            if(row == len)
            {
                for(int r=0; r<len; r++)
                {
                    for(int c=0; c<len; c++)
                    {
                        if(path[r] == c)
                            System.out.print("["+"x"+"]");        
                        else
                            System.out.print("["+"0"+ "]");        

                    }
                    System.out.println("");        
                }
                System.out.println("");        
            }
        }
    }
    public static boolean consistent(int[] path, int currentRow, int currentCol) 
    {
        boolean ret = true;
        if(path != null)
        {
            int len = path.length;
            for(int row=0; row < currentRow && ret; row++)
            {
                if(path[row] == currentCol)
                    ret = false;
                else if( Math.abs(currentRow - row ) == Math.abs(currentCol - path[row]))
                    ret = false;
            }
        }
        return ret;
    }
}
public class Queen2 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        final int len = 4;
        final int width = 8;
        int[][] board = new int[len][len];
        for(int i=0; i<len; i++)
            for(int j=0; j<len; j++)
                board[i][j] = i*len+j;

        int[][] path = new int[width][2];
        int depth = 0;
        queen(path, width, depth);

    }
    public static boolean consistent(int[][] path, int width, int depth, int newRow)
    {
        if(path != null)
        {
            for(int i = 0; i < depth; i++)
            {
                int currCol = path[i][0];
                int currRow = path[i][1];
                if(currRow == newRow)
                    return false;
                else if(Math.abs(depth - currCol ) ==Math.abs(newRow - currRow))
                    return false;
            }
        }
        return true;
    }
    public static void queen(int[][] path, int width, int depth)
    {
        if(depth == width)
        {
            for(int i=0; i < depth; i++)
                System.out.println("["+path[i][0]+"]["+path[i][1]+"]");
            System.out.println("");
        }
        else 
        {
            for(int row=0; row < width; row++)
            {
                if(consistent(path, width, depth, row)) 
                {
                    path[depth][0] = depth;
                    path[depth][1] = row;
                    queen(path, width, depth+1);
                }
            }
        }
    }
}
import java.io.*;
import java.util.*;

//quick sort algorithm
class QuickSort 
{
	public static void main(String args[])
	{
        Test1();
        Test2();
        Test3();
        Test4();
        Test5();
	}
    public static void Test1()
    {
        System.out.println("test case1:");
		int[] Arr = {100};
		int left = 0;
		int right = Arr.length-1;
		QuickSort(Arr, left, right);
		for(int i=0; i<Arr.length; i++)
			System.out.println("Arr[" + i + "]=" + Arr[i]);
    }
    public static void Test2()
    {
        System.out.println("test case2:");
		int[] Arr1 = {100, 1};
		int left = 0;
		int right = Arr1.length-1;
		QuickSort(Arr1, left, right);
		for(int i=0; i<Arr1.length; i++)
			System.out.println("Arr1[" + i + "]=" + Arr1[i]);
    }
    public static void Test3()
    {
		System.out.println("test case3:");
		int[] Arr2 = {1, 5};
		int left = 0;
		int right = Arr2.length-1;
		QuickSort(Arr2, left, right);
		for(int i=0; i<Arr2.length; i++)
			System.out.println("Arr2[" + i + "]=" + Arr2[i]);
    }
    public static void Test4()
    {
        System.out.println("test case4:");
		int[] Arr3 = {100, 1, 7, 6};
		//int[] Arr3 = {100, 1, 3, 9, 6, 5, 7};
		//int[] Arr3 = {9, 1, 2, 4};
		int left = 0;
		int right = Arr3.length-1;
		QuickSort(Arr3, left, right);
		for(int i=0; i<Arr3.length; i++)
			System.out.println("Arr3[" + i + "]=" + Arr3[i]);
    }

    public static void Test5()
    {
        System.out.println("test case5:");
		int[] Arr3 = {1, 7, 5};
		int left = 0;
		int right = Arr3.length-1;
		QuickSort(Arr3, left, right);
		for(int i=0; i<Arr3.length; i++)
			System.out.println("Arr3[" + i + "]=" + Arr3[i]);
    }
    public static void QuickSort(int[] Arr, int left, int right)
    {
        if(left < right)
        {
            int pivot = Partition(Arr, left, right);
            QuickSort(Arr, left, pivot-1);
            QuickSort(Arr, pivot+1, right);
        }
    }

    public static void swap(int[] arr, int left, int right)
    {
        int tmp = arr[left];
        arr[left] = arr[right];
        arr[right] = tmp;
    }
    public static int Partition(int[] arr, int left, int right)
    {
        int prev = left;
        if(arr != null)
        {
            int pivot = arr[right];
            prev = left;
            for(int i=left; i<=right; i++)
            {
                if(arr[i] < pivot)
                {
                    swap(arr, i, prev);
                    prev++;    
                }
            }
            swap(arr, prev, right);
        }
        return prev;
    }
    //partition
	public static int Partition2(int[] Arr, int left, int right)
	{
		int ret = 0;
		if(Arr != null)
		{
			int len = right - left + 1; 
			if(len == 1)
				ret = left;
			else if(len > 1)
			{
				int pivot = Arr[left];
				int i=left;
				int j=right;
				while(i < j)
				{
					while(i < right && Arr[i] <= pivot ) i++;
					while(j > left && Arr[j] > pivot) j--;
					if(i<j)
					{ int tmp = Arr[i];
						Arr[i] = Arr[j];
						Arr[j] = tmp;
					}
				}
				int t = Arr[left];
				Arr[left] = Arr[j];
				Arr[j] = t;
				ret = j;
			}
		}
		return ret;
	}
}
import java.util.*;

public class QuickSortLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Try it");
        SLL s1 = new SLL();
        SLL s2 = new SLL();
        SLL s3 = new SLL();
        s1.append(2);
        s1.append(20);
        s1.append(30);
        s1.append(40);
        s1.append(50);

        System.out.println("================");
        show(s1.getHead());
        System.out.println("================");
        Node mnode = partition(s1.getHead());
        show(s1.getHead());
        System.out.println("================");
        show(mnode);
        System.out.println("================");

        Node node = median(s1.getHead());
        System.out.println("median["+node.data+"]");

        s2.append(1);
        s2.append(7);
        s2.append(10);

        s3.append(3);
        s3.append(4);
        s3.append(20);

        Node s =  mergeList(mergeList(s1.getHead(), s2.getHead()), s3.getHead());
        show(s);
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
    public static void show(Node curr)
    {
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }

    public static void test4()
    {
        System.out.println("begin test4==================");
        SLL s1 = new SLL();
        
        s1.append(2);
        s1.append(40);
        s1.append(100);
        
        s1.append(50);
        
        s1.append(30);
        
        s1.append(20);
        s1.append(1);
        s1.append(6);
        s1.append(20);
        s1.append(2);
        
        System.out.println("----------------------------");
        show(s1.getHead());
        System.out.println("----------------------------");

        Node[] prev = new Node[1];
        prev[0] = null;
        qsLinkedList(s1.getHead(), s1.getTail(), prev);
        show(s1.getHead());
        System.out.println("begin test4==================");
    }

    public static void test5()
    {
        System.out.println("begin test4==================");
        SLL s1 = new SLL();
        
        s1.append(1);
        s1.append(2);
        s1.append(3);
        
        System.out.println("----------------------------");
        show(s1.getHead());
        System.out.println("----------------------------");

        Node[] prev = new Node[1];
        prev[0] = null;
        qsLinkedList(s1.getHead(), s1.getTail(), prev);
        show(s1.getHead());
        System.out.println("begin test5==================");
    }

    public static void test6()
    {
        System.out.println("begin test6==================");
        SLL s1 = new SLL();
        
        s1.append(30);
        s1.append(20);
        s1.append(10);
        
        System.out.println("----------------------------");
        show(s1.getHead());
        System.out.println("----------------------------");

        Node[] prev = new Node[1];
        prev[0] = null;
        qsLinkedList(s1.getHead(), s1.getTail(), prev);
        show(s1.getHead());
        System.out.println("begin test4==================");
    }

    public static void test2()
    {
        System.out.println("begin test2()================");
        SLL s1 = new SLL();
        s1.append(4);
        s1.append(8);
        show(s1.getHead());

        Node[] prev = new Node[1];
        prev[0] = null;
        Node pivot = qsPartition(s1.getHead(), s1.getTail(), prev);
        System.out.println("pivot=["+pivot.data+"]");
        System.out.println("================");
        show(s1.getHead());
        System.out.println("end test1()================");
    }

    public static void test3()
    {
        System.out.println("begin test3()================");
        SLL s1 = new SLL();
        s1.append(4);
        show(s1.getHead());

        Node[] prev = new Node[1];
        prev[0] = null;
        Node pivot = qsPartition(s1.getHead(), s1.getTail(), prev);
        if(pivot != null)
            System.out.println("pivot=["+pivot.data+"]");
        System.out.println("================");
        show(s1.getHead());
        System.out.println("end test3()================");
    }
    public static void test1()
    {
        System.out.println("begin test2()================");
        SLL s1 = new SLL();
        s1.append(4);
        s1.append(8);
        s1.append(3);
        s1.append(6);
        s1.append(5);
        show(s1.getHead());

        Node[] prev = new Node[1];
        prev[0] = null;
        Node pivot = qsPartition(s1.getHead(), s1.getTail(), prev);
        System.out.println("pivot=["+pivot.data+"]");
        System.out.println("================");
        show(s1.getHead());
        System.out.println("end test1()================");
    }
    public static void swap(Node first, Node second)
    {
        int tmp = first.data;
        first.data = second.data;
        second.data = tmp;
    }
    public static void qsLinkedList(Node head, Node tail, Node[] prev)
    {
        Node h = head;
        Node t = tail;
        Node pivot = qsPartition(h, t, prev); 
        Node myh = h;
        Node myt = t;
        while(myh != null)
        {
            System.out.println("myh["+myh.data+"]");
            if(myh != myt)
                myh = myh.next;
            else
                break;
        }
        if(head != tail)
        {
            if(pivot != null)
                System.out.println("pivot["+pivot.data+"]");
            if(prev[0] != null)
                System.out.println("prev["+prev[0].data+"]");
            if(h != null)
                System.out.println("h["+h.data+"]");
            if(t != null)
                System.out.println("t["+t.data+"]");
            System.out.println("-----------------------");
            
            //if(h != null && prev[0] != null)
            if(h != pivot)
                qsLinkedList(h, prev[0], prev); 
            if(pivot != t)
                qsLinkedList(pivot.next, t, prev);
        }
    }
    public static Node qsPartition(Node head, Node tail, Node[] prev)
    {
        Node curr = head;
        Node big = curr;
        Node pivot = tail;
        if(head == tail)
        {
            System.out.println("head{"+head.data+"}");
            System.out.println("tail{"+tail.data+"}");
            System.out.println("pivot{"+pivot.data+"}");
            prev[0] = null;
            return null;    
        }
        else
        {
            while(curr != null)
            {
                if(curr.data < pivot.data)
                {
                    swap(curr, big);
                    prev[0] = big;
                    System.out.println("prev{"+prev[0].data+"}");
                    big = big.next;
                }                
                curr = curr.next;
            }
            if(big != null)
                swap(pivot, big);
            return big;
        }
    }
    public static Node partition(Node head)
    {
        Node mnode = median(head);
        if(mnode != null)
        {
            Node ret = mnode.next;
            mnode.next = null;
            return ret;
        }
        else
            return mnode;
    }
    public static Node median(Node head)
    {
        Node curr = head;
        Node mcurr = curr;
        if(curr != null)
        {
            while(curr.next != null)
            {
                curr = curr.next.next;
                if(curr == null)
                    break;
                mcurr = mcurr.next;
            }
        }
        return mcurr;
    }
    public static int[] merge(int[] arr1, int[] arr2)
    {
        int[] arr = null; 
        if(arr1 == null)
            return arr2;
        else if(arr2 == null)
            return arr1;
        else 
        {
            int len1 = arr1.length;
            int len2 = arr2.length;
            arr = new int[len1+len2];
            int inx1 = 0;
            int inx2 = 0;
            int k=0;

            while(inx1 < len1 || inx2 < len2)
            {
                if(inx1 >= len1)
                {
                    arr[k] = arr1[inx2];
                    inx2++;
                }
                else if(inx2 >= len2)
                {
                    arr[k] = arr2[inx1];
                    inx1++;
                }
                else
                {
                    if(arr1[inx1] < arr2[inx2])
                    {
                        arr[k] = arr1[inx1];
                        inx1++;
                    }
                    else
                    {
                        arr[k] = arr2[inx2];
                        inx2++;
                    }
                }
                k++;
            }
        }
        return arr;
    }
    public static Node mergeList(Node s1, Node s2)
    {
        Node curr = null;
        Node head = curr;
        while( s1 != null || s2 != null)
        {
            if(s1 == null)
            {
                if(curr == null)
                   head = curr = s2;
                else
                {
                    curr.next = s2;
                    curr = curr.next;
                }
                s2 = s2.next;
            }
            else if(s2 == null)
            {
                if(curr == null)
                    head = curr = s1;
                else
                {
                    curr.next = s1;
                    curr = curr.next;
                }
                s1 = s1.next;
            }
            else
            {
                if(s1.data < s2.data)
                {
                    if(curr == null)
                        head = curr = s1;
                    else
                    {
                        curr.next = s1;
                        curr = curr.next;
                    }
                    s1 = s1.next;
                }
                else
                {
                    if( curr == null)
                        head = curr = s2;
                    else
                    {
                        curr.next = s2;
                        curr = curr.next;
                    }
                    s2 = s2.next;
                }
            }
        }
        return head;
    }
}
	public static int Partition2(int[] Arr, int left, int right)
	{
		int ret = 0;
		if(Arr != null)
		{
			int len = right - left + 1; 
			if(len == 1)
				ret = left;
			else if(len > 1)
			{
				int pivot = Arr[left];
				int i=left;
				int j=right;
				while(i < j)
				{
					while(i < right && Arr[i] <= pivot ) i++;
					while(j > left && Arr[j] > pivot) j--;
					if(i<j)
					{ int tmp = Arr[i];
						Arr[i] = Arr[j];
						Arr[j] = tmp;
					}
				}
				int t = Arr[left];
				Arr[left] = Arr[j];
				Arr[j] = t;
				ret = j;
			}
		}
		return ret;
	}
public class Quine {
  public static void main(String[] args) {
    System.out.printf("public class Quine {\n public static void main(String[] args) {\n System.out.printf(");
  }
}

import java.util.Random;

public class RandomNumber
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] array = RandomNum(1, 10);
        Aron.printArray(array);
    }
    // generate 0 - [n-1]
    public static int[] RandomNum(int init, int n)
    {   
        int[] array = new int[n]; 
        Random rn = new Random();
        for(int i=0; i<n; i++)
            array[i] = rn.nextInt(n) + init;

        return array;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;

// regex example, regular expression example
// match, case insensitive, case-insensitive, case-sensitive, group, find
// *jregex* *j_regex_example_many*
public class RegexExample{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test10();
        test11();
    }
    static void test0(){
        Aron.beg();
        String pattern = "([a-z]+).([a-zA-Z-]+)(/)";
        String[] strArr = {
            "www.google.com/search?q=goog/nice",
            "www.google.com/search?q=goog",
            "http://www.google.msn.ca/search?q=goog",
            "http://www.google.msn.ca/a/b/c/d"
        };

        Pattern r = Pattern.compile(pattern);
        for(int i=0; i<strArr.length; i++) {
            Matcher mat = r.matcher(strArr[i]);
            if(mat.find()) {
                Print.p("found=" + mat.group(0));
            }
        }

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Pattern r = Pattern.compile("captheorem", Pattern.CASE_INSENSITIVE);
        Matcher mat = r.matcher("CAPTHEOREM");
        if(mat.find()) {
            Print.p("found=" + mat.group(0));
        }
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        //Pattern pattern = Pattern.compile("[0-9]{3}[-]{0,1}[0-9]{3}[-]{0,1}[0-9]{4}");
        Pattern pattern = Pattern.compile("[0-9]{3}[-]?[0-9]{3}[-]?[0-9]{4}");
        Matcher matcher = pattern.matcher("334-4467777 yes... 334666-4456 415-333-9674 whatever 4264491569");
        while(matcher.find()) {
            System.out.println(matcher.group());
        }
        Aron.end();
    } 
    static void test3(){
        Aron.beg();

        // match number
        Pattern pattern = Pattern.compile("\\d+");
        Matcher matcher = pattern.matcher("334-4467777 yes... 334666-4456 415-333-9674 whatever 4264491569");
        while(matcher.find()) {
            System.out.println(matcher.group());
        }
        Aron.end();
    } 
    static void test4(){
        Aron.beg();

        // match number and group
        Pattern pattern = Pattern.compile("\\w+");
        Matcher matcher = pattern.matcher("334-4467777 yes... 334666-4456 415-333-9674 whatever 4264491569");
        while(matcher.find()) {
            System.out.println(matcher.group());
        }
        Aron.end();
    } 
    static void test5(){
        Aron.beg();

        // match number
        Pattern pattern = Pattern.compile("[A-Z]+");
        Matcher matcher = pattern.matcher("This is case insensitive PREPOSITION");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 
    static void test6(){
        Aron.beg();

        // match number
        Pattern pattern = Pattern.compile("[a-zA-Z0-9_]+");
        Matcher matcher = pattern.matcher("This is case_INSENSITIVE PREPOSITION");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 
    static void test7(){
        Aron.beg();

        // excluding a,n, and space
        Pattern pattern = Pattern.compile("[^an ]+");
        Matcher matcher = pattern.matcher("This is banana");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 
    static void test8(){
        Aron.beg();

        // excluding all vowels 
        Pattern pattern = Pattern.compile("[a-z&&[^youiea]]+");
        Matcher matcher = pattern.matcher("show all the words which do not contains vowel");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 
    static void test9(){
        Aron.beg();

        // POSIX character classes \p{Lower}+ => [a-z]+ 
        Pattern pattern = Pattern.compile("\\p{Lower}+");
        Matcher matcher = pattern.matcher("show all the words which do not contains vowel");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 

    // grouping
    static void test10(){
        Aron.beg();
        //import java.util.regex.Matcher;
        //import java.util.regex.Pattern;
        String str = "\"dog cat\" 3241.10 "; 
        Pattern pattern = Pattern.compile("(\"[^\"]*\")|([0-9]*\\.?[0-9]+)");
        Matcher matcher = pattern.matcher(str);
        while(matcher.find()) {
            for(int i=1; i<= matcher.groupCount(); i++) {
                if(matcher.group(i) != null && matcher.group(i).length() > 0) {
                    String ss = matcher.group(i);
                    Print.pbl(ss);
                }
            }
        }

        
        Aron.end();
    }

    public static void test11(){
        Aron.beg();
        
        // match boundary word, match word, match words, match word only
        // boundary word, boundary words only, boundary only, word boundary
        String[] arr = {
            "dog",
            "cat",
            "key-value"
        };
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");
        Aron.printArray(arr);
        for(String s : arr){
            Matcher matcher = pattern.matcher(s);
            if(matcher.find()){
                Print.pbl("match word=" + matcher.group());
            }
        }
        Print.pbl("Does not match key-value");

        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import classfile.*;

public class RegexMatches {
    public static void main( String args[] ) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();
        String pattern = "([a-z]+).([a-zA-Z-]+)(/)";
        String[] strArr = {
            "www.google.com/search?q=goog/nice",
            "www.google.com/search?q=goog",
            "http://www.google.msn.ca/search?q=goog",
            "http://www.google.msn.ca/a/b/c/d"
        };

        Pattern r = Pattern.compile(pattern);
        for(int i=0; i<strArr.length; i++) {
            Matcher mat = r.matcher(strArr[i]);
            if(mat.find()) {
                Print.p("found=" + mat.group(0));
            }
        }

        Aron.end();
    }
    // case insensitive
    static void test1(){
        Aron.beg();
        Pattern r = Pattern.compile("captheorem", Pattern.CASE_INSENSITIVE);
        Matcher mat = r.matcher("CAPTHEOREM");
        if(mat.find()) {
            Print.p("found=" + mat.group(0));
        }
        Aron.end();
    }
}
import java.util.regex.Pattern;
import java.util.regex.Matcher;

// 411-114-3475 whatever  415-3354567 what 665335-9987 cool 6653334467
public class RegexPhone {
    public static void main(String[] args) {

        //Pattern pattern = Pattern.compile("[0-9]{3}[-]{0,1}[0-9]{3}[-]{0,1}[0-9]{4}");
        Pattern pattern = Pattern.compile("[0-9]{3}[-]?[0-9]{3}[-]?[0-9]{4}");
        Matcher matcher = pattern.matcher("334-4467777 yes... 334666-4456 415-333-9674 whatever 4264491569");
        while(matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}

/* output
334-4467777
334666-4456
415-333-9674
4264491569
*/
import Lib.*;

public class Hello
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[][] array2d = new int[3][2];

        System.out.println("array2.length="+array2d.length);
        System.out.println("array2[0].length="+array2d[0].length);

        for(int i=0; i<3; i++)
            array2d[i] = fun();

        for(int i=0; i<3; i++)
        {
            for(int j=0; j<2; j++)
                System.out.print("["+array2d[i][j]+"]");
            System.out.println();
        }

        test1();
        testParition();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
    }

    public static void test8()
    {
        System.out.println("test8"); 
        String str = "abcde";
        int k=0;
        int p=0;
        Integer num = new Integer(0);
        dump(str, k, p, num);
    } 
    public static void test9()
    {
		BST b1 = new BST();
		b1.Insert(15);
		b1.Insert(12);
        Node prev = null;
        boolean isbst = isBST(b1.root, prev);
        System.out.println("isbst=" + isbst);

    } 
    public static void dump(String str, int k, int p, Integer num){
        if(k < str.length()){
            dump(str, k+1, p, num);
        }
        else if(k == str.length()){
            num = new Integer(3); 
            p = 10;
        }
        if(k < str.length())
            System.out.println("charAt [" + k + "]=" + str.charAt(k));
        System.out.println("p=" + p + "  num=" + num);
    }

    public static boolean isBST(Node root, Node prev)
    {
        if( root != null)
        {
            if(!isBST(root.left, prev))
                return false;
            if(prev != null && prev.data >= root.data)
                return false;
            if(!isBST(root.right, root))
                return false;
        }
        return true;
    }

    public static void kdistance(Node r, int k){
        
        if(r != null){
            if(k == 0)
                System.out.println(r.data);
            else{
                kdistance(r.left, k-1);
                kdistance(r.right, k-1);
            }
        }
    }

    public static void test7()
    {
        System.out.println("test7"); 
        int[] arr1 = {3, 1, 4, 6, 2};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test6()
    {
        System.out.println("test6"); 
        int[] arr1 = {3};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test5()
    {
        System.out.println("test5"); 
        int[] arr1 = {3, 2};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test4()
    {
        System.out.println("test4"); 
        int[] arr1 = {2, 3, 2, 3};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    //[file=mergesort1.html title=""
    public static void mergeSort(int[] arr, int lo, int hi){
        if(lo < hi){
            int mid = (lo + hi)/2;
            mergeSort(arr, lo, mid);
            mergeSort(arr, mid+1, hi);
            merge(arr, lo, mid, hi);
        }
    }
    public static void merge(int[] arr1, int lo, int mid, int hi){
        int len = hi - lo + 1; 
        int[] array = new int[len];
        if(len > 1){
            int i = lo;
            int j = mid+1;
            int k = 0;
            while(i <= mid || j <= hi){
                if(i > mid){
                    array[k] = arr1[j];
                    j++;
                }
                else if (j > hi){
                    array[k] = arr1[i];
                    i++;
                }
                else{
                    if(arr1[i] < arr1[j]){
                        array[k] = arr1[i];
                        i++;
                    }else{
                        array[k] = arr1[j];
                        j++;
                    }
                }
                k++;
            }
            for(int x=0; x<len; x++){
                arr1[x+lo] = array[x];
            }
        }
    }
    //]
    public static void testParition()
    {
        System.out.println("testParition"); 
        int[] arr1 = {2, 3};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test2()
    {
        System.out.println("test2"); 
        int[] arr1 = {2, 3};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  
    }
    public static void test3()
    {
        System.out.println("test3"); 
        int[] arr1 = {3, 2, 1, 5, 2, 6};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  
    } 
    public static void test1()
    {
        System.out.println("test1"); 
        int[] arr1 = {2};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  
    } 
    public static void quickSort(int[] arr, int lo, int hi){
        if(lo < hi){
            int p = partition(arr, lo, hi);
            quickSort(arr, lo, p-1);
            quickSort(arr, p+1, hi);
        }
    }
    public static int partition(int[] arr, int lo, int hi){
        int len = hi - lo + 1;
        int bigger = lo;
        if(len > 1){
            int pivot = arr[hi];
            for(int i=lo; i<len; i++){
                if(arr[i] < pivot){  
                    swap(arr, bigger, i);
                    bigger++;
                } 
            }
            swap(arr, bigger, hi);
        }
        return bigger;
    }
    public static void swap(int[] arr, int i, int j){
        int tmp  = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    public static int[] fun()
    {
        int[] array = {1, 2};
        return array;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class RemoveSpace 
{
	public static void main(String args[])
	{
		System.out.println("n=");
		String str = RemoveSpace(" ");
		System.out.println("str=[" + str + "]");
	}
	public static String RemoveSpace(String str)
	{
		String s="";
		if( str != null)
		{
			int len = str.length();
			if(len == 1)
			{ if(str.charAt(0) != ' ')	s = str; }
			else if( len > 1)
			{ String w="";
				if(str.charAt(0) != ' ')
					w = str.charAt(0) + "";
				for(int i=1; i<len; i++)
				{ if(str.charAt(i) != ' ')
						w = w + str.charAt(i);
					else if(str.charAt(i-1) != ' ')
					{ if(s.equals(""))
						{ s = w; w="";}
						else 
						{
							s = s + " " + w;
							w = "";
						}
					}
				}
				if(!w.equals(""))
					s = s + " " + w;
			}
		}
		return s;
	}
}
//[ java regular expression example ]//
//[ java regular expression tutorial ]//

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.HashMap;
import java.util.Map;

public class ReplaceMultiString {
    public static void main( String args[] ) {
        // java regular, java regex, jregex
        Map<String, String> replacements = new HashMap<String, String>() {
            {
                put(":", "colon");
                put("#", "number_sign");
                put("$", "dollar");
            }
        };

        String input = "$dog";

        String regexp = "\\$";
        StringBuffer sb = new StringBuffer();
        Pattern pattern = Pattern.compile(regexp);
        Matcher match = pattern.matcher(input);

        while(match.find()) {
            match.appendReplacement(sb, replacements.get(match.group()));
        }
        match.appendTail(sb);
        System.out.println(sb.toString());
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class ReverseSingleLinkedList {
    public static void main(String args[]) {
        test0();
        test1();
        test2();
    }
    static void test0(){
        Aron.beg();
        SingleLinkedList s = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);

        s.append(n1);
        s.append(n2);
        s.append(n3);
        s.print();
        Node head = ReverseIterationClone(s.head);
        s.Remove(n1);
        s.Remove(n2);
        Print.pbl("Clone and Reverse the list");
        Aron.printSLL(head);
        Ut.l();
        Print.pbl("Original List");
        Aron.printSLL(s.head);
        Aron.end();
    }
    static void test1(){
        Aron.beg();

        SingleLinkedList s = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        s.append(n1);
        s.append(n2);
        s.append(n3);
        s.print();
        Ut.l();
        Node head = Reverse3(s.head);
        Aron.printSLL(head);

        Aron.end();
    }
    static void test2(){
        Aron.beg();

        SingleLinkedList s = new SingleLinkedList();
        Node n1 = new Node(1);
        s.append(n1);
        s.print();
        Ut.l();
        Node head = Reverse3(s.head);
        Aron.printSLL(head);

        Aron.end();
    }
    static Node head = null;
    public static Node Reverse(Node curr) {
        if(curr != null) {
            Node node = Reverse(curr.next);
            if(node != null) {
                node.next = curr;
                curr.next = null;
            } else {
                head = curr;
            }
        }
        return curr;
    }

    public static Node Reverse2(Node curr) {
        Node tmp = null;
        if(curr == null)
            return null;
        else if(curr.next == null)
            return curr;
        else {
            tmp = Reverse2(curr.next);
            curr.next.next = curr;
            curr.next = null;
        }
        return tmp;
    }

    public static Node Reverse3(Node curr) {
        Node tmpHead = null;
        if(curr != null){
            tmpHead = Reverse3(curr.next);
            if(tmpHead == null)
                tmpHead = curr;
            else{
                curr.next.next = curr;
                curr.next = null;
            }
        }
        return tmpHead;
    }
    // Modified the original list
    public static Node ReverseOriginalList(Node head) {
        Node prev = null;
        Node curr = head;
        while(curr != null) {
            Node tmpNext = curr.next;
            curr.next = prev;
            prev = curr;
            curr = tmpNext;
        }
        return prev;
    }
    //Clone the original list and reverse it
    public static Node ReverseIterationClone(Node head) {
        Node curr = head;
        Node prev = null;
        Node newCurr = null;
        Node newPrev = null;
        while(curr != null) {
            newCurr = new Node(curr.data);

            Node newNext = newCurr.next;
            newCurr.next = newPrev;

            newPrev = newCurr;
            newCurr = newNext;
            curr = curr.next;
        }
        return newPrev; //return head
    }
    public static Node ReverseCloneStack(Node mycurr) {
        Stack<Node> st = new Stack<Node>();
        Node curr = mycurr;
        while(curr != null) {
            Print.pbl(curr.data);
            st.push(curr);
            curr = curr.next;
        }
        Ut.l();

        Node head = null;
        Node newPrev = null;
        Node newCurr = null;
        while(!st.isEmpty()) {
            newCurr = new Node(st.pop().data);
            if(newPrev != null)
                newPrev.next = newCurr;
            else
                head= newCurr;
            newPrev = newCurr;
        }
        return head;

    }
    public static Node ReverseClone(Node head) {
        Node curr = head;
        Node prev = null;
        Node newCurr = null;
        Node newPrev = null;
        while(curr != null) {
            newCurr = new Node(curr.data);

            curr.next = prev;
            newCurr.next = newPrev;

            prev = curr;
            curr = curr.next;
            newPrev = newCurr;
            newCurr = newCurr.next;
        }
        return newPrev;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class ReverseStr
{
	public static void main(String args[])
	{
		int i = 0;
		System.out.println("s=" + RevStr("", i));
		System.out.println("s1=" + RevStr("a", i));
		System.out.println("s2=" + RevStr("ab", i));
		System.out.println("s3=" + RevStr("ab ", i));
	}
	public static String RevStr(String str, int i)
	{
		String s="";
		if(str != null)
		{
			if(str.length() == 1)
				s = str;
			else if(str.length() > 1 && i < str.length())
			{
				s = RevStr(str, i+1) + str.charAt(i);
			}
		}
		return s;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class ReverseStrIte
{
	public static void main(String args[])
	{
		int i = 0;
		System.out.println("s3=" + RevStr("ab"));
	}
	public static String RevStr(String str)
	{
		char[] chArr=null;
		if( str != null)
		{
			chArr = str.toCharArray();
			int len = str.length();
			for(int i=0; i<len/2; i++)
			{
				char tmp = chArr[i];
				chArr[i] = chArr[len-1-i];
				chArr[len-1-i] = tmp;
			}
		}
		return new String(chArr);
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class ReverseStrings{
    public static void main(String args[]) {
        test0();
    }
    static void test0(){
        Aron.beg();
        String str = "dog and cat hello world";
        reverseString(str);
        Aron.end();
    }
    public static void reverseString(String str){
        StringBuilder sb = new StringBuilder(str);
        StringBuilder word = new StringBuilder();
        if(str != null){
            int len = str.length();
            for(int i=0; i<len/2; i++){
                char tmp = sb.charAt(i);
                sb.setCharAt(i, sb.charAt(len-1-i));
                sb.setCharAt(len-1-i, tmp);
            }
            Print.pbl(sb.toString());
            String s = "";
            for(int i=0; i<len; i++){
                if(sb.charAt(i) != ' '){
                    word.append(sb.charAt(i));
                }else{
                    Print.pbl(word.reverse());
                    word.delete(0, word.length()); 
                }
            } 
            if(word.length() > 0)
                Print.pbl(word.reverse());
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class ReverseWord
{
	public static void main(String args[])
	{
		int k = 0;
		String s = ReverseWord("", k);
		System.out.println("s=" + s);
	}
	public static String ReverseWord(String str, int k)
	{
		String s = "";
		for(int i = k; i < str.length(); i++)
		{
			if((str.charAt(i)==' ') && !s.equals(""))
			{
				return ReverseWord(str, i+1) + " " + s;
			}
			else if(str.charAt(i) != ' ')
				s = s + Character.toString(str.charAt(i));
		}
		return s;

	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class RotateMatrix90 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
        test1();
		System.out.println();
        test2();
        System.out.println();
        test3();
        System.out.println();
        test4();
	}

	//rotate matrix clockwise 90
	public static int[][] rotateMatrixClockwise90(int[][] A)
	{
		if(A != null)
		{
			int nRow = A.length;
			int nCol = A[0].length;
			for(int k=0; k<nRow/2; k++)
				for(int i=k; i<nRow-1-k; i++)
				{
					int tmp = A[k][i];
					A[k][i] = A[nRow-1-i][k];
					A[nRow-1-i][k] = A[nRow-1-k][nRow-1-i];
					A[nRow-1-k][nRow-1-i] = A[i][nRow-1-k];
					A[i][nRow-1-k] = tmp;
				}
		}
		return A;
	}

	//rotate matrix counterclockwise 90
	public static int[][] rotatecounterclockwise90(int[][] A)
	{
		if( A != null)
		{
			int nRow = A.length;
			int nCol = A[0].length;
			for(int k=0; k<nRow/2; k++)
			{
				for(int i=k; i<nRow-1-k; i++)
				{
					int tmp = A[k][nRow-1-i];
					A[k][nRow-1-i] = A[nRow-1-i][nRow-1-k];
					A[nRow-1-i][nRow-1-k]=A[nRow-1-k][i];
					A[nRow-1-k][i]=A[i][k];
					A[i][k]=tmp;
				}
			}
		}
		return A;
	}

    //Rotate matrix counterclosewise 90 recursively 
    public static void rotatecounterclockwise90Recursion(int[][] arr, int depth)
    {
        if(arr != null)
        {
            int len = arr.length;
            for(int i=depth; i<len-1-depth; i++)
            {
                int tmp = arr[depth][i];
                arr[depth][i] = arr[len-1-i][depth];
                arr[len-1-i][depth] = arr[len-1-depth][len-1-i];
                arr[len-1-depth][len-1-i] = arr[i][len-1-depth];
                arr[i][len-1-depth] = tmp;
            }
            if(len - 2*depth > 1)
                rotatecounterclockwise90Recursion(arr, depth+1);
        }
    }

    //Rotate matrix clockwise 90 recursively 
    public static void rotateClockWise90Recursion(int[][] arr, int depth)
    {
        if(arr != null)
        {
            int len = arr.length;
            for(int i=depth; i<len-1-depth; i++)
            {
                int tmp = arr[depth][len-1-i];
                arr[depth][len-1-i] = arr[len-1-i][len-1-depth];
                arr[len-1-i][len-1-depth] = arr[len-1-depth][i];
                arr[len-1-depth][i] = arr[i][depth];
                arr[i][depth] = tmp;
            }
            if(len - 2*depth > 1)
                rotateClockWise90Recursion(arr, depth+1);
        }
    }

    public static void test1()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

        int depth = 0;
		rotatecounterclockwise90Recursion(A, depth);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
    }

    public static void test2()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

        int depth = 0;
		rotateClockWise90Recursion(A, depth);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
    }
    public static void test3()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

		rotatecounterclockwise90(A);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

    }
    public static void test4()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

		rotateMatrixClockwise90(A);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
    }
}
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 
import classfile.*;

public class RotatedSortedArray{
    public static void main(String[] args) {
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test0_findMinIndexNew();
        test1_findMinIndexNew();
        test2_findMinIndexNew();
        test3_findMinIndexNew();
        test4_findMinIndexNew();
    }

    static void test1(){
        Aron.beg();
        int[] arr = {4, 3, 2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 0);

        Aron.end();
    }


    static void test2(){
        Aron.beg();
        int[] arr = {1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 1);
        Aron.end();
    } 

    static void test3(){
        Aron.beg();
        int[] arr = {3};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 0);
        Aron.end();
    } 

    static void test4(){
        Aron.beg();
        int[] arr = {3, 4, 5, 1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 2);

        Aron.end();
    }

    static void test5(){
        Aron.beg();
        int[] arr = {3, 4, 5, 1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinIndexNegative(negative(arr), lo, hi);
        Test.t(index, 3); 

        Aron.end();
    }

    static void test6(){
        Aron.beg();
        int[] arr = {2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 0);

        Aron.end();
    }

    //[ file=RotatedSortedArray.html title=""
    // assume there is not duplicated number in the array
    // find the index of maximum value in the rotated sorted array
    public static int findMaxIndex(int[] arr, int lo, int hi) {
        if(arr != null) {
            if(arr[lo] < arr[hi] || lo == hi)
                return hi;
            else {
                int mid = (lo + hi)/2;
                if(arr[lo] < arr[mid])
                    return findMaxIndex(arr, mid, hi);
                else
                    return findMaxIndex(arr, lo, mid);
            }
        }
        return -1;
    }
    //]

    // negative all values in the array
    public static int[] negative(int[] arr) {
        int[] tmpArr = new int[arr.length];
        int c=0;
        for(int e: arr) {
            tmpArr[c] = -e;
            c++;
        }
        return tmpArr;
    }

    // find the mininum index from a rotated sorted array
    public static int findMinIndex(int[] arr, int lo, int hi) {
        return findMaxIndex(arr, lo, hi);
    }
    
    public static int findMinIndexNegative(int[] arr, int lo, int hi) {
        if(arr != null) {
            if(arr[lo] > arr[hi] || lo == hi)
                return hi;
            else {
                int mid = (lo + hi)/2;

                if(arr[lo] < arr[mid])
                    return findMinIndexNegative(arr, mid, hi);
                else
                    return findMinIndexNegative(arr, lo, mid);
            }
        }
        return -1;
    }

    static void test0_findMinIndexNew(){
        Aron.beg();
        int[] arr = {1, 2, 3, 4}; 
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinIndexNew(arr, lo, hi);
        Test.t(findMinIndexNew(arr, lo, hi), 0);

        Aron.end();
    }
    static void test1_findMinIndexNew(){
        Aron.beg();
        int[] arr = {2, 3, 4, 1}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 3);

        Aron.end();
    }
    static void test2_findMinIndexNew(){
        Aron.beg();
        int[] arr = {1, 2}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 0);

        Aron.end();
    }
    static void test3_findMinIndexNew(){
        Aron.beg();
        int[] arr = {2, 1}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 1);

        Aron.end();
    }
    static void test4_findMinIndexNew(){
        Aron.beg();
        int[] arr = {2, 3, 1}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 2);

        Aron.end();
    }

    public static int findMinIndexNew(int[] arr, int lo, int hi){
        if(arr != null){
            if(arr[lo] < arr[hi] || lo == hi)
                return lo;
            else{
                int mid = 0;
                if((lo + hi) % 2 == 1)
                    mid = ((lo + hi)/2) + 1;
                else 
                     mid = (lo + hi)/2;

                if(arr[mid] < arr[hi])
                    return findMinIndexNew(arr, lo, mid);
                else
                    return findMinIndexNew(arr, mid, hi);
            }
        }
        return -1;
    }

}
import java.util.*;
import java.io.*;
import classfile.*;

public class RotatedSortedArrayMaxMin{
    public static void main(String[] args) {
        test00_min();
        test0_min();
        test1_min();
        test2_min();
        test3_min();
        test4_min();
        test5_max();
        test6_max();
        test7_max();
        test8_max();
    }
    public static void test00_min(){
        Aron.beg();
        int[] arr = {1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test0_min(){
        Aron.beg();
        int[] arr = {1, 2, 3, 4};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test1_min(){
        Aron.beg();
        int[] arr = {2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 1);
        Aron.end();
    }
    public static void test2_min(){
        Aron.beg();
        int[] arr = {3, 1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 1);
        Aron.end();
    }
    public static void test3_min(){
        Aron.beg();
        int[] arr = {4, 1, 2, 3};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 1);
        Aron.end();
    }
    public static void test4_min(){
        Aron.beg();
        int[] arr = {2, 3, 4, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 3);
        Aron.end();
    }

    // find the index of minimum element of an array
    public static int findMinimumIndex(int[] arr, int lo, int hi){
        if( arr[lo] <= arr[hi])
            return lo;
        else{
            // [2, 1]
            // [3, 1, 2]
            // =>[3, 1] => [1]
            int mid = (lo + hi)/2;
            if(arr[lo] < arr[mid])
                return findMinimumIndex(arr, mid, hi);
            else if(arr[lo] > arr[mid])
                return findMinimumIndex(arr, lo, mid);
            else 
                return hi;
        }
    }
    public static int findMaximumIndex(int[] arr, int lo, int hi){
        if(arr[lo] <= arr[hi])
            return hi;
        else{
            // [2, 1]
            int mid = (lo + hi)/2;
            if( arr[lo] < arr[mid])
                return findMaximumIndex(arr, mid, hi);
            else if(arr[lo] > arr[mid]) 
                return findMaximumIndex(arr, lo, mid);
            else
                return lo;
        }
    }
    public static void test5_max(){
        Aron.beg();
        int[] arr = {2, 3, 4, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 2);
        Aron.end();
    }
    public static void test6_max(){
        Aron.beg();
        int[] arr = {2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test7_max(){
        Aron.beg();
        int[] arr = {1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test8_max(){
        Aron.beg();
        int[] arr = {4, 1, 2, 3};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }

} 

import java.io.*;
import java.lang.String;
import java.util.*;
class Search2DMatrix 
{
	public static void main(String args[])
	{
		int[][] Arr = new int[1][3];
		gen2D(Arr);
		int right=0;
		int down=Arr.length-1;
		int key=2;
		boolean found = Search2DRecur(Arr, right, down, key);

		if(found)
			System.out.println("found key=" + key);
		else 
			System.out.println("not found key="+key);
	}

	public static void gen2D(int[][] Arr)
	{
		int row, col;
		if(Arr != null)
		{
			row = Arr.length;
			col = Arr[0].length;
			Arr[0][0] = 0;
			Random r = new Random();
			for(int i=0; i<row; i++)
			{
				int ran = r.nextInt(3); 
				for(int j=0; j<col; j++)
				{
					if(i-1>=0 && j-1>=0)
					Arr[i][j] = Arr[i-1][j]+ Arr[i][j-1]+ran;
					else if(j-1>=0)
						Arr[i][j] = Arr[i][j-1]+ran;
					else if(i-1>=0)
						Arr[i][j] = Arr[i-1][j]+ran;

					System.out.print(String.format("%10s", Arr[i][j]));
				}
				System.out.println();
			}
		}
	}
	public static boolean Search2D(int[][] Arr, int key)
	{
		int row, col;
		boolean found=false;
		if(Arr != null)
		{
			row = Arr.length;
			col = Arr[0].length;

			int right = 0;
			int down = row-1;
			while(right < col && down >= 0 && !found)
			{
				if(key > Arr[down][right])
						right++;
				else if(key < Arr[down][right])
                        down--;
				else if(key == Arr[down][right])
				{
					found = true;
					System.out.println("found Arr["+down+"]["+right+"]="+Arr[down][right]);
				}
			}
			if(!found)
					System.out.println("not fund key=" + key);
		}
		return found;
	}

	//right = 0;
	//down = row-1; 
	
	public static boolean Search2DRecur(int[][] Arr, int right, int down, int key)
	{
		if(Arr != null && right < Arr[0].length && down >= 0)
		{
			if(key > Arr[down][right])
				return Search2DRecur(Arr, right+1, down, key);			
			else if(key < Arr[down][right])
				return Search2DRecur(Arr, right, down-1, key);			
			else 
				return true;
		}
		return false;
	}
	
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

public class SerializeBinary {
    public static void main(String[] args) {
        test_serializeLevel();
        test_deserializeBinary();
        test1_deserializeIterator();
        test2_deserializeIterator();
        test_deSerializeIndex();
        test1_deSerializeIndex();
    }
    static void test_serializeLevel(){
        Aron.beg();
       
        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        Aron.inorder(bin.root);
        Aron.line();
        try {
            BufferedWriter out1 = new BufferedWriter(new FileWriter("text/level0.txt"));

            serializeLevel(bin.root, out1);
            out1.close();

            BufferedReader levelIn = new BufferedReader(new FileReader("text/level0.txt"));

            List<List<String>> list = createMap(levelIn);
            int depth = 0;
            
            Map<String, Node> map = new HashMap<String, Node>(); 
            Node root = deserializeLevel(list, map);
            Aron.line();
            Aron.inorder(root);
        } catch(Exception e) {
        }
        Aron.end();
    }
    
    static void test1_deserializeIterator(){
        Aron.beg();
        BST bin = new BST();
        bin.insert(10);
        bin.insert(11);

        try {
            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            List<String> list = Aron.readFileOneLineSplit("text/out.txt");
            Iterator<String> ite = list.iterator();
            Node root = deserializeIterator(ite);

            Aron.inorder(root);

        } catch(Exception e) {
        }

        Aron.end();
    } 

    static void test2_deserializeIterator(){
        Aron.beg();
        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        try {
            Aron.inorder(bin.root);
            Aron.line();

            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            List<String> list = Aron.readFileOneLineSplit("text/out.txt");
            Iterator<String> ite = list.iterator();
            Node root = deserializeIterator(ite);

            Aron.inorder(root);

        } catch(Exception e) {
        }

        Aron.end();
    } 
    
    static void test_deserializeBinary(){
        Aron.beg();

        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        try {
            Aron.inorder(bin.root);

            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out.txt"));

            int[] A = new int[1];
            A[0] = 0;
            String[] Array = readFile(in);
            Node root = deserializeBinary(Array, A);
            Aron.inorder(root);
        } catch(Exception e) {
        }

        Aron.end();
    }

    static void test_deserializeBinary3(){
        Aron.beg();

        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        System.out.println("");
        try {
            Aron.inorder(bin.root);

            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out.txt"));

            String[] Array = readFile(in);
            Node root = deserializeBinary3(Array);
            Aron.inorder(root);
        } catch(Exception e) {
        }

        Aron.end();
    }

    //Use Level order to write node to file
    public static void serializeLevel(Node root, BufferedWriter out1) {
        try {
            if(root != null) {
                Queue<Node> q1 = new LinkedList<Node>();
                Queue<Node> q2 = new LinkedList<Node>();
                q1.add(root);
                while(q1.peek() != null || q2.peek() != null) {
                    while(q1.peek() != null) {
                        String s = "";
                        Node node = q1.remove();
                        s += node.data + " ";
                        if(node.left != null) {
                            s += node.left.data + " ";
                            q2.add(node.left);
                        } else
                            s += "#" + " ";
                        if(node.right != null) {
                            s += node.right.data + " ";
                            q2.add(node.right);
                        } else
                            s += "#" + " ";

                        s += "\n";
                        out1.write(s);
                    }

                    while(q2.peek() != null) {
                        String s = "";
                        Node node = q2.remove();
                        s += node.data + " ";
                        if(node.left != null) {
                            s += node.left.data + " ";
                            q1.add(node.left);
                        } else
                            s += "#" + " ";
                        if(node.right != null) {
                            s += node.right.data + " ";
                            q1.add(node.right);
                        } else
                            s += "#" + " ";

                        s += "\n";
                        out1.write(s);
                    }
                }

            }
        } catch(Exception e) {
        }
    }

    public static List<List<String>> createMap(BufferedReader in) {
        List<List<String>> list = new ArrayList<List<String>>();
        try {
            String line = null;
            while((line = in.readLine()) != null) {
                line = line.trim();
                String[] array = line.split("\\s+");
                if(array != null && array.length == 3) {
                    list.add(Arrays.asList(array));
                }
            }
        } catch(Exception e) {
        }
        return list;
    }

    public static String[] readFile(BufferedReader in) {
        String[] Array = null;
        try {
            String str;
            boolean end = false;
            while( (str = in.readLine()) != null && !end) {
                System.out.println(str);
                Array = str.split("\\s");
                end = true;
            }
            in.close();

            for(int i=0; Array != null && i<Array.length; i++) {
                System.out.println("["+Array[i]+"]");
            }

        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        return Array;
    }

    public static Node deserializeLevel(List<List<String>> listList, Map<String, Node> map) {
        Node root = null;
        for(List<String> list : listList){
            if(root == null){
                root = new Node(Integer.parseInt(list.get(0)));
                map.put(list.get(0), root);

                String left = list.get(1);
                if(!left.equals("#")){
                    Node node =  new Node(Integer.parseInt(left));
                    root.left = node;
                    map.put(left, node);
                }

                String right = list.get(2);
                if(!right.equals("#")){
                    Node node =  new Node(Integer.parseInt(right));
                    root.right = node;
                    map.put(right, node);
                }
            }
            else{
                Node curr = map.get(list.get(0));
                if(curr == null){
                    curr = new Node(Integer.parseInt(list.get(0)));
                    map.put(list.get(0), curr);
                }

                String left = list.get(1);
                if(!left.equals("#")){
                    Node node =  new Node(Integer.parseInt(left));
                    curr.left = node;
                    map.put(left, node);
                }

                String right = list.get(2);
                if(!right.equals("#")){
                    Node node =  new Node(Integer.parseInt(right));
                    curr.right = node;
                    map.put(right, node);
                }
            }
        }
        return root;
    }

    public static Node deserializeBinary(String[] Array, int[] A) {
        Node root = null;
        if(Array != null && A[0] < Array.length) {
            if(!Array[A[0]].equals("#")) {
                root = new Node(Integer.parseInt(Array[A[0]]));
                A[0]++;
                root.left = deserializeBinary(Array, A);
                A[0]++;
                root.right = deserializeBinary(Array, A);
            }
        } else {
            Print.pbl("root is null");
        }
        return root;
    }

    static int index = 0;
    public static Node deserializeBinary3(String[] Array) {
        Node root = null;
        if(Array != null && index < Array.length) {
            if(!Array[index].equals("#")) {
                root = new Node(Integer.parseInt(Array[index]));
                index++;
                root.left = deserializeBinary3(Array);
                index++;
                root.right = deserializeBinary3(Array);
            }
        } else {
            Print.pbl("root is null");
        }
        return root;
    }

    //[ file=serializebin.html title=""
    public static void serializeBinary(Node root, BufferedWriter out) {
        try {
            if(root != null) {
                out.write(root.data + " ");
                serializeBinary(root.left, out);
                serializeBinary(root.right, out);
            } else {
                out.write("# ");
            }
        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
    }
    public static Node deserializeIterator(Iterator<String> ite) {
        Node root = null;
        if(ite.hasNext()) {
            String token = ite.next();
            if(!token.equals("#")) {
                root = new Node(Integer.parseInt(token));
                root.left = deserializeIterator(ite);
                root.right = deserializeIterator(ite);
            }
        } 
        return root;
    }
    //]

    public static void test_deSerializeIndex() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(14);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);

        Aron.inorder(b1.root);
        Aron.line();

        try {
            FileWriter fstream = new FileWriter("text/out.txt");
            BufferedWriter out = new BufferedWriter(fstream);
            int k=0;
            serializeIndex(b1.getRoot(), out, k);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out.txt"));
            Map<Integer, Integer> map = buildMapFromFile(in);

            k = 0;
            Node root = deSerializeIndex(map, k);
            Aron.inorder(root);

        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        Aron.end();
    }

    public static void test1_deSerializeIndex() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(12);

        Aron.inorder(b1.root);
        Aron.line();

        try {
            FileWriter fstream = new FileWriter("text/out1.txt");
            BufferedWriter out = new BufferedWriter(fstream);
            int k=0;
            serializeIndex(b1.getRoot(), out, k);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out1.txt"));
            Map<Integer, Integer> map = buildMapFromFile(in);

            k = 0;
            Node root = deSerializeIndex(map, k);
            Aron.inorder(root);

        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        Aron.end();
    }

    //Write nodes to file with inorder traversal
    public static void serializeIndex(Node root, BufferedWriter out, int k) {
        if(root != null) {
            String s = k + ":" + root.data + "\n";
            try {
                serializeIndex(root.left, out, 2*k + 1);
                out.write(s);
                serializeIndex(root.right, out, 2*k + 2);
            } catch(Exception e) {
                System.err.println("Error" + e.getMessage());
            }
        }
    }
    //Initialize k = 0 
    public static Node deSerializeIndex(Map<Integer,Integer> map, int k) {
        if(map.containsKey(k)) {
            Integer data = map.get(k);
            Node root = new Node(data);
            root.left = deSerializeIndex(map, 2*k + 1);
            root.right = deSerializeIndex(map, 2*k + 2);
            return root;
        }
        return null;
    }

    public static Map<Integer,Integer> buildMapFromFile(BufferedReader in) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        try {
            String line = null;
            while((line = in.readLine()) != null) {
                line = line.trim();
                String[] array = line.split(":");
                if(array.length == 2) {
                    map.put(Integer.parseInt(array[0]), Integer.parseInt(array[1]));
                } else
                    System.err.println("Error: invalid file format");
            }
        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        return map;
    }
}
//Traveral binary tree in level order store it in HashMap
//Reconstruct the binary tree from HashMap
//
//      [p]
//[2*p+1] [2*p+2]
//

import java.util.*;
import classfile.*;

public class SerializeBinaryLevelOrder {
    public static void main(String[] args) {
        test0();        
        test1();        
        test2();        
        test3();        
        test4();        
        test5();        
    }
    static void test0(){
        Aron.beg();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20);

        Aron.preorder(bt.root);
        levelOrder(bt.root);
        map = levelOrder(bt.root);

        BST newbt = new BST();
        int key = 0;
        newbt.root = buildBinaryTree(map, key);
        Aron.inorder(newbt.root);

        Aron.end();
    }
    static void test1(){
        Aron.beg();

        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20);

        Aron.inorder(bt.root);
        levelOrder2(bt.root);

        Aron.end();
    }

    static void test2(){
        Aron.beg();
        //System.out.println(String.format("[%-20s]=[%s]" , "label", "content" ));
        System.out.println(String.format("[%-20s]=[%s]" , 9, "content" ));
        for(int i=0; i<5; i++){
            System.out.println(String.format("[%1$05d]" , i));
        } 
        Aron.end();
    } 
    
    static void test3(){
        Aron.beg();
        padding();
        Aron.end();
    }

    static void test4(){
        Aron.beg();

        for(int i=0; i< 5; i++){
            String str = "%1$-" + (i + 1) + "s";
            String value = String.format(str, i);
            System.out.println("["+ value + "]");
        } 
        Aron.end();
    }
    static void test5(){
        Aron.beg();

        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20);

        int level = level(bt.root);
        System.out.println("level[" + level + "]");
        for(int i=1; i<=level; i++){
            prettyPrint(bt.root, i);
            System.out.println();
        } 
        Aron.end();
    }
    static int level(Node root){
        if(root != null){
            return Math.max(level(root.left), level(root.right)) + 1;
        }
        return 0;
    }

    static void prettyPrint(Node r, int level){
        if(r != null){
                //String format = "%1$-" + level + "s";
                String format = "%1$" + (level + 10) + "s";
                String str = "[" + r.data + "]";
                System.out.print(String.format(format, str));

            prettyPrint(r.left, level - 1);
            prettyPrint(r.right, level - 1);
        }
    }

    static void padding(){
        String[] left  = {"Technology", "Technic", "Technologies", "Technisian"};
        String[] right = {"Continuous", "Continua", "Continuously", "Continuation"};
        for(int i=0; i< left.length; i++){
            String str = "%1$-" + (i + 4) + "s";
            //System.out.println("str[" + str + "]");
            //String value = String.format("%1$-15s %2$15s", left[i], right[i]);
            String value = String.format(str + " %2$15s", left[i], right[i]);
            System.out.println("[" + value + "]");
        } 
    }

    public static Node buildBinaryTree(Map<Integer, Integer> map, int key) {
        Node root = null;
        if(map.containsKey(key)) {
            root = new Node((Integer)map.get(key));
            map.remove(key);
            root.left   = buildBinaryTree(map, 2*key+1);
            root.right  = buildBinaryTree(map, 2*key+2);
        }
        return root;
    }

    public static void levelOrderRecursion(Queue<Node> q, Map<Integer, Integer> map, int k) {
        Queue<Node> tmpQueue = new LinkedList<Node>();
        while(q.peek() != null) {
            Node node = q.remove();
            map.put(k, node.data);
            if(node.left != null)
                tmpQueue.add(node.left);
            if(node.right != null)
                tmpQueue.add(node.right);
        }
        if(tmpQueue.peek() != null)
            levelOrderRecursion(tmpQueue, map, k);
    }

    
    public static void levelOrder2(Node curr) {
        if(curr != null){
            Queue<Node> q1 = new LinkedList<Node>();
            Queue<Node> q2 = new LinkedList<Node>();
            q1.add(curr);
            while(!q1.isEmpty() || !q2.isEmpty()){

                while(!q1.isEmpty()){
                    Node node = q1.remove();
                    System.out.println("[" + node.data + "]");
                    if(node.left != null)
                        q2.add(node.left);
                    if(node.right != null)
                        q2.add(node.right);
                }

                while(!q2.isEmpty()){
                    Node node = q2.remove();
                    System.out.println("[" + node.data + "]");

                    if(node.left != null)
                        q1.add(node.left);
                    if(node.right != null)
                        q2.add(node.right);
                }
            }
        }
    }
    public static Map<Integer, Integer> levelOrder(Node root) {
        Queue<Node> queue1 = new LinkedList<Node>();
        Queue<Node> queue2 = new LinkedList<Node>();
        Queue<Integer> numq1 = new LinkedList<Integer>();
        Queue<Integer> numq2 = new LinkedList<Integer>();
        Map<Integer, Integer> orderedMap = new LinkedHashMap<Integer, Integer>();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();

        int parentIndex = -1;
        int[] Array = new int[20];
        if(root != null) {
            parentIndex= 0;
            System.out.println("here");
            queue1.add(root);
            numq1.add(parentIndex);
        }
        while(queue1.peek() != null || queue2.peek() != null) {
            while(queue1.peek() != null) {
                Node no = queue1.remove();
                parentIndex = numq1.remove();
                map.put(parentIndex, no.data);
                orderedMap.put(parentIndex, no.data);

                System.out.print("["+no.data+"]");
                System.out.print(" parentIndex="+parentIndex);
                if(no.left != null) {
                    queue2.add(no.left);
                    numq2.add(2*parentIndex+1);
                }
                if(no.right != null) {
                    queue2.add(no.right);
                    numq2.add(2*parentIndex+2);
                }
            }
            System.out.println("");
            while(queue2.peek() != null) {
                Node no = queue2.remove();
                parentIndex = numq2.remove();
                map.put(parentIndex, no.data);
                orderedMap.put(parentIndex, no.data);

                System.out.print("["+no.data+"]");
                System.out.print(" parentIndex="+parentIndex);
                if(no.left != null) {
                    queue1.add(no.left);
                    numq1.add(2*parentIndex+1);
                }
                if(no.right != null) {
                    queue1.add(no.right);
                    numq1.add(2*parentIndex+2);
                }
            }
            System.out.println("");
        }
        return map;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class SerializeGeneralTree{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        String file = "./text/try.txt";
        
        try{
            Node r = Aron.createGeneralTree();
            Aron.inorderGeneralTree(r);
            Ut.l();
            BufferedWriter bw = new BufferedWriter(new FileWriter(file));
            serializeGeneralTree(r, bw);
            bw.close();
            
            List<String> list = Aron.readFileOneLineSplit(file);
            Aron.printlnList(list);

            Ut.l();
            Node dr = deserializeGeneralTree(list);
            Aron.inorderGeneralTree(dr);
        }catch(IOException e){
        }
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    public static void serializeGeneralTree(Node r, BufferedWriter bw){
        if(r != null){
            try{
            bw.write(r.data + " ");
            for(Node n : r.list)
                serializeGeneralTree(n, bw);

            bw.write(" # ");
            }catch(IOException e){
                e.printStackTrace();
            }
        }
    }

    // use one stack to deserialize general tree
    public static Node deserializeGeneralTree(List<String> list){ 
        Stack<Node> stack = new Stack<>();
        for(String s : list){
            if(!s.equals("#")){
                Node n = new Node(s);
                stack.push(n);
            }else{
                if(stack.size() > 1){
                    Node top = stack.pop();
                    stack.peek().list.add(top);
                }
            }
        }
        return stack.peek();
    }
} 

import java.util.*;
import java.io.*;
import java.util.stream.*;
import classfile.*;

//class NNode<T>{
//    public T data;
//    public List<NNode> list = new ArrayList<>();
//    public NNode(T data){
//        this.data = data;
//    }
//}

public class SerializeNaryTree{
    public static void main(String[] args) {
        //test0();
        test00();
        //test1();
//        test2();
//
//        test0_deserialize_debug();
//        test1_deserialize_debug();
//        test2_deserialize_debug();
//        test00_writeFile();
          //test01_readFile();
//        test10_deserialize();
//        test11_deserializeStack();
//        test12_deserializeStack();
//        test13_deserializeStack();
//        test02_buildTreeFromLevelOrder();
    }
    static void test0(){
        Aron.beg();
        Node root = new Node("1");
        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize(ite);
        int level = 0;
        Aron.prettyPrintGeneral(node, level);

        Aron.end();
    }
    static void test00(){
        Aron.beg();

        String fName = "file4.txt";
        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();
        Node root = deserialize(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);

        Aron.end();
    }

    static void test0_deserialize_debug(){
        Aron.beg();
        Node root = new Node("1");
        root.list.add(new Node("2"));
        root.list.add(new Node("3"));
        root.list.add(new Node("4"));
        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize_debug(ite);
        printNary(node);

        Aron.end();
    }
    static void test2_deserialize_debug(){
        Aron.beg();
        Node root = new Node("1");

        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");

        Node n35 = new Node("5");
        Node n36 = new Node("6");
        n3.list.add(n35);
        n3.list.add(n36);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize_debug(ite);
        printNary(node);

        Aron.end();
    }
    static void test1_deserialize_debug(){
        Aron.beg();
        Node root = new Node("1");
        Node n1 = new Node("2");
        Node n2 = new Node("3");
        Node n3 = new Node("4");

        Node n4 = new Node("5");
        Node n5 = new Node("6");

        n3.list.add(n4);
        n3.list.add(n5);
        root.list.add(n1);
        root.list.add(n2);
        root.list.add(n3);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize_debug(ite);
        printNary(node);

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Node root = new Node("1");
        root.list.add(new Node("2"));
        root.list.add(new Node("3"));
        root.list.add(new Node("4"));

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize(ite);
        printNary(node);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");

        Node n4 = new Node("4");
        Node n5 = new Node("5");

        root.list.add(n2);
        root.list.add(n3);

        n3.list.add(n4);
        n3.list.add(n5);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize(ite);
        printNary(node);

        Aron.end();
    }
    static void test10_deserialize(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");

        Node n4 = new Node("4");
        Node n5 = new Node("5");

        root.list.add(n2);
        root.list.add(n3);

        n3.list.add(n4);
        n3.list.add(n5);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);

        Aron.end();
    }

    static void test11_deserializeStack(){
        Aron.beg();

        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");

        root.list.add(n2);
        root.list.add(n3);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);
 

        Aron.end();
    }

    static void test12_deserializeStack(){
        Aron.beg();
        Node root = new Node("1");
        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);

        Aron.end();
    }
    static void test13_deserializeStack(){
        Aron.beg();

        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);
        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);

        Aron.end();
    }
    public static void printNary(Node curr){
        if(curr != null){
            Print.pbl(curr.data);
            for(int i=0; i<curr.list.size(); i++){
                printNary((Node)curr.list.get(i));
            } 
        }
    }

    public static void write(Node curr, String fname){
        if(fname != null){
            try(BufferedWriter bw = new BufferedWriter(new FileWriter(fname))){
                serialize(curr, bw);
            }catch(IOException e){
                System.out.println(e.getMessage());
            }
        }
    }
    public static List<String> read(String fname){
        List<String> list = null; 
        if(fname != null){
            try(BufferedReader br = new BufferedReader(new FileReader(fname))){
                String line; 
                while((line = br.readLine()) != null){
                    break;
                }
                list = Arrays.asList(line.trim().split("\\s+"));

                Aron.printList(list);
            }catch(IOException e){
                System.out.println(e.getMessage());
            }
        }
        return list;
    }
    //[ file=serializetree.html title=""
    // serialize n-ary tree from preorder to post order 
    public static void serialize(Node curr, BufferedWriter bw){
        if(curr != null){
            try{
                bw.write(curr.data + " ");
                for(Node node : curr.list){
                    serialize(node, bw);
                }
                bw.write("#" + " ");
            }catch(IOException e){
            }
        }
    }

    public static Node deserialize(Iterator<String> ite){
        Node root = null;
        if(ite.hasNext()){
            String token = ite.next();
            //Print.pbl("[" + token);
            if(!token.equals("#")){
                root = new Node(token);
                Node child = deserialize(ite);
                if(child != null)
                    root.list.add(child);
            }else{
                root = deserialize(ite);
            }
            //Print.pbl("]");
        }
        return root;
    }

    public static Node deserialize_debug(Iterator<String> ite){
        Node root = null;
        if(ite.hasNext()){
            String token = ite.next();
            if(!token.equals("#")){
                Print.p("[" + token);
                root = new Node(token);
                Node child = deserialize_debug(ite);
                if(child != null){
                    root.list.add(child);
                    Print.pbl(root.data + "->(" + child.data + ")");
                }
                Print.p("]");
            }else{
                Print.p("[" + token);
                root = deserialize_debug(ite);
                Print.p("]");
            }
        }
        return root;
    }
    //]

    //[ file=deserializetree.html title=""
    // deserialize with stack
    public static Node deserializeStack(Iterator<String> ite){
        Stack<Node> stack = new Stack<>(); 
        while(ite.hasNext()){
            String token = ite.next();
            if(!token.equals("#")){
                stack.push(new Node(token));
            }else{
                if(stack.size() > 1){
                    Node top = stack.pop();
                    Node peek = stack.peek();
                    peek.list.add(top);
                }
            }
        }
        return stack.peek();
    }
    //]

    public static void writeFile(Node r, String fName){
        try{
            BufferedWriter bw = new BufferedWriter(new FileWriter(fName));
            levelOrder(r, bw);
            bw.close();
        }catch(IOException ie){
            ie.printStackTrace();
        }
    }
    public static void levelOrder(Node r, BufferedWriter bw){
        if(r != null){
            try{
                Queue<Node> queue = new LinkedList<Node>(); 
                if(r != null){
                    queue.add(r);
                    while(!queue.isEmpty()){
                        Node node = queue.remove();
                        bw.write(node.data + ":");
                        for(Node n : node.list){
                            bw.write(n.data + ":");
                            queue.add(n);
                        }
                        bw.write("\n");
                    }
                }
            }catch(IOException ie){
                ie.printStackTrace();
            }
        }
    }
    public static Map<Integer, List<Integer>> readFile(String fName){
       Map<Integer, List<Integer>> map = new HashMap<>(); 
       if(fName != null){
           try{
               BufferedReader br = new BufferedReader(new FileReader(fName));
               String line = null;
               while((line = br.readLine()) != null){
                   List<String> strList = Arrays.asList(line.split(":"));
                   // Java 8 lambda expr
                   List<Integer> list = strList.stream().map(Integer::parseInt).collect(Collectors.toList());
                   if(list.size() > 0) 
                       map.put(list.get(0), list.size() > 1? list.subList(1, list.size()) : new ArrayList<Integer>());
               }
           }catch(IOException ie){
               ie.printStackTrace();
           }
       }
       return map;
    }
    
    static void test00_writeFile(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        
        Node n5 = new Node("5");
        Node n6 = new Node("6");

        n3.list.add(n5);
        n3.list.add(n6);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);
        String fName = "file5.txt";
        writeFile(root, fName);
        Aron.end();
    }
    static void test01_readFile(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        
        Node n5 = new Node("5");
        Node n6 = new Node("6");

        n3.list.add(n5);
        n3.list.add(n6);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);
        String fName = "file5.txt";
        writeFile(root, fName);
//        Map<Integer, List<Integer>> map = readFile(fName); 
//        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){
//            Print.pp(entry.getKey());
//            Aron.printList(entry.getValue());
//        } 
        Aron.end();
    }
    static void test02_buildTreeFromLevelOrder(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        
        Node n5 = new Node("5");
        Node n6 = new Node("6");

        n3.list.add(n5);
        n3.list.add(n6);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);
        String fName = "file5.txt";
        writeFile(root, fName);
        Map<Integer, List<Integer>> map = readFile(fName); 
        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){
            Print.pp(entry.getKey());
            Aron.printList(entry.getValue());
        } 
        Node r = buildTreeFromLevelOrder(map, 1);  
        printNary(r);

        Aron.end();
    }
    public static Node buildTreeFromLevelOrder(Map<Integer, List<Integer>> map, Integer r){
        Node parent = null;
        if(map.size() > 0){
            parent = new Node(r + "");
            List<Integer> list = map.get(r);
            for(Integer n : list){
                parent.list.add(buildTreeFromLevelOrder(map, n));
            }
        }
        return parent;
    }
} 
import java.util.ArrayList;
public class SetMatrixZero 
{
    public static void main(String[] args)
    {
        System.out.println("SetMatrixZero");
        int[][] Matrix = {
            {0, 3, 5, 6},
            {1, 3, 5, 0},
            {4, 0, 5, 6},
            {7, 3, 5, 6}
        };
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
        int len = Matrix.length; 
        for(int i=0; i<len; i++)
        {
            for(int j=0; j <len; j++)
            {
                if(Matrix[i][j] == 0)
                {
                    arrayList.add(i*len + j);
                }
            }
        }

        for(int i=0; i<len; i++)
        {
            for(int j=0; j <len; j++)
            {
                System.out.print(Matrix[i][j] + " ");
            }
            System.out.println();
        }

        System.out.println();
        for(int k=0; k<arrayList.size(); k++)
        {
            int row = arrayList.get(k)/len;
            int col = arrayList.get(k)%len;
            for(int i=0; i<len; i++)
            {
               for(int j=0; j<len; j++)
               {
                   if(i==row || j==col)
                   {
                       Matrix[i][j] = 0;
                   }
               } 
            }
        }

        for(int i=0; i<len; i++)
        {
            for(int j=0; j <len; j++)
            {
                System.out.print(Matrix[i][j] + " ");
            }
            System.out.println();
        }

    }
}
import java.util.*;
import java.io.*;
import classfile.*;

class URLShortener{
    final int base = 52;
    Map<Integer, Character> map = new HashMap<Integer, Character>(); 
    Map<Character, Integer> revmap = new HashMap<Character, Integer>(); 
    public URLShortener(){
        createMap();
    }
    //[ file=shortener.html title=""
    public StringBuilder encodeTo52(int n){
        final int base = 52; 
        StringBuilder sb = new StringBuilder();
        if(n == 0)
           sb.append("0");
        else{
            while(n > 0){
                sb.append(map.get(n % base));
                n /= base;
            }
        }
        return sb.reverse();
    }
    public int decode(StringBuilder sb){
        int sum = 0;
        for(int i=sb.length()-1; i>=0; i--){
            sum += (int)Math.pow(base, revmap.get(new Character(sb.charAt(i))));     
        }
        return sum;
    }
    public void createMap(){
        int count = 0;
        for(int i=0; i<10; i++){
            map.put(count, new Character((char)((int)'0' + i))); 
            revmap.put(new Character((char)((int)'0' + i)), count);
            count++;
        }

        for(int i=0; i<26; i++){
            map.put(count, new Character((char)((int)'a' + i))); 
            revmap.put(new Character((char)((int)'a' + i)), count);
            count++;
        }

        for(int i=0; i<26; i++){
            map.put(count, new Character((char)((int)'A' + i))); 
            revmap.put(new Character((char)((int)'A' + i)), count);
            count++;
        }

        
    }
    //]
    public void printMap(){
        for(Map.Entry<Integer, Character> entry: map.entrySet()){
            System.out.println("[" + entry.getKey() + "] [" + entry.getValue() + "]"); 
        }
    }
}


public class Shortener{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
    public int encode(int n){
        return 1;
    }

    static void test0(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(100); 
        System.out.println("100[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(0); 
        System.out.println("0[" + sb.toString() + "]"); 
        Aron.end();
    }

    static void test2(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(9); 
        System.out.println("9[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test3(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(10); 
        System.out.println("10[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test4(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(11); 
        System.out.println("11[" + sb.toString() + "]"); 
        Aron.end();
    }

    static void test5(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(1000000); 
        System.out.println("1000000[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test6(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(100000000); 
        System.out.println("100000000[" + sb.toString() + "]"); 
        Aron.end();
    }
} 
import classfile.*;

// update: Wed Sep 28 03:22:10 PDT 2016
//
public class ShortestPathKthEdge {
    static final int INT = 100;
    public static void main(String[] args) {
        Print.p("Hello World!");
        int[][] graph= { 
            {0, 10, 3, 2},
            {INT, 0, INT, 7},
            {INT, INT, 0, 6},
            {INT, INT, INT, 0}
        };
        int u = 0;
        int v = 3;
        int k = 2;
        int numVertex = 4;
        int min = minPath(graph, numVertex, k, u, v);
        Print.p("u=["+u+"]");
        Print.p("v=["+v+"]");
        Print.p("k=["+k+"]");
        Print.p("finalmin=["+min+"]");
        int numEdge = 0;

        //GraphTraveral(graph, numVertex, numEdge);
        Ut.l();
        PreorderGraphTraveral(graph, numVertex, numEdge);
        Ut.l();
        PostGraphTraveral(graph, numVertex, numEdge);
        /*
        int min2 = minPathDP(graph, numVertex, numEdge, u, v);
        Print.p("min2=["+min2+"]");
        */
    }

    //Use Depth First Search to find the shortest path from vertex u to v with k edges
    public static int minPath(int[][] graph, int numVertex, int k, int u, int v) {
        //when u == v, assume the cycle in the same node
        if(k <= 0 && u == v)
            return 0;
        else if( k <= 0)
            return INT;
        /*
        else if( k == 1 && graph[u][v] != INT)
            return graph[u][v];
        */
        else {
            int min = INT;
            for(int i=0; i<numVertex; i++) {
                if(graph[u][i] != INT && u != i && v != i) {
                    Print.p("inorder["+u+"]["+i+"]=["+graph[u][i]+"]");
                    Print.p("k=["+k+"]");
                    int subm = minPath(graph, numVertex, k-1, i, v);
                    if(subm != INT) {
                        min = Math.min(min, subm) + graph[u][i];
                        Print.p("min=["+min+"] subm["+subm+"]   ["+u+"]["+i+"]");
                    }
                }
            }
            return min;
        }
    }

    //Traveral from node(depth) to other nodes
    public static void PostGraphTraveral(int[][] w, int numVertex, int depth) {
        for(int i=0; i<numVertex; i++) {
            if( i !=depth && w[depth][i] != 0 && w[depth][i] != INT) {
                PostGraphTraveral(w, numVertex, i);
                //Print.p(depth+"->"+i+"["+w[depth][i]+"]");
                Print.p(i+"->"+depth+"["+w[depth][i]+"]");
            }
        }
    }

    //Preorder Traveral
    public static void PreorderGraphTraveral(int[][] w, int numVertex, int depth) {
        for(int i=0; i<numVertex; i++) {
            if( i !=depth && w[depth][i] != INT) {
                Print.p(depth+"->"+i+"["+w[depth][i]+"]");
                PreorderGraphTraveral(w, numVertex, i);
            }
        }
    }


    //Use dynamic programming to find the shortest path from vertex u to v with numEdge
    //edge
    public static int minPathDP(int[][] graph, int numVertex, int numEdge, int u, int v) {
        int[][][] cube = new int[numVertex][numVertex][numEdge+1];

        for(int e=0; e<numEdge+1; e++) {
            for(int i=0; i<numVertex; i++) {
                for(int j=0; j<numVertex; j++) {
                    cube[i][j][e] = INT;

                    //base case
                    if( e == 0 && i == j)
                        cube[i][j][e] = 0;
                    else if ( e == 1 && graph[i][j] != INT)
                        cube[i][j][e] = graph[i][j];
                    else if( e > 1) {
                        for(int a=0; a < numVertex; a++) {
                            if(i != j && a != i && a != j && graph[i][a] != INT &&
                                    cube[i][j][e-1] != INT)
                                cube[i][j][e] = Math.min(graph[i][a] + cube[a][j][e-1],
                                                         cube[i][j][e]);
                        }
                    }
                }
            }

            for(int i=0; i<numVertex; i++) {
                for(int j=0; j<numVertex; j++) {
                    if(cube[i][j][e] < 100)
                        Print.p("["+cube[i][j][e]+"]");
                    else
                        Print.p("["+0+"]");
                }
            }
        }
        return cube[u][v][numEdge];
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Shuffle 
{
	public static void main(String args[])
	{
		int[] B = new int[10];
		for(int i=0; i<10; i++)
			B[i] = i;  

		for(int i=0; i<B.length; i++)
			System.out.print(B[i]+" ");

		System.out.println();

		int[] A = Shuffle(B);
		for(int i=0; i<B.length; i++)
			System.out.print(A[i]+" ");
		System.out.println();
        
        test1();
        test2();

	}
	public static int[] Shuffle(int[] A)
	{
		Random ran = new Random();
		if( A != null) {
			int len=A.length;
			if(len > 1)
			for(int i=0; i<len; i++) {
				int r = ran.nextInt(len) % (len-i);
				int tmp = A[r]; A[r] = A[len-1-i]; A[len-1-i] = tmp;
			}
		}
		return A;
	}

    // given string s and t of the same length
    public static String PerfectShuffle(String s, String t)
    {
        int n = s.length();    
        if(n <= 1) return s + t;
        
        String a = PerfectShuffle(s.substring(0, n/2), t.substring(0, n/2));
        String b = PerfectShuffle(s.substring(n/2, n), t.substring(n/2, n));
        return a + b;
    }
    public static void test1()
    {
        String s = "abc";
        String t = "efg";
        System.out.print("\n test1() \n");
        System.out.print("\n s=" + s + "\n");
        System.out.print("\n t=" + t + "\n");
        System.out.print("\n PerfectShuffle()=" + PerfectShuffle(s, t) + "\n");
    }
    public static void test2()
    {
        String s = "a";
        String t = "e";
        System.out.print("\n test2() \n");
        System.out.print("\n s=" + s + "\n");
        System.out.print("\n t=" + t + "\n");
        System.out.print("\n PerfectShuffle()=" + PerfectShuffle(s, t) + "\n");
    }
}
public class SieveEratosthenes 
{
    public static void main(String[] args)
    {
        long startTime = System.currentTimeMillis();
        Prime(1000000);
        long endTime = System.currentTimeMillis();
        long diff = endTime - startTime;
        System.out.println("diff=" + diff);
    }

    //Find all the primes from 2 to n
    //Sieve of Eratosthenes Algorithm
    public static void Prime(int n)
    {
        boolean[] prime = new boolean[n+1];
        for(int i=0; i<n; i++)
            prime[i] = true;

        for(int i=2; i<Math.sqrt(n); i++)
        {
            int k=0;
            int index = i*i + k*i;
            if(prime[i])
            {
                while(index <= n)
                {
                    if(prime[index])
                        prime[index] = false;
                    index = i*i + k*i;
                    k++;
                }
            }
        }
        for(int i=2; i<n; i++)
        {
            System.out.println("[" + i + "]=" + prime[i]);
        }
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

// 4:22, 5:41, 6:19
// Least Recent Used Cache
//

//[ file=simpleLRU.html title=""
// Least Recent Used Cache, LRU
class LNode {
    String key;
    Object data;
    public LNode(String key, Object data) {
        this.data = data;
        this.key = key;
    }
}

class LRU {
    final int max;
    int count;
    LinkedList<LNode> list = new LinkedList<LNode>();
    Map<String, LNode> map = new HashMap<String, LNode>();

    public LRU(int max) {
        this.max = max;
        this.count = 0;
    }
    public void insert(String key, LNode node) {
        LNode value = map.get(key);
        if(value != null) {
            list.remove(value);
            list.addLast(node);
            map.put(key, node);
        } else {
            if(count < max) {
                map.put(key, node);
                list.addLast(node);
                count++;
            }else{
                LNode reNode = list.removeFirst();
                list.addLast(node);
                map.remove(reNode.key);
                map.put(key, node);
            }
        }
    }
    public void remove(String key) {
        if(count > 0 && map.containsKey(key)){
            LNode node = map.get(key);
            if(node != null){
                list.remove(node);
                map.remove(key);
                count--;
            }
        }
    }

    public void print(){
        for(Map.Entry<String, LNode> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " , " + entry.getValue().data + "]");
        } 
        Aron.line();

        for(LNode node : list){
            System.out.println("["+ node.data + "]");
        }
    }
}
//]

public class SimpleLRU{
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0() {
        Aron.beg();
        LRU lru = new LRU(3);
        String k1 = "dog";
        String k2 = "cat";
        String k3 = "cow";
        LNode node1 = new LNode(k1, "Excuse, Technical, Technician, Torch");
        LNode node2 = new LNode(k2, "This is typical excuse for being late");
        LNode node3 = new LNode(k3, "Please elaborate your question, please clarify your intention, The wound will heal up");

        lru.insert(k1, node1);
        lru.insert(k2, node2);
        lru.insert(k3, node3);

        lru.print();

        Aron.end();
    }
    static void test1() {
        Aron.beg();
        LRU lru = new LRU(3);
        String k1 = "dog";
        String k2 = "cat";
        String k3 = "cow";
        String k4 = "pig";

        LNode node1 = new LNode(k1, "First, Excuse, Technical, Technician, Torch");
        LNode node2 = new LNode(k2, "Second, This is typical excuse for being late");
        LNode node3 = new LNode(k3, "Third, Please elaborate your question, please clarify your intention, The wound will heal up");
        LNode node4 = new LNode(k4, "Fourth, Injuring 100 people and wounding 20 people in the bombing near the market in Thailand");

        lru.insert(k1, node1);
        lru.insert(k2, node2);
        lru.insert(k3, node3);
        lru.insert(k4, node4);

        lru.print();

        Aron.end();
    }
}

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class SingleLinkedList_test{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    public static void test0(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        sll.append(n1);
        sll.print();

        Aron.end();
    }

    public static void test1(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        sll.append(n1);
        sll.remove(n1);

        sll.print();

        Aron.end();
    }

    public static void test2(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

//        sll.remove(n1);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 1);
        Test.t(list.get(1).data == 2);
        Test.t(list.get(2).data == 3);

        sll.print();

        Aron.end();
    }
    public static void test3(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n1);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 2);
        Test.t(list.get(1).data == 3);

        sll.print();

        Aron.end();
    }
    public static void test4(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n2);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 1);
        Test.t(list.get(1).data == 3);

        sll.print();

        Aron.end();
    }

    public static void test5(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n3);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 1);
        Test.t(list.get(1).data == 2);

        sll.print();

        Aron.end();
    }

    public static void test6(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n1);
        sll.remove(n2);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 3);

        sll.print();

        Aron.end();
    }
    public static void test7(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n1);
        sll.remove(n2);
        sll.remove(n3);
        List<Node> list = sll.toList();
        Test.t(list.size() == 0);

        sll.print();

        Aron.end();
    }
} 

import classfile.*;

class RunnableThread implements Runnable {
    String name;
    public void run() {
        Foo f = Foo.getInstance();
        Print.pb(f.getNum());
    }
}

final class Foo{
    private static volatile Foo single;
    private static int num = 0;
    private Foo(){
    }

    public synchronized static Foo getInstance(){
        if(single == null){
            single = new Foo();
            Print.pb("an Object is created first time");
        }
        else{
            Print.p("an Object has been created");
        }
        return single;
    }
    public int getNum(){
        return num;
    }
}
   
public class Singleton{
    public static void main(String[] args){
        test1();
    }
    
    static void test1(){
        Aron.beg();
        for(int i=0; i<10; i++) {
            Thread t1 = new Thread(new RunnableThread());
            t1.start();
        }
        Aron.end();
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

class Interval implements Comparable<Interval> {
    public int begin;
    public int end;
    public Interval(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }
    public int compareTo(Interval inter) {
        if(this.begin > inter.begin)
            return 1;
        else if(this.begin == inter.begin)
            return 0;
        else
            return -1;
    }
    public String toString() {
        return "[" + begin + " " + end + "]";
    }
}

public class Hello {
    public static void main(String[] args) {
        test0();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test00();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
        test19();
    }
    static void test00() {
        Aron.beg();
        PriorityQueue<Interval> queue = new PriorityQueue<Interval>();
        Stack<Interval> stack = new Stack<Interval>();
        int[] arr1 = {4, 1, 2, 6, 9};
        int[] arr2 = {5, 1, 4, 9, 10};

        for(int i=0; i<arr1.length; i++) {
            queue.add(new Interval(arr1[i], arr2[i]));
        }
        if(queue.size() > 0) {
            stack.push(queue.remove());
        }
        while(!queue.isEmpty()) {
            Interval top = stack.peek();
            Interval inter = queue.remove();
            if(top.end < inter.begin)
                stack.push(inter);
            else {
                stack.peek().end = Math.max(stack.peek().end, inter.end);
            }
        }
        while(!stack.empty()) {
            System.out.println("[" + stack.peek().begin + " " + stack.peek().end + "]");
            stack.pop();
        }

        Aron.end();
    }

    static void test0() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(5);
        sll.append(4);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = cloneLinkedList(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test2() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test3() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        sll.append(4);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test4() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test5() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test6() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test7() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseLinkedList(sll.head);
        Aron.printSLL(nhead);

        Aron.end();
    }

    static void test8() {
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseIte(sll.head);
        Aron.printSLL(nhead);
        Aron.end();
    }

    static void test9() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);

        SingleLinkedList sll2 = new SingleLinkedList();
        sll2.append(1);
        sll2.append(2);
        sll2.append(3);


        Node curr = sll.head;
        Node head = sll.head;

        while(curr != null && curr.next != null) {
            curr = curr.next;
        }
        curr.next = head;

        boolean circular = isCircular(sll.head);
        System.out.println("isCircular[" + circular + "]");

        boolean circular2 = isCircular(sll2.head);
        System.out.println("isCircular2[" + circular2 + "]");

        Aron.end();
    }
    static void test10(){
        Aron.beg();
        String str = "";
        System.out.println("empty str " + str + "[" + isBalance(str) + "]");

        str = "()";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "([)]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "()([])";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        Aron.end();
    }
    
    static void test11(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test12(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        h = insertNodeToSortedList(ssl.head, 5);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test13(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node newHead = insertNodeToSortedList(ssl.head, 15);
        Aron.printSLL(newHead);
        Aron.end();
    }

    static void test14(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);
        s1.append(7);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        s2.append(6);
        s2.append(11);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test15(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test16(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test17(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test18(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }
    static void test19(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(4);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    //[ file=nextnext.html title=""
    public static Node reverseIte(Node curr) {
        Node prev = null;
        Node next = null;
        while(curr != null) {
            next = curr.next;
            curr.next = prev;

            prev = curr;
            curr = next;
        }
        return prev;
    }

    public static Node reverseLinkedList(Node curr) {
        if(curr == null || curr.next == null)
            return curr;

        Node head = reverseLinkedList(curr.next);
        curr.next.next = curr;
        curr.next = null;

        return head;
    }

    public static Node reversePair(Node head) {
        Node curr = head;
        while(curr != null && curr.next != null) {
            int tmp = curr.data;
            curr.data = curr.next.data;
            curr.next.data = tmp;

            curr = curr.next.next;
        }
        return head;
    }

    public static boolean isCircular(Node curr) {
        if(curr == null)
            return false;
        else {
            Node next = curr.next;
            if(curr == next)
                return true;

            while(next != null) {
                if(curr == next)
                    return true;

                curr = curr.next;

                next = next.next;
                if(next != null)
                    next = next.next;
            }
        }
        return false;
    }
    //]


    static Node cloneLinkedList(Node head) {
        Node newHead = null;
        Node newCurr = null;
        Node curr = head;

        if(curr != null) {
            newCurr = newHead = new Node(head.data);

            while(curr.next != null) {
                newCurr.next = new Node(curr.next.data);
                newCurr = newCurr.next;
                curr = curr.next;
            }
        }
        return newHead;
    }

//    static boolean isBal(String str, int index){
//        if(str != null && index < str.length()){
//            if(!isBal(str, index + 1))
//                return false;
//
//            if(str.charAt(index) == '(' || str.charAt(index) == '[')
//                return isBal(str, index + 1);
//            else
//                return false;
//
//            else if(str.charAt(index) == ')'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '(') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }else if(str.charAt(index) == ']'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '[') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }
//        }
//        return true;
//    }

    static Node mergeSortedList(Node head1, Node head2){
        if(head1 == null)
            return head2;
        if(head2 == null)
            return head1;
        Node curr1 = head1;
        Node curr2 = head2;
        Node curr = null; 
        Node head = null;

        while(curr1 != null || curr2 != null){
            if(curr1 == null){
                if(curr != null)
                    curr.next = new Node(curr2.data);
                else
                    head = curr = new Node(curr2.data);

                curr2 = curr2.next;

            }else if(curr2 == null){
                if(curr != null)
                    curr.next = new Node(curr1.data);
                else
                    head = curr = new Node(curr1.data);

                curr1 = curr1.next;
            }else{
                if(curr1.data < curr2.data){
                    if(curr == null){
                        head = curr = new Node(curr1.data);
                    }else{
                        curr.next = new Node(curr1.data);
                    }

                    curr1 = curr1.next;
                }else{
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else{
                        curr.next = new Node(curr2.data);
                    }

                    curr2 = curr2.next;
                }
            }

            if(curr.next != null)
                curr = curr.next;
        }
        return head;
    }

    static Node insertNodeToSortedList(Node head, int num){
       Node curr = head; 
       Node prev = null;

       while(curr != null){
           if(curr.data < num){
               prev = curr;
               if(curr.next == null){
                   prev.next = new Node(num);
                   return head;
               }
           }else{
               if(prev != null){
                   prev.next = new Node(num);
                   prev.next.next = curr;
                   return head;
               }else{
                   // first node
                   Node node = new Node(num);
                   node.next = curr;
                   head = node;
                   return head;
               }
           }
           curr = curr.next;
       }
       return head;

    }

    static boolean isBalance(String str) {
        Stack<String> stack = new Stack<String>();
        if(str != null) {
            for(int i=0; i<str.length(); i++) {
                String s = str.charAt(i) + "";
                if(s.equals("(") || s.equals("[")) {
                    stack.push(s);
                } else {
                    if(s.equals(")")) {
                    if(!stack.empty() && stack.peek().equals("(")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else if(s.equals("]")) {
                    if(!stack.empty() && stack.peek().equals("[")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else {
                        System.out.println("Error");
                        return false;
                    }

                }
            }
        }
        return stack.empty();
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class SortArray{
    public static void main(String[] args) {
        String[] arr = {"techie", "dangling", "cat", "scene", "ancestor", "scene", "descend", "descended", "sibling", "dangling"}; 
        List<String> list = sortArray(arr);
        Aron.printList(list);
    }
    public static List<String> sortArray(String[] arr){
        Arrays.sort(arr);
        return Arrays.asList(arr);
    }

    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.List;
import java.util.ArrayList;
import classfile.*;

// sorted linkedlist, sorted linked list

class SingleLinkedList {
    Node head;
    public SingleLinkedList() {
        head = null;
    }
    public void append(Node no) {
        Node cur = head;
        if(head == null)
            head = no;
        else {
            while(cur.next != null) {
                cur = cur.next;
            }
            cur.next = no;
        }
    }
    public void append(int n) {
        Node cur = head;
        if(head == null)
            head = new Node(n);
        else {
            while(cur.next != null) {
                cur = cur.next;
            }
            cur.next = new Node(n);
        }
    }

    //recursive
    static Node next=null;
    public void Reverse(Node cur) {
        if(cur != null) {
            Reverse(cur.next);
            if(next != null)
                next.next = cur;
            else
                head = cur;
            next = cur;
            cur.next = null;
        }
    }
    //iteration
    public void Reverse1(Node cur) {
        if(head != null) {
            Node prev = null;
            Node next = cur.next;

            while(cur != null) {
                cur.next = prev;
                prev = cur;
                cur = next;
                if(next != null)
                    next = next.next;
            }
            head = prev;

        }
    }
    public Node getHead() {
        return head;
    }
    public void Remove(Node no) {
        if(no != null && head != null) {
            Node cur = head;
            Node prev = null;
            while(cur != no) {
                prev = cur;
                cur = cur.next;
            }
            if(prev != null && no.next != null) {
                prev.next = no.next;
                no.next = null;
            } else if(prev == null && no.next != null) {
                head = no.next;
                no.next = null;
            } else if(prev != null && no.next == null) {
                prev.next = null;
            } else {
                no = null;
                head = null;
            }
        }
    }
}


//simple sort linked list algorithm
public class SortLinkedList {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(4);
        sll.append(3);
        sll.append(2);
        sll.append(9);
        sll.append(6);
        sll.append(8);
        sll.append(1);
        sll.append(7);


        Aron.line();
        sort(sll.getHead());
        Aron.printSLL(sll.head);

    }

    // [2, 4, 5, 7]
    // [2, 4, 5]
    // [2, 4]
    public static void sort(Node head) {
        if(head != null && head.next != null) {
            Node curr = head;
            Node last = null;
            while(head != last) {
                Node next = curr.next;

                while(next != last) {
                    Print.pbl(curr.data + " " + next.data);
                    if(curr.data > next.data) {
                        int tmp = curr.data;
                        curr.data = next.data;
                        next.data = tmp;
                    }
                    curr = next;
                    next = next.next;
                }
                Aron.line();

                last = curr;
                curr = head;
            }
        }
    }
}
package JavaLib.classfile; 

import classfile.*;

public class SortedLinkedList{
    public Node insert(Node node, int n){
        Node head = node;
        Node curr = node; 
        Node prev = null; 
        while(curr != null && n > curr.data){
            prev = curr;
            curr = curr.next;
        }

        if(curr != null){
            if(prev != null){
                // 3, [2]<-[4]  >  [2]<-{3}<-[4]
                prev.next = new Node(n);
                prev.next.next = curr;
            }else{
                // {1} [2] > {1}<-[2]
                head = new Node(n);
                head.next = curr;
            }
        }else{
            // [2] {3}  > [2]<-{3}
            if(prev != null){
                prev.next = new Node(n);
            }else{
                // {3}
                head = new Node(n);
            }
        }
        return head;
    }
} 
import java.util.*;
import java.io.*;
import classfile.*;

import java.io.IOException;

// spawn new process, spawn process, create process, create new process
public class SpawnProcess{
    public static void main(String[] args) {
        String cmd = "/opt/local/bin/mvim";
        Aron.spawnProcess(cmd);
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class MySpiral {
    final int height=4;
    final int width=4;
    int[][] Arr = new int[height][width];
    Integer[][] A = new Integer[height][width];

    public MySpiral() {
        int c=0;
        for(int i=0; i<height; i++)
            for(int j=0; j<width; j++)
                A[i][j] = Arr[i][j] = c++;

        for(int i=0; i<height; i++) {
            for(int j=0; j<width; j++) {
                if(Arr[i][j]/10 == 0)
                    System.out.print("["+Arr[i][j]+" ] ");
                else
                    System.out.print("["+Arr[i][j]+"] ");
            }
            System.out.print("\n");
        }
    }
    public void printSpiral2(int[][] Arr, int nRow, int nCol) {
        int min = nCol>nRow?nRow:nCol;
        if(nRow == 1) {
            for(int i=0; i<nCol; i++)
                System.out.print("{"+Arr[0][i]+"}");
        } else if(nCol == 1) {
            for(int i=0; i<nRow; i++)
                System.out.print("{"+Arr[i][0]+"}");
        } else {
            for(int k=0; k<(min%2==1?min/2+1:min/2); k++) {
                for(int j=k; j<nCol-1-k; j++)
                    System.out.print("{"+Arr[k][j]+"}");
                System.out.print("\n");
                for(int i=k; i<nRow-1-k; i++)
                    System.out.print("{"+Arr[i][nCol-1-k]+"}");
                System.out.print("\n");
                for(int j=k; j<nCol-1-k; j++)
                    System.out.print("{"+Arr[nRow-1-k][nCol-1-j]+"}");
                System.out.print("\n");
                for(int i=k; i<nRow-1-k; i++)
                    System.out.print("{"+Arr[nRow-1-i][k]+"}");
                System.out.print("\n");
            }
        }

    }

    public void printSpiralRecursion(int[][] array, int nRow, int nCol, int k) {
        if(nRow-2*k > 0 && nCol-2*k > 0) {
            if(nRow - 2*k == 1) {
                for(int i=k; i<nCol-k; i++)
                    System.out.print("["+array[k][i]+"]");
                System.out.print("\n");
            } else if(nCol - 2*k == 1) {
                for(int i=k; i<nRow-k; i++)
                    System.out.print("["+array[i][k]+"]");
                System.out.print("\n");
            } else {
                for(int i=k; i<nCol-1-k; i++) {
                    System.out.print("["+array[k][i]+"]");
                }
                System.out.print("\n");
                for(int i=k; i<nRow-1-k; i++) {
                    System.out.print("["+array[i][nCol-1-k]+"]");
                }
                System.out.print("\n");
                for(int i=k; i<nCol-1-k; i++) {
                    System.out.print("["+array[nRow-1-k][nCol-1-i]+"]");
                }
                System.out.print("\n");
                for(int i=k; i<nRow-1-k; i++) {
                    System.out.print("["+array[nRow-1-i][k]+"]");
                }
                System.out.print("\n");
                printSpiralRecursion(array, nRow, nCol, k+1);
            }
        }
    }

    // assume width > height
    public void printSpiral4(int[][] array, int height, int width) {
        if(array != null) {
            for(int i=0; i < (height > width? height: width); i++) {
                if(width >= height && height - 2*i == 1) {
                    for(int w=i; w < width-i; w++)
                        System.out.println(array[i][w]);
                    return;
                } else if(width < height && width - 2*i == 1) {
                    for(int h=i; h < height-i; h++)
                        System.out.println(array[h][i]);
                    return;
                } else {
                    for(int w=i; w < width-1-i; w++)
                        System.out.println(array[i][w]);

                    for(int h=i; h < height-1-i; h++)
                        System.out.println(array[h][width - 1 - i]);

                    for(int w=i; w < width-1-i; w++)
                        System.out.println(array[height - 1 - i][width - 1 - w]);

                    for(int h=i; h < height-1-i; h++)
                        System.out.println(array[height - 1 - h][i]);
                }
            }
        }
    }

    public void printSpiralSnake(int[][] array, int width, int height) {
        Set<Integer> hashSet = new HashSet<Integer>();
        if(array != null) {
            int c=0, r=0;
            int turn = 0;
            int count = 0;
            boolean print = true;
            while(count < width*height) {
                if(print) {
                    System.out.print("["+c+","+r+"]");
                    hashSet.add(c*width+r);
                    count++;
                }
                if(turn % 4 == 0 && r+1 < width && !hashSet.contains(c*width + r + 1)) {
                    r++;
                    print = true;
                } else if(turn % 4 == 1 && c+1 < height && !hashSet.contains((c+1)*width + r)) {
                    c++;
                    print = true;
                } else if(turn % 4 == 2 && r-1 >= 0 && !hashSet.contains(c*width + r - 1)) {
                    r--;
                    print = true;
                } else if(turn % 4 == 3 && c-1 >= 0 && !hashSet.contains((c-1)*width + r)) {
                    c--;
                    print = true;
                } else {
                    print = false;
                    System.out.println();
                    turn++;
                }
            }
        }
    }
    public void test1() {
        System.out.println("test1 printSpiral4()");
        printSpiral4(Arr, height, width);
    }
    public void test2() {
        System.out.println("test2 printSpiralSnake()");
        printSpiralSnake(Arr, width, height);
    }
    public void test3() {
        System.out.println("test3 printSpiralRecursion()");
        int k=0;
        printSpiralRecursion(Arr, height, width, k);
    }


}


class Spiral {
    public static void main(String args[]) {
        MySpiral spiral = new MySpiral();
        spiral.test1();
        spiral.test2();
        spiral.test3();

        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();

        test00_spiral2();
        test01_spiral2();
        test02_spiral2();
        test03_spiral2();
    }
    public static void test1() {
        System.out.println("test1");
        int[][] array = {
            {1,2,3}
        };
        int k=0;
        spiralArray(array, k);
    }
    public static void test2() {
        System.out.println("test1");
        int[][] array = {
            {1,2,3},
            {4,5,6}
        };
        int k=0;
        spiralArray(array, k);
    }

    public static void test3() {
        System.out.println("test3");
        int[][] array = {
            {1,2,3},
            {4,5,6},
            {7,8,9},
            {10,11,12}
        };
        int k=0;
        spiralArray(array, k);
    }

    public static void test4() {
        System.out.println("test4");
        int[][] array = {
            {1}
        };
        int k=0;
        spiralArray(array, k);
    }
    public static void test5() {
        System.out.println("test5");
        int[][] array = {
            {1,2,3},
            {4,5,6},
            {7,8,9},
            {10,11,12},
            {13,14,15}
        };
        int k=0;
        spiralArray(array, k);
    }
    public static void test6() {
        System.out.println("test6");
        int[][] array = {
            {1,2,3,4},
            {5,6,7,8}
        };
        Aron.printArray2D(array);
        System.out.println("-----------------");
        int k=0;
        spiralArray(array, k);
    }
    public static void test7() {
        System.out.println("test7");
        int[][] array = {
            {1,2},
            {5,6}
        };
        Aron.printArray2D(array);
        System.out.println("-----------------");
        int k=0;
        spiralArray(array, k);
    }

    public static void test8() {
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
        };
        Aron.printArray2D(arr2d);
        int k = 0;
        spiralArray(arr2d, k);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test9() {
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
            { 13,   14,  15, 16},
            { 17,   18,  19, 20},
        };
        Aron.printArray2D(arr2d);
        int k = 0;
        spiralArray(arr2d, k);
        Aron.printArray2D(arr2d);

        Aron.end();
    }

    public static void spiralArray(int[][] array, int k) {
        if(array != null && array.length > 0) {
            int hlen= array.length;
            int wlen= array[0].length;

            if(hlen - 2*k == 1) {
                for(int i=k; i<wlen-k; i++) {
                    Print.p(array[k][i]);
                }
            } else if(wlen -2*k ==1) {
                for(int i=k; i<hlen-k; i++) {
                    Print.p(array[i][k]);
                }
            } else if(k < hlen/2 && k < wlen/2) {
                for(int w=k; w<wlen-1-k; w++) {
                    Print.p(array[k][w]);
                }
                for(int h=k; h<hlen-1-k; h++) {
                    Print.p(array[h][wlen-1-k]);
                }
                for(int w=k; w<wlen-1-k; w++) {
                    Print.p(array[hlen-1-k][wlen-1-w]);
                }
                for(int h=k; h<hlen-1-k; h++) {
                    Print.p(array[hlen-1-h][k]);
                }
                spiralArray(array, k+1);
            }
        }
    }

    //[ file=spiralbest.html title="" 
    //
    // [1]
    // [1, 2]
    // [3, 4]
    // [0][0] = 1
    // [0][1] = 2
    // [1][1] = 4
    // [1][0] = 3
    // k = 1
    //
    //
    // [1, 2, 3]
    // [4, 5, 6]
    // [7, 8, 9]
    // [1, 2] [3, 6] [9, 8] [7, 4]
    // [5]
    //
    // last update 
    // Tue Sep 27 02:24:44 PDT 2016
    // best working version
    public static void spiral2(int[][] arr, int k){
        if(arr != null && arr.length > 0){
            int h = arr.length;
            int w = arr[0].length;
            
            if(h - 2*k == 1){
                for(int i=k; i<w-k; i++){
                    Print.p(arr[k][i]);
                }
            }else if(w - 2*k == 1){
                for(int i=k; i<h-k; i++){
                    Print.p(arr[i][k]);
                }
            }else if(k < Math.min(h, w)/2){
                for(int i=k; i<w-1-k; i++){
                    Print.p(arr[k][i]);
                } 
                for(int i=k; i<h-1-k; i++){
                    Print.p(arr[i][w-1-k]);
                } 
                for(int i=k; i<w-1-k; i++){
                    Print.p(arr[h-1-k][w-1-i]);
                } 
                for(int i=k; i<h-1-k; i++){
                    Print.p(arr[h-1-i][k]);
                } 
                spiral2(arr, k+1);
            }
        }
    }
    //]
    public static void test0_spiral(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
            { 13,  14,  15, 16},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 
        Aron.printArray2D(arr2d);
        spiral(arr2d);
        Aron.printArray2D(arr2d);
        Aron.end();
    }
    public static void test1_spiral(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 
        Aron.printArray2D(arr2d);
        spiral(arr2d);
        Aron.printArray2D(arr2d);
        Aron.end();
    }
    public static void test00_spiral2(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
        };
        int k = 0;
        Aron.printArray2D(arr2d);
        spiral2(arr2d, k);
        Aron.printArray2D(arr2d);
        Aron.end();
    }
    public static void test01_spiral2(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
        };
        int k = 0;
        Aron.printArray2D(arr2d);
        spiral2(arr2d, k);
        Aron.printArray2D(arr2d);
        Aron.end();
    }
    public static void test02_spiral2(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1,   2,   3,  4},
        };
        int k = 0;
        Aron.printArray2D(arr2d);
        spiral2(arr2d, k);
        Aron.printArray2D(arr2d);
        Aron.end();
    }
    public static void test03_spiral2(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1,   2,   3},
        };
        int k = 0;
        Aron.printArray2D(arr2d);
        spiral2(arr2d, k);
        Aron.printArray2D(arr2d);
        Aron.end();
    }
    public static void test04_spiral(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1,   2,   3},
            { 5,   6,   7},
            { 9,   10,  11},
            { 13,  14,  15},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 
        Aron.printArray2D(arr2d);
        spiral(arr2d);
        Aron.printArray2D(arr2d);
        Aron.end();
    }

    public static void spiral(int[][] arr){
        if(arr != null && arr.length > 0){
            int h = arr.length;
            int w = arr[0].length;
            int k = 0;
            int min = Math.min(w, h);
            while(k <= Math.min(w, h)/2){
                if(w- 2*k == 1){
                    for(int i=k; i<h-k; i++){
                        Print.p(arr[i][k]);
                    }
                    break;
                }else if(h - 2*k == 1){
                    for(int i=k; i<w-k; i++){
                        Print.p(arr[k][i]);
                    }
                    break;
                }else if(k < Math.min(w, h)/2){
                    for(int i=k; i<w-1-k; i++){
                        Print.p(arr[k][i]);
                    }
                    for(int i=k; i<h-1-k; i++){
                        Print.p(arr[i][w-1-k]);
                    }
                    for(int i=k; i<w-1-k; i++){
                        Print.p(arr[h-1-k][w-1-i]);
                    }
                    for(int i=k; i<h-1-k; i++){
                        Print.p(arr[h-1-i][k]);
                    }
                }else{
                    break;
                }
                k++;
            }
        }
    }
}
import java.io.*;
class Split 
{
	public static void main(String args[])
	{
		String str= "20.123.111.33";
		String[] Arr = str.split("\\.");
		for(int i = 0; i < Arr.length; i++)
		{
			System.out.println(Arr[i]);
		}
	}
	
}
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Stack;

public class SplitExpression{

    public static void main(String[] args) {
        test0();
    }

    //[ file=splitexp.html title=""
    public static List<String> splitExpr(String exp){
        List<String> list = new ArrayList<String>();

        StringTokenizer stoken = new StringTokenizer(exp, "+-/* ", true);
        while(stoken.hasMoreTokens()){
            String token = stoken.nextToken();
            list.add(token);
            //System.out.println(token);
        }
        return list;
    }
    //]
    
    public static int evaluate(List<String> list){
        Stack<Integer> stack = new Stack<Integer>(); 
        for(String token : list){
            if(token == "+" || token == "/" || token == "-" || token == "*"){
                int value = 0;
                int first = Integer.parseInt(stack.top());
                stack.pop();
                int second = Integer.parseInt(stack.top());
                stack.pop();
                if( token == "+")
                    value = first + second; 
                else if ( token == "-")
                    value = second - first;
                else if ( token == "*")
                    value = first * second;
                else if( token == "/")
                    value = second / first;
                stack.push(value + "");
            }else{
                stack.push(token);
            }
        }
    } 

    static void test0(){
        System.out.println("---------------------------------\n");
        String exp = "512 + 4 × + 3 −";
        List<String> list = splitExpr(exp);
        Aron.printList(list);
        System.out.println("---------------------------------\n");
    }
}
import java.util.*;
import java.io.*;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import classfile.*;

// Notice, do not import com.mysql.jdbc.*
// or you will have problems!

public class SqlConnection{
    public static void main(String[] args) {
        Connection connect = null;
        Statement statement = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {

            // -----------------------------------------------------
            // database: testdb
            // table: item
            // user: root
            // password: {empty}
            // no ssh: autoReconnect=true&useSSL=false 
            //-------------------------------------------------------------------------------- 
            Class.forName("com.mysql.jdbc.Driver").newInstance();
            connect = DriverManager
                      .getConnection("jdbc:mysql://localhost/testdb?autoReconnect=true&useSSL=false&"
                                     + "user=root&password=");

            // Statements allow to issue SQL queries to the database
            statement = connect.createStatement();
            // Result set get the result of the SQL query
            resultSet = statement
                        .executeQuery("select * from testdb.item");
            if(resultSet.next()){
                // get the second column
               String name = resultSet.getString(2);
                Print.pbl(name);
            }
        }catch (Exception ex) {
            // handle the error
            Print.pbl(ex.getMessage());
        }
    }
}
import java.io.*;
class Square 
{
	public static void main(String args[])
	{
        double n = 0.9;
		sqrt(n);
        double value = sqrt2(n, 0.00001);
        System.out.println("real sqrt(value)=" + Math.sqrt(n));
        System.out.println("value=" + value);
	}
	public static double sqrt(double n)
	{
		double a = 1.0;
		double b = n/2;

		for(int i = 0; i < 10; i++)
		{
			if( ((a + b)/2)*((a + b)/2) > n)
			{
				b = (a + b)/2;
			}
			else if( ((a + b)/2)*((a + b)/2) < n)
			{
				a = (a + b)/2;
			}
			else if( ((a + b)/2)*((a + b)/2) == n)
			{

			}
			System.out.println("a=" + a + " b=" + b);
		}
		return a;	
	}
    //Precondition: n is integer and greater than or equal zero 
    public static double sqrt2(double n, double error)
    {
        double left = 0;
        double right = n; 
        double value = 0;
        double diff = 2*error;
        while(Math.abs(diff) > error)
        {
            value = (left + right)/2;
            diff = value*value - n;
            if(diff > 0)
            {
                right = value;
            }
            else if(diff < 0)
            {
                left = value;
            }
            else
                break;
        }
        return value;
    }
}
import java.util.*;

//unique solution
//{3,0,0,2,0,0,0,0,0},
//{0,0,0,1,0,7,0,0,0},
//{7,0,6,0,3,0,5,0,0},
//{0,7,0,0,0,9,0,8,0},
//{9,0,0,0,2,0,0,0,4},
//{0,1,0,8,0,0,0,5,0},
//{0,0,9,0,4,0,3,0,1},
//{0,0,0,7,0,2,0,0,0},
//{0,0,0,0,0,8,0,0,6}

class Sudoku {
    final int gridSize = 9;
    int[][] array;
    int[][] board = {
                    //{0,0,0,0},
                    //{0,0,0,0},
                    //{0,0,0,0},
                    //{0,0,0,0}
        
                    {0,0,0,2,0,0,0,0,0},
                    {0,0,0,1,0,7,0,0,0},
                    {0,0,6,0,3,0,5,0,0},
                    {0,0,0,0,0,9,0,8,0},
                    {0,0,0,0,2,0,0,0,4},
                    {0,0,0,8,0,0,0,5,0},
                    {0,0,9,0,4,0,3,0,1},
                    {0,0,0,7,0,2,0,0,0},
                    {0,0,0,0,0,8,0,0,6}
            };

    /*
    int[][] board = {
                    {3,0,0,2,0,0,0,0,0},
                    {0,0,0,1,0,7,0,0,0},
                    {7,0,6,0,3,0,5,0,0},
                    {0,7,0,0,0,9,0,8,0},
                    {9,0,0,0,2,0,0,0,4},
                    {0,1,0,8,0,0,0,5,0},
                    {0,0,9,0,4,0,3,0,1},
                    {0,0,0,7,0,2,0,0,0},
                    {0,0,0,0,0,8,0,0,6}
        
                    //{0,0,0,2,0,0,0,0,0},
                    //{0,0,0,1,0,7,0,0,0},
                    //{0,0,6,0,3,0,5,0,0},
                    //{0,0,0,0,0,9,0,8,0},
                    //{0,0,0,0,2,0,0,0,4},
                    //{0,0,0,8,0,0,0,5,0},
                    //{0,0,9,0,4,0,3,0,1},
                    //{0,0,0,7,0,2,0,0,0},
                    //{0,0,0,0,0,8,0,0,6}
            };
            */

    int numEmpty;
    public Sudoku() {
        array = new int[gridSize*gridSize][2];
        numEmpty = findEmptyNumber();
    }
    public void printBoard() {
        System.out.println();
        for(int c=0; c<gridSize; c++) {
            for(int r=0; r<gridSize; r++) {
                System.out.print("["+board[c][r]+"]");
            }
            System.out.println();
        }
        System.out.println();
    }

    public void solver(int k) {
        if(k == numEmpty) {
            printBoard();
        }
        else {
            int c = array[k][0];
            int r = array[k][1];
            for(int i=1; i<=gridSize; i++) {
                if(checkColRow(c, r, i) && checkSquare(c, r, i)) {
                    board[c][r] = i;
                    solver(k+1);
                    board[c][r] = 0;
                }
            }
        }
    }

    public void solver_Graph(int k, int[] arr) {
        if(k == numEmpty) {
            //printBoard();
            int hc = arr[0]/4;
            int hr = arr[0]%4;
            String childStr = "\"[" + hc + "," + hr + "]\"";
            String childLabel = childStr + "[style=filled, fillcolor=green];";
            System.out.println(childLabel);
        }
        else {
            int c = array[k][0];
            int r = array[k][1];
            int ec = arr[0]/4;
            int er = arr[0]%4;
            String parentStr = "\"[" + ec + "," + er + "]\"";
            int parent = arr[0];
            for(int i=1; i<=gridSize; i++) {
                arr[0] += 1;
                int child = arr[0];
                int hc = arr[0]/4;
                int hr = arr[0]%4;
                String childStr = "\"[" + hc + "," + hr + "]\"";
                System.out.println(parentStr +"->"+ childStr); 
                if(checkColRow(c, r, i) && checkSquare(c, r, i)) {
                    board[c][r] = i;
                    solver_Graph(k+1, arr);
                    board[c][r] = 0;
                }
            }
        }
    }


    public int findEmptyNumber() {
        int count = 0;
        for(int c=0; c<gridSize; c++) {
            for(int r=0; r<gridSize; r++)
                if(board[c][r] == 0) {
                    array[count][0]=c;
                    array[count][1]=r;
                    count++;
                }
        }
        return count;
    }

    public boolean checkColRow(int c, int r, int num) {
        for(int i=0; i<gridSize; i++) {
            if(board[c][i] == num || board[i][r] == num)
                return false;    
        }
        return true;
    }
    
    public boolean checkSquare(int col, int row, int num) {
        int blockSize = (int)Math.sqrt(gridSize);
        int qcol = col/blockSize;
        int qrow = row/blockSize;
        for(int c = 0; c<blockSize; c++) {
            for(int r = 0; r<blockSize; r++) {
                if(board[qcol*blockSize+c][qrow*blockSize+r] == num)
                    return false;
            }
        }
        return true;
    }
}

public class SudokuSolver {
    public static void main(String[] args) {
        Sudoku s = new Sudoku();
        int k=0;
        //s.solver(k);
        int[] arr = {0};
        System.out.println("digraph G {\n");
        //s.solver_Graph(k, arr);
        s.solver(k);

        System.out.println("}\n");
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class SudokuSolverNew{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        int[][] arr2d = {
                        {0,0,0,2,0,0,0,0,0},
                        {0,0,0,1,0,7,0,0,0},
                        {0,0,6,0,3,0,5,0,0},
                        {0,0,0,0,0,9,0,8,0},
                        {0,0,0,0,2,0,0,0,4},
                        {0,0,0,8,0,0,0,5,0},
                        {0,0,9,0,4,0,3,0,1},
                        {0,0,0,7,0,2,0,0,0},
                        {0,0,0,0,0,8,0,0,6}
                };
        int index = 0;
        int size = 0; 

        for(int i=0; i<9; i++){
            for(int j=0; j<9; j++){
                if(arr2d[i][j] == 0)
                    size++;
            }
        } 

        sudokuSolver(arr2d, index);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    // given 2d array and find a solution for the sudoku
    // 9x9 grid contains the number from 1 to 9
    // -------------------------------------------------------------------------------- 
    // each 3x3 grid contains the number from 1 to 9   
    // each row or column contains the number from 1 to 9
    // -------------------------------------------------------------------------------- 
    public static void sudokuSolver(int[][] arr2d, int index){ 
        int c = index / 9;
        int r = index % 9;
        if(index == 81){
            Aron.printArray2D(arr2d);
        }else{
            if(arr2d[c][r] == 0){
                for(int i=1; i<=9; i++){
                    if(checkSquare(arr2d, c, r, i) && checkColRow(arr2d, c, r, i)){
                        arr2d[c][r] = i; 
                        sudokuSolver(arr2d, index+1);
                        arr2d[c][r] = 0;
                    }
                }
            }else
                sudokuSolver(arr2d, index+1);
         }
    }

    public static boolean checkSquare(int[][] arr2d, int col, int row, int testNum){
        int ic = col/3;
        int ir = row/3;
        for(int c=0; c<3; c++){
            for(int r=0; r<3; r++){
                if(arr2d[c + ic*3][r + ir*3] == testNum) 
                    return false;
            }
        } 
        return true;
    }
    public static boolean checkColRow(int[][] arr2d, int c, int r, int testNum){
        for(int i=0; i<9; i++){
            if(arr2d[c][i] == testNum || arr2d[i][r] == testNum)
                return false;
        }
        return true;
    }
    
} 

import java.util.*;

class Node
{
    Map<Character, Node> map = new HashMap<Character, Node>();
    boolean isWord = false;
    public Node(){}
}

class Tries
{
    Node root;
    public Tries()
    {
        root = new Node();
    }
    public void print(Node curr, List<Character> list)
    {
        if(curr != null)
        {   
            if(curr.isWord)
            {
                for(Character chara:list)
                {
                    System.out.print("["+chara+"]");
                }
                System.out.println();
            }
            for(Character ch: curr.map.keySet())
            {
                list.add(ch);
                print(curr.map.get(ch), list);
                list.remove(ch);
            }
        }
    }
}

public class SuffixTree 
{
    public static void main(String[] args)
    {
        test1();
        test2();
    }
    public static void test1()
    {
        System.out.println("test1()");
        Tries tri = new Tries();
        int depth = 0;
        List<Character> list = new LinkedList<Character>();
        Node myroot = tri.root;
        insert(tri.root, "dog", depth);
        insert(tri.root, "cat", depth);
        insert(tri.root, "human", depth);
        insert(tri.root, "animal", depth);
        insert(tri.root, "mono", depth);
        insert(tri.root, "momo", depth);
        insert(tri.root, "mo", depth);
        insert(tri.root, "mom", depth);
        tri.print(myroot, list);
        String pattern = "m";
        boolean ret = search(myroot, pattern);
        System.out.println("Find pattern=["+pattern+"]=["+ret+"]");
    }
    public static void test2()
    {
        System.out.println("test2()");
        Tries tri = new Tries();
        int depth = 0;
        List<Character> list = new LinkedList<Character>();
        Node myroot = tri.root;
        insert(tri.root, "dog", depth);
        insert(tri.root, "cat", depth);
        insert(tri.root, "human", depth);
        insert(tri.root, "animal", depth);
        insert(tri.root, "mono", depth);
        insert(tri.root, "momo", depth);
        insert(tri.root, "mo", depth);
        insert(tri.root, "mom", depth);
        tri.print(myroot, list);
        String pattern = "mom";
        boolean ret = search(myroot, pattern);
        System.out.println("Find pattern=["+pattern+"]=["+ret+"]");
    }
    public static void insert(Node root, String s, int depth)
    {
        if(depth == s.length())
        {
            if(root != null)
                root.isWord = true;
        } 
        else if(depth < s.length()) 
        {
            if(root == null)
            {
                root = new Node();
                Node subNode = new Node();
                root.map.put(s.charAt(depth), subNode); 
                insert(subNode, s, depth+1);
            }
            else
            {
                Character key = new Character(s.charAt(depth));
                Node child= root.map.get(key);
                if(child == null)
                    child = new Node();
                root.map.put(key, child);
                insert(child, s, depth+1);
            }
        }
    }
    public static boolean search(Node root, String pattern)
    {
        boolean ret = true;
        Node curr = root;
        if(curr != null && pattern != null)
        {
            for(int i=0; i<pattern.length() && ret; i++)
            {
                Character key = new Character(pattern.charAt(i));
                Node child = curr.map.get(key);        
                if(child != null)
                    curr = child;    
                else
                    ret = false;        
            }
            if(!curr.isWord)
               ret = false; 
        }
        return ret;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class SumIntegerPath 
{

	public static void main(String args[])
	{
        Test1();
	}
    public static void Test1()
    {
        BST b1 = new BST();
		b1.Insert(6);
        
		b1.Insert(3);
		b1.Insert(1);
        
		b1.Insert(7);
		b1.Insert(5);
		b1.Insert(2);
        
        int[] A = new int[10];
        int depth = 0;
        int sum = PathInteger(b1.getRoot(), depth, A);
        System.out.println("sum=["+sum+"]");
    }

    //Find the sum of all paths which form all the integer
    public static int PathInteger(Node curr, int depth, int[] A)
    {
        int sum = 0;
        if(curr != null)
        {
            A[depth]= curr.data;
            int lsub = PathInteger(curr.left, depth+1, A);
            int rsub = PathInteger(curr.right, depth+1, A);
            int s = 0;
            if(curr.left == null && curr.right == null)
            {
                for(int i=0; i<=depth; i++)
                {
                   s += A[i]*Math.pow(10, depth-i); 
                }
            }
            sum += lsub + rsub + s;
        }
        return sum;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class SwapBSTNode {
    public static void main(String args[]) {
//        test0();
//        test00();
        test000();
    }
    static void test0(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);

        b1.insert(17);
        b1.insert(199);
        b1.insert(16);

        Ut.l();

        Aron.inorder(b1.root);
        Aron.binImage(b1.root);
        Ut.l();

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        swap(199, 16, b1.root, first, second);
        Aron.binImage(b1.root);
        Aron.inorder(b1.root);
        Aron.end();
    }
    static void test00(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);

        b1.insert(17);
        b1.insert(199);
        b1.insert(16);

        Ut.l();

        Aron.inorder(b1.root);
        Aron.binImage(b1.root);
        Ut.l();

        Node tmp = null;
        swap2(b1.root, 199, 16, tmp);
        Aron.binImage(b1.root);
        Aron.inorder(b1.root);
        Aron.end();
    }
    static void test000(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);

        b1.insert(17);
        b1.insert(199);
        b1.insert(16);

        Ut.l();

        Aron.inorder(b1.root);
        Aron.binImage(b1.root);
        Ut.l();

        Node tmp = null;
        swap2(b1.root, 10, 16, tmp);
        Aron.binImage(b1.root);
        Aron.inorder(b1.root);
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    } 

    // old way to swap two nodes
    public static void swap(int m, int n, Node root, Node[] first, Node[] second) {
        if(root != null) {
            swap(m, n, root.left, first, second);
            if(root.data == m) {
                first[0] = root;
            } else if(root.data == n) {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null) {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    // better swap than the first one, don't need array any more
    public static Node swap2(Node r, int m, int n, Node tmp) {
        if(r != null){
            Node left = swap2(r.left, m, n, tmp);
            if(left == null){
                if(r.data == m){
                    if(tmp == null)
                        tmp = r;
                    else{
                        r.data = n;
                        tmp.data = m;
                        return r;
                    }
                }else if(r.data == n){
                    if(tmp == null)
                        tmp = r;
                    else{
                        tmp.data = n;
                        r.data = m;
                        return r;
                    }
                }
            }else{
                return left;
            }
            Node right = swap2(r.right, m, n, tmp);
            return right;
        }
        return null;
    }

    
    // new way to swap two nodes
    public static Node swapTwoNodes(Node r, int n1, int n2){
        Node node1 = getNode(r, n1);
        Node node2 = getNode(r, n2); 
        if(node1 != null && node2 != null){
            int tmp = node1.data;
            node1.data = node2.data;
            node2.data = tmp;
        }
        return r;
    } 
    public static Node getNode(Node r, int n1){
        if(r != null){
            if( r.data == n1)
                return r;
            Node p1 = getNode(r.left, n1);
            if(p1 != null)
                return p1;
            Node p2 = getNode(r.right, n1);
            if(p2 != null)
                return p2;
                
        }
        return null;
    } 
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// swap nodes in single linkedlist, swap nodes, switch nodes
// add two dumpy nodes to two ends
public class SwapLinkedListNode{
    public static void main(String[] args) {
//        test0();
//        test1();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
    }
    public static void test0(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(4);
        sll.append(8);
        sll.print();

        Ut.l();
        sll.addFirst(new Node(0));
        sll.append(9);
        sll.print();

        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(4);
        sll.append(8);
        sll.addFirst(0);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int n = sll.count();
        Print.pbl("c=" + n);
        Ut.l();
        sll.print();

        Aron.end();
    }
    static void test3(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        Node c3 = new Node(3);
        sll.append(c1);
        sll.append(c2);
        sll.append(c3);
        sll.addFirst(0);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->3");
        swapTwoNodes(sll.head, c1, c3);
        sll.print();

        Aron.end();
    } 
    static void test4(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        Node c3 = new Node(3);
        sll.append(c1);
        sll.append(c2);
        sll.append(c3);
        sll.addFirst(0);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->2");
        swapTwoNodes(sll.head, c1, c2);
        sll.print();

        Aron.end();
    } 
    static void test5(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        Node c3 = new Node(3);
        sll.append(c1);
        sll.append(c2);
        sll.append(c3);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->2");
        swapTwoNodes(sll.head, c1, c2);
        sll.print();

        Aron.end();
    } 
    static void test6(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        sll.append(c1);
        sll.append(c2);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->1");
        swapTwoNodes(sll.head, c1, c1);
        sll.print();

        Aron.end();
    } 
    static void test7(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        Node c3 = new Node(3);
        sll.append(c1);
        sll.append(c2);
        sll.append(c3);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->1");
        swapTwoNodes(sll.head, c1, c1);
        sll.print();

        Aron.end();
    } 
    static void test8(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        sll.append(c1);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->1");
        swapTwoNodes(sll.head, c1, c1);
        sll.print();

        Aron.end();
    } 
    public static void swapTwoNodes(Node head, Node n1, Node n2){
        Node p = null;
        Node n = null;
        Node pp = null;
        Node nn = null;
        Node n1_ = null;
        Node n2_ = null;
        Node prev = null;
        Node curr = head;
        while(curr != null){
            if(curr == n1 || curr == n2){
                    if(n1_ == null){
                        p = prev;
                        n1_ = curr;
                        n = curr.next; 
                    }else if(n2_ == null){
                        pp = prev;
                        n2_ = curr;
                        nn = curr.next;
                    }

                    if(n1_ != null && n2_ != null) {
                        // adjacent nodes
                        if(n == n2_){
                            p.next = n2_;
                            n2_.next = n1_;
                            n1_.next = nn;
                        }else{
                            // non adjacent nodes
                            p.next = n2_;    
                            n2_.next = n;
                            pp.next = n1_;
                            n1_.next = nn;
                        }
                        break;
                    }
            }
            prev = curr;
            curr = curr.next;
        }
    }
} 

public class ThreeBrothers 
{
    public static void main(String[] args)
    {
        //test1();
        Integer[] arr = {1, 2, 2};
        int d=0;
        printTriangle(arr, d);
        Character[] myarr = new Character[10];
        Aron.swap(myarr, 1, 3);
    }
    
    // min(a, MAX) = a
    // mul(a, 1)   = a
    public static void combination(int[] arr, int d, int[] w)
    {
        int min = Integer.MAX_VALUE;
        if(d < 3)
        {
            for(int i=d; i<arr.length; i++)
            {
                w[d] = arr[i];
                combination(arr, d+1, w);
                if(d == 2)
                    System.out.println("["+w[0]+"]["+w[1]+"]["+w[2]+"]");
                /*
                if(d == 2)
                {
                    int mindiff = 2*(Math.max(Math.max(w[0], w[1]), w[2]) - Math.min(Math.min(w[0], w[1]), w[2]));
                    if(mindiff < min)
                    {
                        min = mindiff;
                        System.out.println("["+w[0]+"]["+w[1]+"]["+w[2]+"]");
                        System.out.println();
                    }
                }
                */
            }
        }
    }
    
    
    public static void printTriangle(Integer[] arr, int d)
    {
        if(d == arr.length)
        {
            for(Integer n:arr)
                System.out.print("["+n+"]");
            System.out.println();
        }
        else
        {
            for(int i=d; i<arr.length; i++)
            {
                Aron.swap(arr, i, d);
                printTriangle(arr, d+1);
                Aron.swap(arr, i, d);
            }
        }
    }
    
    public static void test1()
    {
        int[] arr = {1, 2, 4, 5, 6, 8, 9, 11, 14};
        int[] w = new int[3];
        int d = 0;
        combination(arr, d, w);
    }
}
import classfile.Aron;
import classfile.Test;
import java.util.ArrayList;
import java.util.List;


public class TokenizeStr{
    public static void main(String[] args) {
//        test00_tokenize();
//        test0_tokenize();
//
//        test1_tokenize();
//
//        test11_tokenize();
//        test2_tokenize();
//        test22_tokenize();
//        test3_tokenize();
//        test4_tokenize();

        test0_tokenize2();
        test1_tokenize2();
        test2_tokenize2();
        test3_tokenize2();
        test4_tokenize2();
    }
    static void test00_tokenize(){
        Aron.beg();
        String str = "<a>b";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test0_tokenize(){
        Aron.beg();
        String str = "<a>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test11_tokenize(){
        Aron.beg();
        String str = "<b>c</b>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test1_tokenize(){
        Aron.beg();
        String str = "<a>b</a>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test2_tokenize(){
        Aron.beg();
        String str = "<na>da</na>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test22_tokenize(){
        Aron.beg();
        String str = "<name>a</name>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test3_tokenize(){
        Aron.beg();
        String str = "<name>david</name><addr>abc</addr>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test4_tokenize(){
        Aron.beg();
        String str = "<name>david</name>" 
                    +"<addr>abc"
                    +"<phone>cc</phone>"
                    +"<dog>dog</dog>"
                    +"</addr>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    public static char lookAhead(String str, int index){
        int i = 1;
        while(str.charAt(index + i) == ' ')
            i++;

        return str.charAt(index + i);
    }

    //[ file=tokenizestr.html title=""
    /**
     * tokenize xml file like format.
     * read character one by one and feed it to state machine.
     * if token is found, add to a list. Otherwise terminate
     * the process and return null.
     * for example, <name>david</name> => [<name>, david, </name>]
     *
     * @param strChar xxx
     *
     * @return list of tokens if all tokens are valid, otherwise return null
     */
    public static List<String> tokenize(String strChar){
        List<String> list = new ArrayList<String>();
        int state = 0;
        int curr = state;
        String str = "";
        boolean isValid = true;
        for(int i=0; i<strChar.length() && isValid; i++){
            if(curr == 0){
                if(str.length() > 0){
                    list.add(str);
                    str = "";
                }

                if(strChar.charAt(i) == '<'){
                    str += strChar.charAt(i);
                    curr = 1;
                }else if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 2;
                    if(i + 1 < strChar.length() && lookAhead(strChar, i) == '<'){
                        curr = 0;
                    }
                }else{
                    isValid = false;
                }
            }else if(curr == 2){
                if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 2;
                    if(i + 1 < strChar.length() && lookAhead(strChar, i) == '<'){
                        curr = 0;
                    }
                }else{
                    isValid = false;
                }
            }else if(curr == 1){
                if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 3;
                }
                else if(strChar.charAt(i) == '/'){
                    str += strChar.charAt(i);
                    curr = 4;
                }else{
                    isValid = false;
                }
            }else if(curr == 3){
                if(strChar.charAt(i) == '>'){
                    str += strChar.charAt(i);
                    curr = 5; // final
                    curr = 0;
                }else if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 3;
                }else{
                    isValid = false;
                }
            }else if(curr == 4){
                if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 7;
                }else{
                    isValid = false;
                }

            }else if(curr == 7){
                if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                }else if(strChar.charAt(i) == '>'){
                    str += strChar.charAt(i);
                    curr = 8; // final
                    list.add(str);
                    str = "";
                    curr = 0;
                }else{
                    isValid = false;
                }
            }
        }

        if(curr == 2){
            if(str.length() > 0){
                list.add(str);
                str = "";
            }
        }

        return isValid ? list : null;
    }
    //]

    // gx /Users/cat/myfile/github/math/StateMachine2.png
    public static List<String> tokenize2(String strChar){
        List<String> list = new ArrayList<String>();
        int state = 0;
        int curr = state;
        String str = "";
        boolean isValid = true;
        int len = strChar.length();
        for(int i=0; i<len && isValid; i++){
            char currChar = strChar.charAt(i);
            if(currChar != ' '){
                if(curr == 0){
                    if(currChar == '['){
                        list.add(currChar + "");
                        curr = 1;
                    }
                }else if(curr == 1){
                    if(currChar == '['){
                        list.add(currChar + "");
                    }else if(currChar == ']'){
                        curr = 3;
                        list.add(currChar + "");
                    }else if(Character.isLetterOrDigit(currChar)){
                        curr = 2;
                        str += currChar + "";
                        if(i < len - 1){
                            if(lookAhead(strChar, i) == ']' || lookAhead(strChar, i) == '['){
                                list.add(str);
                                str = "";
                            }
                        }
                    }
                }else if(curr == 2){
                    if(Character.isLetterOrDigit(currChar)){
                        str += currChar + "";
                        if(i < len - 1){
                            if(lookAhead(strChar, i) == ']' || lookAhead(strChar, i) == '['){
                                list.add(str);
                                str = "";
                            }
                        }
                    }else if(currChar == ']'){
                       curr = 3;
                       list.add(currChar + ""); 
                    }else if(currChar == '['){
                        curr = 1;
                        list.add(currChar + "");
                    }
                }else if(curr == 3){
                    if(currChar == ']')
                        list.add(currChar + "");
                    else if(currChar == '['){
                        curr = 1;
                        list.add(currChar + "");
                    }
                }
            }
        }
        return list;
    }
    static void test0_tokenize2(){
        Aron.beg();
        String str = "[ 1 ]";
        List<String> list = tokenize2(str);
        Aron.printList(list, "(" );

        Aron.end();
    }
    static void test1_tokenize2(){
        Aron.beg();
        String str = "[ 1 "
                    +" [ 2 ]"
                    +" [ 3 ]"
                    +" ]";
        List<String> list = tokenize2(str);
        Aron.printList(list, " " );
        Aron.end();
    }
    static void test2_tokenize2(){
        Aron.beg();
        String str = "[ 1 "
                    +" [ 2 ]"
                    +" [ 3 "
                    +"  [ 4 ]"
                    +"  [ 5 ]"
                    +" ]"
                    +"]";
        List<String> list = tokenize2(str);
        Aron.printList(list, "<" );
    }
    static void test3_tokenize2(){
        Aron.beg();
        String str = "[ abc "
                    +" [ 123 ]"
                    +" [ 3 "
                    +"  [ 4 ]"
                    +"  [ 5 ]"
                    +" ]"
                    +" [ 6 ]"
                    +" ]";
        List<String> list = tokenize2(str);
        Aron.printList(list, " " );

        Aron.end();
    }
    static void test4_tokenize2(){
        Aron.beg();
        String str = "[abc"
                    +"[123]"
                    +"[3"
                    +"[4]"
                    +"[5]"
                    +"]"
                    +"[6]"
                    +"]";
        List<String> list = tokenize2(str);
        Aron.printList(list, " " );

        Aron.end();
    }
}

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TownerHanoi{
    public static void main(String[] args) {
        test1();
    }

    // gf http://www.mathcs.emory.edu/~cheung/Courses/170/Syllabus/13/hanoi.html
    public static String hanoi(int n, int fromPeg, int toPeg) {
        if(n == 1){
            return (fromPeg + "->" + toPeg + "\n");
        }else{
            int helperPeg = 6 - fromPeg - toPeg; 
            String s1 = hanoi(n-1, fromPeg, helperPeg);
            String myStep = fromPeg + "->" + toPeg + "\n";
            String s2 = hanoi(n-1, helperPeg, toPeg);
            return s1 + myStep + s2; 
        }
    }

    static void test1(){
        Aron.beg();
        int n = 3;
        int fromPeg   = 1;
        int helperPeg = 2; 
        int toPeg     = 3;
        String ss        = hanoi(n, fromPeg, toPeg);
        Print.p(ss);

        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

//[ file=inorderiterator.html title=""     
class InorderIterator {
    Node curr;
    Stack<Node> stack = new Stack<Node>();
    public InorderIterator(Node r) {
        this.curr = r;
    }
    public boolean hasNext() {
        if(curr != null || stack.size() > 0)
            return true;
        else
            return false;
    }
    public int next() {
        while(hasNext()) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.pop();
                curr = node.right;
                return node.data;
            }
        }
        return -1;
    }
}
//]

class TraversalIteration{

    public static Node prev = null;
    public static void main(String args[]) {
        BST b1 = new BST();
        b1.insert(14);
        b1.insert(15);
        b1.insert(12);
        b1.insert(17);
        b1.insert(19);

        b1.insert(130);
        b1.insert(16);
        b1.insert(10);

        PostOrder(b1.getRoot());
        System.out.println();
        Node cloneRoot = CloneTree(b1.getRoot());

        PostorderDFS(cloneRoot);
        PostorderTwoStacks(cloneRoot);
    }
    //in order traversal using iteration
    public static void InorderIteration(Node r) {
        Stack<Node> st = new Stack<Node>();
        Node curr = r;
        if( curr != null) {
            while(!st.empty() || curr != null) {
                if(curr != null) {
                    st.push(curr);
                    curr = curr.left;
                } else {
                    Node no = st.pop();
                    System.out.println("[" + no.data + "]");
                    curr = no.right;
                }
            }
        }
    }

    
    //[file=postorder1.html title=""
    //postorder recursion
    public static void PostOrder(Node r) {
        if( r != null) {
            PostOrder(r.left);
            PostOrder(r.right);
            System.out.println("[" + r.data + "]");
        }
    }
    //]

    //[ file=postorderite.html title=""
    // postorder with iteration
    public static void postIteration(Node root) {
        Stack<Node> stack = new Stack<Node>();
        Node curr = root;
        while(curr != null || stack.isEmpty() == false) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.peek();
                if(node.isVisited) {
                    System.out.println("[" + node.data + "]");
                    stack.pop();
                } else {
                    node.isVisited = true;
                    curr = node.right;
                }
            }
        }
    }
    //]

    //[ file=twostackite.html title="" 
    //Postorder with two stacks
    public static void PostorderTwoStacks(Node curr) {
        Stack<Node> st1 = new Stack<Node>();
        Stack<Node> st2 = new Stack<Node>();
        if(curr != null) {
            st1.push(curr);
            while(!st1.empty()) {
                Node node = st1.pop();
                st2.push(node);
                if(node.left != null)
                    st1.push(node.left);
                if(node.right != null)
                    st1.push(node.right);
            }
            while(!st2.empty()) {
                Node node = st2.pop();
                System.out.println("[" + node.data + "]");
            }
        }
    }
    //]

    // clone a binary tree
    // Use postorder traversal
    public static Node CloneTree(Node root) {
        if(root != null) {
            Node left = CloneTree(root.left);
            Node right = CloneTree(root.right);
            Node parent = new Node(root.data);
            parent.left = left;
            parent.right = right;
            return parent;
        }
        return null;
    }

    public static void PostorderDFS(Node r) {
        if( r != null) {
            Stack<Node> st= new Stack<Node>();
            Map<Node, List<Node>> map = new HashMap<Node, List<Node>>();
            st.push(r);
            while(!st.empty()) {
                Node top = st.peek();
                if((top.left == null && top.right == null) || top.isVisited) {
                    Node node = st.pop();
                    System.out.println("[" + node.data + "]");

                } else if((top.left != null || top.right != null) && !top.isVisited) {
                    List<Node> list = new LinkedList<Node>();
                    if(!map.containsKey(top)) {
                        if(top.left != null)
                            list.add(top.left);
                        if(top.right != null)
                            list.add(top.right);
                        map.put(top, list);
                    } else {
                        list = map.get(top);
                    }
                    if(list.size() > 0) {
                        Node node = list.get(0);
                        st.push(node);
                        list.remove(0);
                        if(list.size() == 0) {
                            top.isVisited = true;
                            map.remove(top);
                        }
                    }
                }
            }
        }
    }
    //[ file=preinorder.html title=""
    public static void preorder(Node root) {
        if(root != null) {
            System.out.println("[" + root.data + "]");
            inorder(root.left);
            inorder(root.right);
        }
    }
    public static void inorder(Node root) {
        if(root != null) {
            inorder(root.left);
            System.out.println("[" + root.data + "]");
            inorder(root.right);
        }
    }

    public static void preorderIteration(Node r) {
        Stack<Node> st = new Stack<Node>();
        Node curr = r;
        if( curr != null) {
            while(curr != null || !st.empty()) {
                if(curr != null) {
                    System.out.println("["+curr.data+"]");
                    st.push(curr);
                    curr = curr.left;
                } else {
                    Node node = st.pop();
                    curr = node.right;
                }
            }
        }
        curr = r;
    }

    public static void inorderIteration(Node r) {
        Stack<Node> st = new Stack<Node>();
        Node curr = r;
        if( curr != null) {
            while(curr != null || !st.empty()) {
                if(curr != null) {
                    st.push(curr);
                    curr = curr.left;
                } else {
                    Node node = st.pop();
                    System.out.println("["+curr.data+"]");
                    curr = node.right;
                }
            }
        }
        curr = r;
    }
    //]

}
package classfile;
import java.io.*;
import java.lang.String;
import java.util.*;

class TNode {
    boolean isWord;
    TNode[] array = new TNode[26];
}

public class Tries {
    public TNode root;
    public Tries() {
        root = new TNode();
        root.isWord = true;
    }
    public  int map(char ch) {
        return (int)ch - 'a';
    }
    public  void add(TNode r, int[] arr, int k) {
        if( k < arr.length) {
            if(r.array[arr[k]] == null)
                r.array[arr[k]] = new TNode();
            if(k == arr.length-1)
                r.isWord = true;
            add(r.array[arr[k]], arr, k+1);
        }
    }

    public  boolean contains(TNode r, int[] arr, int h) {
        if(h < arr.length && r.array[arr[h]] != null) {
            if(h + 1 == arr.length && r.isWord)
                return true;
            else
                return contains(r.array[arr[h]], arr, h+1);
        }
        return false;
    }
    public  void addWord(TNode r,  String word, int k) {
        if( k < word.length()) {
            if(r.array[map(word.charAt(k))] == null)
                r.array[map(word.charAt(k))] = new TNode();
            if(k == word.length()-1)
                r.isWord = true;
            addWord(r.array[map(word.charAt(k))], word, k+1);
        }
    }
    public  boolean containsWord(TNode r, String word, int k) {
        if(word.length() == 0)
            return r.isWord;
        if(k < word.length() && r.array[map(word.charAt(k))] != null) {
            if(k + 1 == word.length() && r.isWord)
                return true;
            else
                return containsWord(r.array[map(word.charAt(k))], word, k+1);
        }
        return false;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;


class MyNode{
    public MyNode[] arr = new MyNode[26];
    public boolean isWord;
    public String word;
    public MyNode(boolean isWord){
        this.isWord = isWord;
        word = null;
    }
}

class Tries{
    public MyNode root;
    public Tries(){
        root = new MyNode(true);
    }
}


public class Tries2{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    static void test2(){
        Aron.beg();
        String str = "abc";
        Print.p((int)str.charAt(0));
        Print.p(str.codePointAt(0));
        Aron.end();
    } 
   
    static void test0(){
        Aron.beg();
        int k = 0;
        String str = "abc";
        Tries t = new Tries();
        insert(t.root, str, k);

        Test.t(contains(t.root, str, k));
        Test.t(contains(t.root, "", k));
        Test.f(contains(t.root, "a", k));
        Test.f(contains(t.root, "d", k));

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        int k = 0;
        String str1 = "tea";
        String str2 = "ten";
        String str3 = "tenny";
        String str4 = "tee";
        String str5 = "teyo";
        Tries t = new Tries();
        insert(t.root, str1, k);
        insert(t.root, str2, k);
        insert(t.root, str3, k);
        insert(t.root, str4, k);
        insert(t.root, str5, k);

        Test.t(contains(t.root, str1, k));
        Test.t(contains(t.root, str2, k));
        Test.t(contains(t.root, str3, k));
        Test.t(contains(t.root, str4, k));
        Test.t(contains(t.root, str5, k));

        Test.f(contains(t.root, "t", k));
        Test.f(contains(t.root, "te", k));
        Test.f(contains(t.root, "teee", k));
        Test.f(contains(t.root, "teae", k));

        List<String> list = new ArrayList<String>(); 
        String partialWord = "te";
        MyNode node = autoComplete(t.root, partialWord, k);
        getList(node, list);
        Aron.line();
        Aron.printList(list);

        Aron.end();
    }
    static void test3(){
        Aron.beg();
        int k = 0;
        String str1 = "tea";
        String str2 = "ten";
        String str3 = "tenny";
        String str4 = "tee";
        String str5 = "teyo";
        Tries t = new Tries();
        insert(t.root, str1, k);
        insert(t.root, str2, k);
        insert(t.root, str3, k);
        insert(t.root, str4, k);
        insert(t.root, str5, k);

        List<String> list = new ArrayList<String>(); 
        String partialWord = "te";
        MyNode node = autoComplete(t.root, partialWord, k);
        getList(node, list);
        Aron.line();
        Print.pbl(partialWord);
        Aron.printList(list);

        Aron.end();
    }

    public static void insert(MyNode root, String str, int k){
        if(k == str.length()){
            root.isWord = true;    
            root.word = str;
        }
        else if(k < str.length()){
            int inx = Aron.charIndex(str.charAt(k)); 
            MyNode node = root.arr[inx];
            if(node != null){
                insert(node, str, k+1);
            }else{
                root.arr[inx] = new MyNode(false);
                insert(root.arr[inx], str, k+1);
            }
        }
    }
    public static boolean contains(MyNode root, String str, int k){
        if(k < str.length()){
            int inx = Aron.charIndex(str.charAt(k)); 
            if(root.arr[inx] != null){
                return contains(root.arr[inx], str, k+1);
            }else{
                return false;
            }
        }else{
           return root.isWord;
        }
    }

    public static MyNode autoComplete(MyNode root, String str, int k){
        if(k < str.length()){
            int inx = Aron.charIndex(str.charAt(k)); 
            if(root.arr[inx] != null){
                return autoComplete(root.arr[inx], str, k+1);
            }else{
                return null;
            }
        }else{
           return root;
        }
    }
    public static void getList(MyNode node, List<String> list){
        for(int i=0; i<node.arr.length; i++){
            if(node.arr[i] != null){
                if(!node.arr[i].isWord){
                    getList(node.arr[i], list);
                }else{
                    list.add(node.arr[i].word);
                }
            }
        }
    }
} 
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// gx http://www.geeksforgeeks.org/find-pair-rows-binary-matrix-maximum-bit-difference/
// count the maximum different bits in binary matrix
class TNode{
    public TNode[] arr = new TNode[2];
    public boolean isWord = false;
    public TNode(boolean isWord){
        this.isWord = isWord;
    }
    public TNode(){
    }
}

public class TriesBinary{
    public static void main(String[] args) {
//        test0();
//        test1();
        test2();
    }
    public static void insert(TNode node, String s, int index){
        if(index < s.length()){
            int inx = s.charAt(index) - '0';
            if(node.arr[inx] == null)
                node.arr[inx] = new TNode(false);
            insert(node.arr[inx], s, index+1);
        }else{
            node.isWord = true;
        }
    }
    public static boolean contains(TNode root, String s, int index){
        if(s != null){
            if(index < s.length()){
                int n = s.charAt(index) - '0';    
                if(root.arr[n] == null)
                    return false;
                else
                    return contains(root.arr[n], s, index+1);
            }else{
                return root.isWord;
            }
        }
        return false;
    }
    
    public static void print(TNode node){
        if(node != null){
            if(node.arr[0] != null){
                Print.pp(0);
                print(node.arr[0]);
                Print.pp("\n");
            }
            if(node.arr[1] != null){
                Print.pp(1);
                print(node.arr[1]);
                Print.pp("\n");
            }
        }
    }
   
    public static int countDiff(TNode node){
        if(node != null){
            if(node.arr[0] != null && node.arr[1] != null){
                int l = countDiff(node.arr[0]);
                int r = countDiff(node.arr[1]);
                return l + r + 1;
            }
        }
        return 0;
    }
    public static void test0(){
        Aron.beg();

        String s1 = "011";
        String s2 = "111";
        String s3 = "010";
        TNode root = new TNode(true);
        int index = 0;
        insert(root, s1, index);
        insert(root, s2, index);
        insert(root, s3, index);
        print(root);
        Aron.end();
    }

    public static void test1(){
        Aron.beg();
        String[] array = {
            "011",
            "111",
            "010",
            "000",
        };
        String s1 = "011";
        String s2 = "111";
        String s3 = "010";
        TNode root = new TNode();
        int index = 0;

        for(int i=1; i<array.length; i++){
            insert(root, array[i], index);
        }

        int num = countDiff(root);
        Print.pp("num=" + num);

        Aron.end();
    }

    static void test2(){
        Aron.beg();

        String[] array = {
            "011",
            "111",
            "010",
        };
        TNode root = new TNode();
        int index = 0;

        for(int i=1; i<array.length; i++){
            insert(root, array[i], index);
        }
        
        boolean b = contains(root, "111", index);
        Test.t(b == true);
        b = contains(root, "000", index);
        Test.t(b == false);

        Aron.end();
    } 
} 

import java.util.*;
import java.io.*;
import classfile.*;

// Tries with HashMap
class XNode {
    public Map<Character, XNode> map = new HashMap<Character, XNode>();
    public boolean isWord = false;
    public String word;
    public XNode(boolean isWord) {
        this.isWord = isWord;
    }
}

public class TriesMap{
    public static void main(String[] args) {
        test0_insert();
        test1_insert();
        test2_insert();
        test3_insert();
        test4_insert();
        test4_autocomplete();
        test5_autocomplete();
        test5_autocompleteList();
        test6_autocompleteList();
        test7_autocompleteList();
        test8_autocompleteList();
        test9_autocompleteList();
    }

    
    //[ file=triesmap.html title=""
    /**
    * insert str to Tries from the root, if str doesn't exist in Tries
    * set isWord to be true, and assign str to word
    * if str does exist in the tries, do nothing
    *
    * @param root   the root node of Tries, it can't be null
    * @param str    the String is being inserted
    * @param index  index of str, initial value is zero
    *
    * return void
    */
    public static void insert(XNode root, String str, int index) {
        if(index == str.length()) {
            root.isWord = true;
            root.word = str;
        } else {
            char ch = str.charAt(index);
            XNode node = root.map.get(ch);
            if(node == null) {
                node = new XNode(false);
                root.map.put(ch, node);
            }
            insert(node, str, index+1);
        }
    }

    /**
    * check if the str exist in the Tries,
    *
    * @param root the root of Tries
    * @param str  the String to be checked
    * @param index index of str
    *
    * @return true if str exists in the Tries, false otherwise
    */
    public static boolean contains(XNode root, String str, int index) {
        if(index == str.length()) {
            return root.isWord;
        } else {
            if(root.map.containsKey(str.charAt(index))) {
                return contains(root.map.get(str.charAt(index)), str, index + 1);
            } else {
                return false;
            }
        }
    }

    public static XNode autocomplete(XNode root, String partialWord, int index) {
        if(index == partialWord.length()) {
            return root;
        }else {
            XNode node = root.map.get(partialWord.charAt(index));
            if(node != null) {
                return autocomplete(node, partialWord, index + 1);
            }
            return null;
        }
    }
    public static void autocompleteList(XNode node, String partialWord, int index, List<String> list) {
        if(node.isWord)
            list.add(node.word);
        else{
            for(Map.Entry<Character, XNode> entry : node.map.entrySet()){
                if(entry.getValue().isWord)
                    list.add(entry.getValue().word);
                else
                    autocompleteList(entry.getValue(), partialWord, index+1, list);
            } 
        }
    }
    //]

    public static void print(XNode root) {
        if(root != null) {
            if(root.isWord)
                Print.pb(root.word);

            for(Map.Entry<Character, XNode> entry : root.map.entrySet()) {
                print(entry.getValue());
            }
        }
    }

    static void test0_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, str, index);
        Test.t(contains(root, str, index));
        Aron.end();
    }
    static void test1_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, "ab", index);
        Test.f(contains(root, str, index));
        Aron.end();
    }
    static void test2_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, "a", index);
        insert(root, "ab", index);
        insert(root, "abc", index);
        insert(root, "abcd", index);

        Test.t(contains(root, "", index));
        Test.t(contains(root, "a", index));
        Test.t(contains(root, "ab", index));
        Test.t(contains(root, "abcd", index));
        Test.t(contains(root, "abc", index));

        Test.f(contains(root, "abb", index));
        Test.f(contains(root, "abcc", index));
        Aron.end();
    }
    static void test3_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, "abcd", index);

        Test.t(contains(root, "", index));
        Test.f(contains(root, "a", index));
        Test.f(contains(root, "ab", index));
        Test.t(contains(root, "abcd", index));
        Test.f(contains(root, "abc", index));

        Aron.end();
    }
    static void test4_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, "abcd", index);
        insert(root, "a", index);
        insert(root, "abc", index);
        print(root);

        Aron.end();
    }
    static void test4_autocomplete() {
        Aron.beg();

        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        
        String str = "cat";
        XNode node = autocomplete(root, str, index);
        Test.t(node.isWord == true);
        Test.t(node.word.equals(str));

        Aron.end();
    }
    static void test5_autocomplete() {
        Aron.beg();

        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        
        String str = "ca";
        XNode node = autocomplete(root, str, index);
        Test.t(node.isWord == false);

        Aron.end();
    }
    static void test5_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        insert(root, "qualify", index);
        insert(root, "quart", index);
        insert(root, "quarter", index);
        insert(root, "quantify", index);
        insert(root, "quantifying", index);
        insert(root, "quantified", index);
        insert(root, "quantifies", index);
        insert(root, "quant", index);
        insert(root, "quantitative", index);
        insert(root, "quadratic", index);
        insert(root, "satellite", index);
        insert(root, "beijing", index);
        insert(root, "vienna", index);
        
        String str = "qua";
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Print.pbl(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test6_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        insert(root, "qualify", index);
        insert(root, "quart", index);
        insert(root, "quarter", index);
        insert(root, "quantify", index);
        insert(root, "quantifying", index);
        insert(root, "quantified", index);
        insert(root, "quantifies", index);
        insert(root, "quant", index);
        insert(root, "quantitative", index);
        insert(root, "quadratic", index);
        insert(root, "satellite", index);
        insert(root, "beijing", index);
        insert(root, "vienna", index);
        
        String str = "q";
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Print.pbl(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test7_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        insert(root, "qualify", index);
        insert(root, "quart", index);
        insert(root, "quarter", index);
        insert(root, "quantify", index);
        insert(root, "quantifying", index);
        insert(root, "quantified", index);
        insert(root, "quantifies", index);
        insert(root, "quant", index);
        insert(root, "quantitative", index);
        insert(root, "quadratic", index);
        insert(root, "satellite", index);
        insert(root, "beijing", index);
        insert(root, "vienna", index);
        
        String str = "c";
        Print.pbl(str);
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Aron.printList(list);

        Aron.end();
    }
    static void test8_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        insert(root, "qualify", index);
        insert(root, "quart", index);
        insert(root, "quarter", index);
        insert(root, "quantify", index);
        insert(root, "quantifying", index);
        insert(root, "quantified", index);
        insert(root, "quantifies", index);
        insert(root, "quant", index);
        insert(root, "quantitative", index);
        insert(root, "quadratic", index);
        insert(root, "satellite", index);
        insert(root, "beijing", index);
        insert(root, "vienna", index);
        
        String str = "";
        Print.pbl(str);
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Aron.printList(list);

        Aron.end();
    }
    static void test9_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        
        String str = "cat";
        Print.pbl(str);
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Aron.printList(list);

        Aron.end();
    }
}

import java.lang.Character;
public class Trim 
{
    public static void main(String[] args)
    {
        String str = "   hello world  ";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = "";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = "a";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = " ";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = " a";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = "a ";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = " a ";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = null;
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");


    }
    public static String trim(String str)
    {
        String ret = null;
        if(str != null)
        {
            ret = "";
            int i = 0;
            while(str.length() > 0 && str.length() > i && Character.isSpace(str.charAt(i)))
            {
                            i++;
            }
            int l = str.length();

            while(l > 0 && Character.isSpace(str.charAt(l-1)))
            {
                            l--;
            }
            for(int k = i; k < l; k++)
            {
                            ret = ret + str.charAt(k);
            }
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

class Card{
    String type;
}

class Deskcard{
    List<Card> list;
    void add(Card card){
        list.add(card);
    }
    Card removeTop(){
        if(list.size() > 0)
            return list.remove(list.size()-1);
        return null;
    }
}



public class Try444{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void swap(int[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    public static void test0(){
        Aron.beg();
        int len = 10;
        int[] arr = new int[len];
        for(int i=0; i<len; i++){
            arr[i] = i;
        } 

        Random r = new Random();
        int last = len-1;
        for(int i=1; i<len; i++){
            int n= r.nextInt(len-i);
            swap(arr, n, len-i);
            Print.pp("n=" + n + "\n");
        } 
        
        Ut.l();
        for(int i=0; i<len; i++){
            Print.pp(arr[i] + " ");
        } 

        Aron.end();
    }
    public static void shuffle(){
        Random r = new Random();
        int num = r.nextInt(52) + 1;
        Print.pp("num=" + num);
    }
    public static void test1(){
        Aron.beg();

        Random r = new Random();
        int n = r.nextInt(1);
        Aron.end();
    }

    public static void delete(Node r, Node n){
        Random ran = new Random();
        // 0 - 9
        int num = ran.nextInt(10);
        Print.p(num); 
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryChar{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        char currChar = '1';
        if(Character.isLetterOrDigit(currChar)){
            Print.pbl(currChar);
        }
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryCoin{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        List<Integer> coinList = new ArrayList<>(Arrays.asList(1, 2, 3));
        
        List<Integer> list = new ArrayList<>();
        int s = 10;
        coinChange(coinList, s, list);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
    // given a list of coins and an Integer, find the number of combinations of coins are added up the s
    // assume s > 0 and all face value of coins are greater than zero
    public static void coinChange(List<Integer> coinList, Integer s, List<Integer> list){
        if(s == 0)
            Aron.printList(list);    
        else if (s > 0){
            for(Integer n : coinList){
                list.add(n);
                coinChange(coinList, s-n, list); 
                list.remove(list.size()-1);
            }
        }
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryCopyList{
    public static void main(String[] args) {
        test0();
        test1();
    }

    public static void test0(){
        Aron.beg();
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3)); 
        List<Integer> ll = list.stream().collect(Collectors.toList()); 
        Aron.printList(ll);
        

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    public static void copyList(){
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryCreateTree{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Node r = createGeneralTree();
        print(r);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    public static void print(Node r){ 
        Print.p(r.data);
        for(Node n : r.list)
            print(n);
    }

    public static Node createGeneralTree(){
        Node r = new Node(1); 
        Node n1 = new Node(2);
        Node n2 = new Node(3);
        Node n3 = new Node(4);

        Node nn1 = new Node(11);
        Node nn2 = new Node(12);
        Node nn3 = new Node(13);

        Node nn4 = new Node(14);
        Node nn5 = new Node(15);

        n1.list.add(nn1);
        n1.list.add(nn2);
        n1.list.add(nn3);

        n2.list.add(nn4);
        n2.list.add(nn5);

        r.list.add(n1);
        r.list.add(n2);
        r.list.add(n3);
        return r;
    }

} 

import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import java.util.stream.*;
import java.util.*;
import java.io.*;
import classfile.*;

// *j_json* *json* *json_array* *json seri *
class Item implements Serializable {
    @SerializedName("_OrderDetails")
    private OrderDetails[] mOrderDetails;

    @SerializedName("Id")
    private String mId;
    public String getId(){
        return mId;
    }

    public OrderDetails[] getMOrderDetails(){ 
        return mOrderDetails;
    }

    @SerializedName("OrderData")
    private String mOrderDate;

    @SerializedName("Number")
    private String mNumber;

    @SerializedName("CustomerName")
    private String mCustomerName;

    @SerializedName("Note")
    private String mNote;

    // Add setters and getters

    public static class OrderDetails implements Serializable {
        @SerializedName("ProductName")
        private String mProductName;
        String getMProductName(){
            return mProductName;
        }

        @SerializedName("TotalAfterDiscount_Lc")
        private String mTotalAfterDiscount;

        @SerializedName("MeasureUnitName")
        private String mMeasureUnitName;

        @SerializedName("TotalPrice_Lc")
        private String mTotalPrice;

        @SerializedName("PricePerUnit_Lc")
        private String mPricePerUnit;

        @SerializedName("Quantity")
        private String mQuantity;

        // Add setters and getters
    }
}

public class TryJsonArray {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        String responseJSON = "[\n" +
                              "  {\n" +
                              "    \"_OrderDetails\": [\n" +
                              "      {\n" +
                              "         \"ProductName\": \"FUCHS SUPER GT SAE 10W30 6X5 / FP10100010102\",\n" +
                              "        \"TotalAfterDiscount_Lc\": \"7500\",\n" +
                              "        \"MeasureUnitName\": \"كرتونة\",\n" +
                              "        \"TotalPrice_Lc\": \"7500\",\n" +
                              "        \"PricePerUnit_Lc\": \"75\",\n" +
                              "        \"Quantity\": \"100\"\n" +
                              "      }\n" +
                              "    ],\n" +
                              "    \"Id\": \"274\",\n" +
                              "    \"OrderDate\": \"4/10/2014 12:00:00 AM\",\n" +
                              "    \"Number\": \"16\",\n" +
                              "    \"CustomerName\": \"الأسد\",\n" +
                              "    \"Note\": \"\"\n" +
                              "  }\n" +
                              "]";

        Item[] placelist;
        Gson gson = new Gson();
        placelist = gson.fromJson(responseJSON, Item[].class);
        System.out.println(Arrays.toString(placelist));
        for(Item m : placelist){
            Print.pbl(m.getId());
            for(Item.OrderDetails order : m.getMOrderDetails()){
                Print.pbl(order.getMProductName());
            }
        }

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
}


import java.util.*;
import java.io.*;
import classfile.*;

public class TryLevel{
    public static void main(String[] args) {
//        test0();
        test1();
        test2();
    }
    public static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7); 
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        //Aron.binImage(b1.root);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(9);
        int level = 1;

        
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        level(b1.root, map, level);
        int sum = 0;
        for(int k=0; k<=map.size(); k++){
            int m = (int)Math.pow(2, k);
            for(int i=1; i<=m; i++){
                int index = sum + i;
                Integer value = map.get(index);
                if(value != null)
                    Print.pbl("k=" + k + "  s=" + (sum + i) + " v=" + value);
                
            }
            sum += m;
            Aron.line();
        } 

        int index = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, index, isLeaf);
//        Aron.binImage(b1.root);
        
        Aron.end();
    }
    
    static void test2(){
        Aron.beg();
        int level = 1;
        Aron.line();
        BST b1 = Aron.createBin();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        level(b1.root, map, level);

        int index = 1;
        boolean isLeaf = true;
        Node root = buildTree(map, index);
        Aron.prettyPrint(root, index, isLeaf);


        Aron.end();
    } 

    
    public static Node buildTree(Map<Integer, Integer> map, int index){
        Node r = null;
        Integer n = map.get(index);
        if(n != null){
            r = new Node(n);
            r.left = buildTree(map, 2*index);
            r.right = buildTree(map, 2*index+1);
        }
        return r;
    }

    public static void printLevel(){
        int level = 1;
        Aron.line();
        BST b1 = Aron.createBin();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        level(b1.root, map, level);
        int sum = 0;
        int num = 0;
        int k = 0;
        while(num < map.size()){
            int m = (int)Math.pow(2, k);
            for(int i=1; i<=m; i++){
                int index = sum + i;
                Integer value = map.get(index);
                if(num < map.size() && value != null){
                    Print.pb("k=" + k + "  s=" + (sum + i) + " v=" + value);
                    num++;
                }
                
            }
            sum += m;
            k++;
            Aron.line();
        } 
//
//        int index = 0;
//        boolean isLeaf = true;
//        Aron.prettyPrint(b1.root, index, isLeaf);
    }
    public static void level(Node r, Map<Integer, Integer> map, int level){
        if(r != null){
            Print.pbl(level + "=>" + r.data);
            map.put(level, r.data);
            level(r.left, map, 2*level);
            level(r.right, map, 2*level + 1);
        }
    } 
} 

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryMM{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        //String s = "kabcabckFABCFdd";
        String s = "name#778-338-4145dd";

        //Pattern pattern = Pattern.compile("k([a-c]+)|(F([A-C]+)F)");
        //Pattern pattern = Pattern.compile("(k([a-c]+)|([A-C]+))");
        Pattern pattern = Pattern.compile("(\\w+)|#([0-9-]+)");
        Matcher matcher = pattern.matcher(s);
        while(matcher.find()) {
            Print.pbl("groupCount=" + matcher.groupCount());
            Ut.l();
            int gc = matcher.groupCount();
            for(int i=1; i<=gc; i++){
                if(matcher.group(i) != null)
                    Print.pb(matcher.group(i));
            } 
        }

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        String s = "dog\r\ncat";
        String str = s.replace("\r\n", "-");
        Print.pbl("str=" + str);
        Aron.end();
    } 
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryMin2{
    public static void main(String[] args) {
        test0();
        String str = "test it";
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.time.LocalDateTime;
import java.time.Duration;

interface ICar{
    public double getPrice();
}

class SmallCar implements ICar {
    String name;
    public SmallCar(String name) {
        this.name = name;
    }
    public double getSize() {
        return 114;
    }
}

class MiddleCar implements ICar {
    String name;
    public MiddleCar(String name) {
        this.name = name;
    }
    public double getSize() {
        return 314;
    }
}

class Ticket {
    double price;
    String id;
    LocalDateTime start;
    LocalDateTime end;
    public Ticket(String id, double price) {
        this.id = id;
        this.price = price;
        this.start = LocalDateTime.now();
    }
    public LocalDateTime diff() {
        return LocalDateTime.now();
    }
}

class ParkingSpace {
    Ticket ticket;
    ICar car;
    public ParkingSpace(Ticket ticket, ICar car) {
        this.ticket = ticket;
        this.car = car;
    }
}

class ParkSystem {
    Map<String, ParkingSpace> map = new HashMap<>();
    public ParkSystem(int max) {
    }
    public void add(ParkingSpace parkingSpace) {
        map.put(parkingSpace.ticket.id, parkingSpace);
    }
    public void remove(parkingSpace parkingSpace) {
        map.remove(ParkingSpace.ticket.id);
    }
}


public class TryPark {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();

        ParkSystem ps = new ParkSystem(10);
        Ticket t1 = new Ticket("1", LocalDateTime.now());
        Ticket t2 = new Ticket("2", LocalDateTime.now());
        Ticket t3 = new Ticket("3", LocalDateTime.now());

        ps.add(t1, new ParkingSpace(t1, new SmallCar("2323", 345.3)));

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        LocalDateTime from = LocalDateTime.now();
        LocalDateTime to = LocalDateTime.now();
        Duration duration = Duration.between(from, to);
        Print.pbl(duration.toString());
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryParseXML{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        String str = "/Users/cat/myfile/github/java/text/filex.txt";

        validate(str);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
    public static boolean validate(String fname){
        try{
            BufferedReader br = new BufferedReader(new FileReader(fname));
            String line = null;
            while( (line = br.readLine()) != null){
                Print.pbl(line);
            }
        }
        catch(IOException e){
            e.printStackTrace();
        }
        return true;
    }

    public static void buildTree(Iterator<String> ite){
        if (ite.hasNext()){

            Pattern r = Pattern.compile("\\d+", Pattern.CASE_INSENSITIVE);
            Matcher mat = r.matcher("CAPTHEOREM");
            if(mat.find()) {
                Print.p("found=" + mat.group(0));
            }
     
            if(ite.next().equals("[")){
                    
            }
        }else{

        }
        
        
        
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryPath{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 1, 0, 0},
            {0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        List<Integer> list = new ArrayList<Integer>(); 
        int n1=0, n2=5;
        list.add(n1);
        allpath(arr2d, n1, n2, list);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        int[][] arr2d = {
            {0, 1, 1, 1, 0, 0},
            {0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);

        int height = arr2d.length;
        int width = arr2d[0].length; 
        List<Integer> list = new ArrayList<Integer>(); 
        List<Integer> mlist = new ArrayList<Integer>(); 
        int n1=0, n2=5;
        list.add(n1);
        shortest(arr2d, n1, n2, list, mlist);
        Aron.printList(mlist);

        Aron.end();
    }
    public static void allpath(int[][] arr2d, int n1, int n2, List<Integer> list){
        int height = arr2d.length;
        int width = arr2d[0].length;
        if(n1 < height){
            if(n1 != n2){
                for(int i=0; i<width; i++){
                    if(arr2d[n1][i] == 1){
                        list.add(i);
                        allpath(arr2d, i, n2, list);
                        list.remove(list.size()-1);
                    }
                } 
            }else{
                Aron.printList(list);
            }
        }
    }

    public static void shortest(int[][] arr2d, int n1, int n2, List<Integer> list, List<Integer> mlist){
        int height = arr2d.length;
        int width = arr2d[0].length;
        if(n1 < height){
            if(n1 != n2){
                for(int i=0; i<width; i++){
                    if(arr2d[n1][i] == 1){
                        list.add(i);
                        shortest(arr2d, i, n2, list, mlist);
                        list.remove(list.size()-1);
                    }
                } 
            }else{
                if(mlist.size() == 0)
                    mlist = list.stream().collect(Collectors.toList());
                else{
                    if(list.size() < mlist.size()){
                        mlist = list.stream().collect(Collectors.toList());
                        Aron.printList(mlist);
                    }
                }
            }
        }
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryPostOrder{
    public static void main(String[] args) {
        //test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        BST b = Aron.createBin();
        postorder(b.root);
        
        Aron.end();
    }
    
    static void test1(){
        Aron.beg();
        BST b = Aron.createBin();
        printSequence(b.root);

        Aron.end();
    }
    
    public static void postorder(Node r){
        Stack<Node> s1 = new Stack<>();
        Stack<Node> s2 = new Stack<>();
        if(r != null){
            s1.push(r);
            while(!s1.empty()){
                Node n = s1.pop();
                if(n.left != null)
                    s1.push(n.left);
                if(n.right != null)
                    s1.push(n.right);
                s2.push(n);
            }
            while(!s2.empty())
                Print.pbl(s2.pop().data);
        }
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    }

    public static void printSequence(Node r){
       Stack<Node> s1 = new Stack<>();  
       Stack<Node> s2 = new Stack<>();  
       if(r != null){ 
           s1.push(r);
           while(!s1.empty() || !s2.empty()){
               while(!s1.empty()){
                   Node n = s1.pop();
                   Print.p(n.data);

                   if(n.left != null)
                       s2.push(n.left);
                   if(n.right != null)
                       s2.push(n.right);
               }

               while(!s2.empty()){
                   Node n = s2.pop();
                   Print.p(n.data);
                   if(n.right != null)
                       s1.push(n.right);
                   if(n.left != null)
                       s1.push(n.left);
               }
           }
           
       }
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryPrime{
    public static void main(String[] args) {
        test00();
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        List<Integer> list = prime(10); 
        Aron.printList(list);
        Aron.end();
    }
    public static void test00(){
        Aron.beg();
        List<Integer> list = prime(2); 
        Aron.printList(list);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        List<Integer> list = nprime(10); 
        Aron.printList(list);

        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        List<Integer> list = nprime(1); 
        Aron.printList(list);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        List<Integer> list = nprime(2); 
        Aron.printList(list);

        Aron.end();
    }
    public static List<Integer> nprime(int n){
        List<Integer> list = new ArrayList<>();

        if(n >= 1){
            list.add(2);
            int k = 1;
            int i = 3;
            while(k < n){
                boolean isPrime = true;
                for(Integer p : list){
                    if( i % p == 0){
                        isPrime = false;
                        break;
                    }
                }
                if(isPrime){
                    list.add(i);
                    k++;
                }
                i++;
            } 
            
        }
        return list;
    }
    public static List<Integer> prime(int n){
        List<Integer> list = new ArrayList<>();

        if(n >= 2){
            list.add(2);
            for(int i=3; i<=n; i++){
                boolean isPrime = true;
                for(Integer p : list){
                    if( i % p == 0){
                        isPrime = false;
                        break;
                    }
                }
                if(isPrime)
                    list.add(i);
            } 
            
        }
        return list;
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryRArr{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    public static void test0(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
            { 13,  14,  15, 16},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        Aron.printArray2D(arr2d);
        Aron.line();

        rotate(arr2d);
        Aron.printArray2D(arr2d);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
            { 13,  14,  15, 16},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 
        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
            { 13,  14,  15, 16},
            { 17,  18,  19, 20},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3},
            { 4,   5,   6},
            { 7,   8,  9},
            { 10,  11,  12},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test4(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test5(){
        Aron.beg();
        int[][] arr2d = {
            {1},
            {2},
            {3},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test6(){
        Aron.beg();
        int[][] arr2d = {
            {1, 2},
            {3, 4},
            {5, 6},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test7(){
        Aron.beg();
        int[][] arr2d = {
            {1},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }

    public static void rotate(int[][] array){
        int len = array.length;
        for(int k=0; k<len/2; k++){
            for(int i=k; i<len-1-k; i++){
                int tmp = array[k][i];
                array[k][i] = array[len-1-i][k];
                array[len-1-i][k] = array[len-1-k][len-1-i];
                array[len-1-k][len-1-i] = array[i][len-1-k];
                array[i][len-1-k] = tmp;
            }
        }
    }

    // /Users/cat/myfile/github/java/TryRArr.java
    public static void spiral(int[][] arr){
        int height = arr.length;
        int width= arr[0].length;
        int min = Math.min(width, height);
        int k = 0;
        while(k < width){
            // [2, 1]
            // horizonal 
            if(height - 2*k == 1){
                for(int i=k; i<width-k; i++)
                    Print.p(arr[k][i]); // horizontal

                break;
            }
            else if(width - 2*k == 1){
                for(int i=k; i<height-k; i++)
                    Print.p(arr[i][k]); // vertical 

                break;
            }
            else{
                for(int i=k; i<width-1-k; i++)
                    Print.p(arr[k][i]);
                for(int i=k; i<height-1-k; i++)
                    Print.p(arr[i][width-1-k]);
                for(int i=k; i<width-1-k; i++)
                    Print.p(arr[height-1-k][width-1-i]);
                for(int i=k; i<height-1-k; i++)
                    Print.p(arr[height-1-i][k]);
            }
            k++;
        }
    }

} 

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TrySerialize{
    public static void main(String[] args) {
        test0();
    }
    public static void test0(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        List<String> list = new ArrayList<String>(); 
        inorder(b1.root, list);
        Aron.printList(list);


        Iterator<String> ite = list.iterator(); 
        Node root = serialize(ite);

        level = 0;
        isLeaf = true;
        Aron.prettyPrint(root, level, isLeaf);
        Aron.binImage(root); 

    }
    public static void inorder(Node r, List<String> list){
        if(r != null){
            list.add(r.data + "");
            inorder(r.left, list);
            inorder(r.right, list);
        }else{
            list.add("#");
        }
    }
    
    public static Node serialize(Iterator<String> ite){
        if(ite.hasNext()){
            String s = ite.next();
            if(!s.equals("#")){
                Node parent = new Node(s);
                parent.left = serialize(ite); 
                parent.right = serialize(ite);
                return parent;
            }
        }
        return null;
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryTime{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        XTime.start();
        for(int i=0; i<1000000; i++)
            Print.pbl(i);
            
        XTime.stop();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

/Users/cat/myfile/github/java

public class TryTry0{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    // instead of 
    // double LinkedList 
    // what is double LinkedList 
    // what is double LinkedList
    public static void Donald_Trump(List<Integer> mlist){
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

// gx http://stackoverflow.com/questions/31986332/visitor-vs-servant-vs-command-patterns 
interface IMobile{
}

class IPhone implements IMobile{
    String name;
    public IPhone(String name){
        this.name = name;
    }
    public void turnOn(IBluetooth b){
        b.switchOn(this);
    }
}

class Android implements IMobile{
    String name;
    public Android(String name){
        this.name = name;
    }
    public void turnOn(IBluetooth b){
        b.switchOn(this);
    }
}

interface IBluetooth{
    public void switchOn(IPhone iphone);
    public void switchOn(Android android);
}

class VisitorBlueTooth implements IBluetooth{
    public void switchOn(IPhone iphone){
        Print.pbl(iphone.name);
    }
    public void switchOn(Android android){
        Print.pbl(android.name);
    }
}

public class TryVisitorPattern{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();

        IPhone iphone = new IPhone("iPhone");
        Android android = new Android("android");
        VisitorBlueTooth visitor = new VisitorBlueTooth();
        visitor.switchOn(iphone);
        visitor.switchOn(android);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class Tryee{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
//
import classfile.*; 

public class Tryhh{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        
        String fname = "/Users/cat/myfile/github/java";
        List<String> list = Aron.getCurrentDir(fname);
        Aron.printList(list);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        String fname = "/Users/cat/myfile/github/java";
        List<String> list = fileList(fname);
        Aron.printList(list);

        Aron.end();
    }

    // get all files from current directory
    // return a list of absoluate paths
    // getcurrent file, 
    public static List<String> getCurrentFiles(String directoryName) {
        List<String> list = new ArrayList<String>(); 
        File directory = new File(directoryName);
        File[] fList = directory.listFiles();
        for (File file : fList) {
            if (file.isFile()) {
                list.add(file.getAbsolutePath());
            } 
        }
        return list;
    }

    public static List<String> fileList(String directory) {
        List<String> fileNames = new ArrayList<>();
        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(Paths.get(directory))) {
            for (Path path : directoryStream) {
                fileNames.add(path.toString());
            }
        } catch (IOException ex) {}
        return fileNames;
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class TwoIntSum
{
	public static void main(String args[])
	{
		int[] Arr={1, 2, 3, 3, 3, 3, 1, 5, 2, 4};
		TwoIntSum(Arr, 6);
	}
	//list has repeating numbers
	public static void TwoIntSum(int[] Arr, int sum)
	{
		if(Arr != null)
		{
			Map<Integer, Integer> map = new HashMap<Integer, Integer>();
			int len = Arr.length;
			int[] diffArr = new int[len];

			for(int i=0; i<len; i++)
			{ diffArr[i] = sum - Arr[i]; 
				if(map.containsKey(new Integer(Arr[i])))
				{ int val = map.get(new Integer(Arr[i])).intValue();
					val++;
					map.put(new Integer(Arr[i]), new Integer(val));
				}
				else
					map.put(new Integer(Arr[i]), new Integer(1)); 
			}

			for(int i=0; i<len; i++)
			{ if(map.containsKey(new Integer(diffArr[i])))
				{ int val = map.get(new Integer(diffArr[i])).intValue();
					if(val>0)
					{ val--;
						map.put(new Integer(diffArr[i]), val);

						int pair = sum - diffArr[i];	
						if(map.containsKey(new Integer(pair)))
						{
							int pval = map.get(new Integer(pair)).intValue();
							if(pval > 0)
							{
								pval--;
								map.put(new Integer(pair), pval);
								System.out.println("["+i+"]="+diffArr[i]);
								System.out.println("pair="+pair);
							}
						}
					}
				}
			}
		}	 //end if
	}//end TwoIntSum()
}
import java.util.*;

class Pair{
    public String name;
    public Pair(String name){
        this.name = name;
    }
}

class PairCompare implements Comparator<Pair>{
    public int compare(Pair p1, Pair p2){
        return p1.name.compareToIgnoreCase(p2.name); 
    }
}

public class UniquePair{
    public static void main(String[] args){
        List<Pair> list = new ArrayList<Pair>();
        list.add(new Pair("dog"));
        list.add(new Pair("god"));
        list.add(new Pair("abc"));

        Collections.sort(list, new PairCompare());

        for(Pair p : list){
            System.out.println("[" + p.name + "]");
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Item{
    String name;
    double price;
}
                     
class VendorMachine {
    Map<String, List<Item>> map = new Hashmap<String, List<Item>>();
    double total;
    public VendorMachine(){
    }

    public Item buy(double cash, String key){
        List<Item> list = map.get(key);
        if(list != null){
            if(cash > list[list.size()-1].price){
                Item item = list.remove();
                if(list.isEmpty())
                    map.remove(key);
            }
        }
        return item;
    }
    public double change(double cash, Item item){
        if(item != null){
            return cash - item.price;
        }
        return 0;
    }
}


public class Hello
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test99();
    }
    public static void test99() {
        Queue<String> q1 = new LinkedList<String>();
        Queue<String> q2 = new LinkedList<String>();
        q1 = q2;
    }

}
import java.util.*;
import java.io.*;
import classfile.*;

// gf http://stackoverflow.com/questions/31986332/visitor-vs-servant-vs-command-patterns
interface IMobile{
}

class IPhone implements IMobile{
    public void turnOn(IBluetooth b){
        b.switchOn(this);
    }
}

class Android implements IMobile{
    public void turnOn(IBluetooth b){
        b.switchOn(this);
    }
}

interface IBluetooth{
    public void switchOn(IPhone iphone);
    public void switchOn(Android android);
}

class VisitorBlueTooth implements IBluetooth{
    public void switchOn(IPhone iphone){
    }
    public void switchOn(Android android){
    }
}

public class VisitorPattern{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class WordPath{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        List<String> list = new ArrayList<String>();
        Set<String> dict = new HashSet<String>(Arrays.asList("cat", "kat", "kit")); 
        int index = 0;

        String sWord = "cat";
        String eWord = "kit";


        String foundWord = removeWord(sWord, dict, index);
        list.add(foundWord);
        if(!foundWord.equals(eWord)){
            dict.remove(foundWord);
        }
        Print.p(foundWord);


        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        List<String> list = new ArrayList<String>();
        Set<String> dict = new HashSet<String>(Arrays.asList("cat", "kat", "kit", "cit")); 
        int index = 0;

        String sWord = "cat";
        String eWord = "kit";
        listWords(sWord, eWord, list, dict);
        Aron.printList(list);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        List<String> list = new ArrayList<String>();
        Set<String> dict = new HashSet<String>(Arrays.asList("kat", "cat", "cow")); 
        int index = 0;

        String sWord = "cat";
        String eWord = "cow";
        listWords(sWord, eWord, list, dict);
        Aron.printList(list);

        Aron.end();
    }

    // cat -> kat
    public static void listWords(String sWord, String eWord, List<String> list, Set<String> dict){
        int index = 0;
        String foundWord = removeWord(sWord, dict, index);
        if(foundWord.length() > 0){ 
            list.add(foundWord);
            dict.remove(foundWord);
            Print.p("fw=" + foundWord);
            Print.p("eWord=" + eWord);
            if(!foundWord.equals(eWord)){
                listWords(foundWord, eWord, list, dict);
            }else{
                Print.p("size=" + list.size());
                Aron.printList(list);
            }
            dict.add(foundWord);
            list.remove(list.size()-1);
        }
    }

    // index = 0
    public static String removeWord(String sWord, Set<String> dict, int index){
        String ret = "";
        if(index < sWord.length()){
            for(char ch='a'; ch<='z' && ret.length() == 0; ch++){
            //for(char ch='a'; ch<='z'; ch++){
                char[] arr = sWord.toCharArray();
                char tmp = arr[index];
                arr[index] = ch;
                String changeWord = new String(arr); 
                if(dict.contains(changeWord)){
                    return changeWord;
                }
                ret = removeWord(sWord, dict, index+1);
            }
        }
        return ret;
    }
} 

import java.util.*;
class ConvertWordToNumber
{
    Map<String, Integer> map = new HashMap<String, Integer>();
    public ConvertWordToNumber()
    {
        InitMap();
    }
    public void InitMap()
    {
        map.put("zero", 0);
        map.put("one", 1);
        map.put("two", 2);
        map.put("three", 3);
        map.put("four", 4);
        map.put("five", 5);
        map.put("six", 6);
        map.put("seven", 7);
        map.put("eight", 8);
        map.put("nine", 9);

        map.put("ten", 10);
        map.put("eleven", 11);
        map.put("twelve", 12);
        map.put("thirteen", 13);
        map.put("fourteen", 14);
        map.put("fifteen", 15);
        map.put("sixteen", 16);
        map.put("seventeen", 17);
        map.put("eighteen", 18);
        map.put("nineteen", 19);

        map.put("twenty", 20);
        map.put("thirty", 30);
        map.put("forty", 40);
        map.put("fifty", 50);
        map.put("sixty", 60);
        map.put("seventy", 70);
        map.put("eighty", 80);
        map.put("ninety", 90);

        map.put("hundred", 100);
        map.put("thousand", 1000);
        map.put("million", 1000000);
        map.put("billion", 1000000000);
    }

    public int Convert2(String englishWord)
    {
        String[] array = englishWord.split(" ");
        int sum = 0;
        int total = 0;
        for(int i=0; i<array.length; i++)
        {
            int base = map.get(array[i]);
            if(base == 1000 || base == 1000000 
                    || base == 1000000000)
            {
                sum *= base;
                total += sum;
                sum = 0;
            }
            else
            {
                if(base == 100)
                    sum *= base;
                else
                    sum += base;
            }
        }
        total += sum;
        return total;
    }

    public int Convert(String englishWord)
    {
        String[] array = englishWord.split(" ");    
        int sum = 0; int s = 0;
        if(array != null)
        {   
            for(int i=0; i<array.length; i++)
            {
                Integer n = map.get(array[i]);            
                System.out.print("{"+n+"}");
                if(n == 1000 || n == 1000000 || n == 1000000000)
                {
                    s *= n;
                    sum += s;
                    s = 0;
                }
                else if( n == 100)
                {
                    s *= n;
                }
                else
                {
                    s += n;
                }
            }
            sum += s;
        }
        return sum;
    }
}

public class WordToNumber 
{
    public static void main(String[] args)
    {
        System.out.println("Convert English spoken number to numerical number");
        ConvertWordToNumber num = new ConvertWordToNumber();
        String words = "nine million five thousand two hundred twelve";
        int n =  num.Convert2(words);
        System.out.println();
        System.out.println(words);
        System.out.println("["+n+"]");

        words = "one";
        n =  num.Convert2(words);
        System.out.println("["+n+"]");

        System.out.println();
        words = "one thousand";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");

        System.out.println();
        words = "two hundred twelve ";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");

        System.out.println();
        words = "seven million twelve thousand four hundred twenty nine";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");

        System.out.println();
        words = "seven million twenty one thousand four hundred twenty nine";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");


        System.out.println();
        words = "zero";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");


    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.io.output.TeeOutputStream;

import classfile.*;

public class WriteOutputConsole {
    public static void main(String[] args) {
//        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        String fName = "./text/myfile3.txt";
        String content = "This is my file";
        Aron.writeFileBoth(fName, content);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        
        String fName = "./text/file33.txt";
        List<String> list = Arrays.asList("cat\n", "dog\n", "cow\n");

        Aron.writeFileBoth(fName, list);

        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

public class allPairSum{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
    }
    public static void test0() {
        Aron.beg();
        Integer[] arr = {1, 2, 3, 4}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 0);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Integer[] arr = {1, 3, 3, 7}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 2);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();
        Integer[] arr = {1, 4, 4, 7}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 4);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        Integer[] arr = {1, 4, 4, 4}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 2);

        Aron.end();
    }

    public static void test4() {
        Aron.beg();
        Integer[] arr = {1, 4, 4, 4, 4}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 4);

        Aron.end();
    }
    public static void test5() {
        Aron.beg();
        Integer[] arr = {1, 4, 4, 4, 4, 4, 7}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 6);

        Aron.end();
    }

    //[ file=pairofelements.html title=""
    // [4, 1, 7] 8
    // {4, 7, 1}
    // 4 -> 1
    // 7 -> 1
    // 1 -> 1
    //
    // [4, 4, 1, 7]
    // {4, 4, 7, 1}
    // 4->2
    // 7->1
    // 1->1
    public static List<Integer> sum(Integer[] arr, int sum) {
        List<Integer> list = new ArrayList<Integer>(); 
        if(arr != null){
            int len = arr.length;
            Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
            for(Integer n : arr){
                if(map.containsKey(n)){
                    Integer v = map.get(n);
                    map.put(sum - n, v.intValue() + 1);
                }else{
                    map.put(sum - n, 1);
                }
            }

            for(Integer n : arr){
                if(map.containsKey(n)){
                    Integer v = map.get(n);
                    if(v != null){
                        if(2*n == sum){
                            if(v.intValue() > 1){
                                if(v.intValue() % 2 == 1){
                                    for(int i=0; i<v.intValue()-1; i++)
                                        list.add(n);
                                }else{
                                    for(int i=0; i<v.intValue(); i++)
                                        list.add(n);
                                }
                                map.remove(n);
                            }
                        }else{
                            list.add(n);
                        }
                    }
                }
            }
            
        }
        return list;
    }
    //]

}

import java.io.*;
class allprime 
{
	public static void main(String args[])
	{
		allprime(10000);
	}
	public static void allprime(int num)
	{
		boolean[] primeArr = new boolean[num+1];
		for(int i=2; i<=num; i++)
			primeArr[i] = true;	

		for(int i=2; i<=num; i++)
			for(int j=i; i*j<=num; j++)
				primeArr[i*j] = false;

		int count=1;
		for(int i=2; i<=num; i++)
		{
			if(primeArr[i])
			{
				System.out.print(String.format("%6d", i));
				if(count%30==0)	
					System.out.println();
				count++;
			}
		}
		System.out.println();
	}
}
import java.io.*;
import java.util.Collections;
import java.util.ArrayList;
import java.lang.Number;
class biggest 
{
	public static void main(String args[])
	{
		int j = 0;
		String str= "2334343535";
		ArrayList<Integer> list = new ArrayList<Integer>();
		int len = str.length();
		char[] Ch = new char[len];
		if(len > 1)
		{
			for(int i = 0; i < len - 1; i++)
			{
				int a0 = str.charAt(i) - '0';
				int a1 = str.charAt(i + 1) - '0';
				int d = a1 - a0;
				if( d == 1)
				{
					System.out.println("d=" + d);	
					Ch[j] = str.charAt(i);
					j++;
				}
				else 
				{
					if(j > 0)
					{
						System.out.println("Ch=" + Ch);
						int num = Integer.parseInt(new String(Ch));
						System.out.println("num=" + num);
						list.add(num);
						j = 0;
					}
				}
			}
		}

	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class binperm 
{
	public static void main(String args[])
	{
		ArrayList<String> list = new ArrayList<String>();
		char[] charArr = {'1','a', 'b', 'c', 'c', 'c', 'a', 'k', 'e'};
		//char[] charArr = {'a'};
		int i=0;
		binperm(charArr, i, list);
		for(int j=0; j<list.size(); j++)
			System.out.println("list["+j+"]="+list.get(j));
	}
	

	public static void binperm(char[] charArr, int i, ArrayList<String> list)
	{
		if( charArr != null)
		{
			if(i < charArr.length)
			{
				if(('a' <= charArr[i] && charArr[i] <= 'z') || ('A' <= charArr[i] && charArr[i] <= 'Z'))
				{
					charArr[i] = Character.toUpperCase(charArr[i]);
					if(i == charArr.length-1)
					list.add(new String(charArr));
					binperm(charArr, i+1, list);

					charArr[i] = Character.toLowerCase(charArr[i]);
					if(i == charArr.length-1)
					list.add(new String(charArr));
					binperm(charArr, i+1, list);
				}
				else
				{
					if(i == charArr.length-1)
					list.add(new String(charArr));
					binperm(charArr, i+1, list);
				}
			}
		}
	}	
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

class NNode{
    NNode left;
    NNode right;
    int data;
    public NNode(int data){
        this.data = data;
    }
}

class BINTree{
    public NNode root = null;
    public BINTree(){
    }

    public void insert(NNode node){
        NNode curr = root;
        if(curr == null){
            root = curr = node;
        }else{
            while(curr != null){
                if(node.data < root.data){
                    if(curr.left == null){
                        curr.left = node;
                        break;
                    }
                    else
                        curr = curr.left;
                }
                else{
                    if(curr.right == null){
                        curr.right = node;
                        break;
                    }
                    else
                        curr = curr.right;
                }
            }
        }
    }

    public void print(NNode r){
        if(r != null){
            print(r.left);
            Print.pb(r.data);
            print(r.right);
        }
    }

}

public class bst_try{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        NNode n1 = new NNode(9);
        NNode n2 = new NNode(5);
        NNode n3 = new NNode(11);
        BINTree tree = new BINTree();
        tree.insert(n1);
        tree.insert(n2);
        tree.insert(n3);
        tree.print(tree.root);
        Ut.l();

        NNode n4 = new NNode(20);
        insert(tree.root, n4); 

        tree.print(tree.root);

        Aron.end();
    }

    public static void insert(NNode r, NNode node){
        if(r == null)
            r = node;
        else{
            if(node.data < r.data)
                if(r.left == null)
                    r.left = node;
                else
                    insert(r.left, node);
            else{
                if(r.right == null)
                    r.right = node;
                else 
                    insert(r.right, node);
            }
        }

    }

    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class  checkparentheses 
{
	public static void main(String args[])
	{
		String str="{[][}]";
		boolean ret = checkparentheses(str);

		System.out.println("ret="+ret);
	}

	public static boolean checkparentheses(String str)
	{
			Stack<String> st = new Stack<String>();	
			Map<String, String> map = new HashMap<String, String>();
			map.put(")", "(");
			map.put("]", "[");
			map.put("}", "{");
			boolean ret = true;
			if( str != null)
			{
				for(int i=0; i<str.length() && ret; i++)
				{
					String chstr = str.charAt(i) + "";
					if(chstr.equals("(") ||
							chstr.equals("[") || 
							chstr.equals("{"))
					{
						st.push(chstr);
					}
					else
					{ if(st.empty())
							ret = false;
						else 
						{ String p = st.pop();
							String mp = map.get(str.charAt(i)+"");
							if( p.equals(mp))
								ret = true;
							else
								ret = false;
						}
					}
				}
			}
			if(!st.empty())
				ret = false;
			return ret;
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

public class connectLevelOrder{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        BST bst = Aron.createBin(); 
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(bst.root, level, isLeaf);
        Ut.l();
        Node head = levelLink(bst.root);
        Aron.printSLL(head);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        BST bst = Aron.createBin(); 
        levelOrderLink(bst.root);
        Print.pbl(bst.root.left.next.data);
        Aron.end();
    }

    // connect each *levelorder*, connect level order, link levelorder
    public static void levelOrderLink(Node r){
        Queue<Node> q1 = new LinkedList<>(); 
        Queue<Node> q2 = new LinkedList<>(); 
        if(r != null){
            q1.add(r);
            while(q1.size() > 0 || q2.size() > 0){
                Node prev = null;
                while(q1.size() > 0){
                    Node curr = q1.poll();
                    if( prev != null)
                        prev.next = curr;
                    prev = curr;
                    if(curr.left != null)
                        q2.add(curr.left);
                    if(curr.right != null)
                        q2.add(curr.right);
                }

                prev = null;
                while(q2.size() > 0){
                    Node curr = q2.poll();
                    if( prev != null)
                        prev.next = curr;
                    prev = curr;
                    if(curr.left != null)
                        q1.add(curr.left);
                    if(curr.right != null)
                        q1.add(curr.right);
                }
            }
        }
    }


    // connect all node in level order *levelorder*
    public static Node levelLink(Node r){
        Node head = null;
        if( r != null){
            Queue<Node> queue = new LinkedList<>(); 
            queue.add(r);
            Node prev = null;
            while(queue.size() > 0){
                Node curr = queue.poll();
                if(prev != null)
                    prev.next = curr;
                else
                    head = prev = curr;

                prev = curr;

                if(curr.left != null)
                    queue.add(curr.left);
                if(curr.right != null)
                    queue.add(curr.right);
            }
        }
        return head;
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class constructNLTreefromPre 
{
	public static void main(String args[])
	{
		char[] Arr = {'N', 'N','L','L','N','L','L'};
		int[] inx={0};
		Node myroot= constructTree(Arr, inx);
		Inorder(myroot);
	}
	
	public static Node constructTree(char[] Arr, int[] inx)
	{
		Node root= new Node(Arr[inx[0]]);
		if(Arr[inx[0]] == 'L')
			;
		else 
		{
			inx[0]++;
			root.left = constructTree(Arr, inx);	
			inx[0]++;
			root.right = constructTree(Arr, inx);
		}
		return root;
	}
	
	
	public static void Inorder(Node root)
	{
		if( root != null)
		{ Inorder(root.left);
			System.out.println((char)root.data);
			Inorder(root.right);
		}
	}
	public static void PreOrder(Node root)
	{
		if(root != null)
		{
			System.out.println("pre=" + (char)root.data);
			PreOrder(root.left);
			PreOrder(root.right);
		}
	}
}
import java.util.List;
import java.util.ArrayList;


public class containList
{
	public static void main(String[] args)
	{
		ArrayList<String> mylist = new ArrayList<String>();
		mylist.add("cool");
		mylist.add("dog");
		mylist.add("apple");
		
		if(mylist.contains("dog"))
		{
			System.out.println("mylist contains dog");
		}
		else
		{
			System.out.println("mylist does not contains dog");
		}
	}
}

import java.util.*;
public class countComponent 
{
	public static void main(String[] args)
	{
        //test case 
        // A = null
        // A = {};
        // A = {{0}};
        // A = {{1}};
        // A = general case
		System.out.println("Hello World!");
        
        int[][] A = null; 
        int count = count(A);
        System.out.println("count="+count);

        int[][] B = {};
        count = count(B);
        System.out.println("count=0="+count);

        int[][] C = {{0}};
        count = count(C);
        System.out.println("count=1="+count);

        int[][] D = {{1}};
        count = count(D);
        System.out.println("count=0="+count);

        int[][] E = {
            {0, 0},
            {0, 0}
        };
        count = count(E);
        System.out.println("count=1="+count);
        
         int[][] F = {
            {0, 1},
            {1, 0}
        };
        count = count(F);
        System.out.println("count=2="+count);

        int[][] H = {   {1, 1, 1, 1},
                        {1, 1, 0, 1},
                        {0, 1, 1, 1},
                        {0, 1, 1, 1}
                    };
        int col=0, row=0;
        int num=0;
        count = DFSCount(H, col, row);
        System.out.println("count=2="+count);

        int[][] G = {   {0, 1, 1, 1},
                        {1, 1, 0, 1},
                        {0, 1, 0, 1},
                        {0, 0, 0, 0}
                    };

	}
	static void component(int[][] A, int x, int y)
	{
		if(A != null && A[0] != null)
		{
            if(A[x][y] == 0)
            {
                A[x][y] = 2;
                if(x+1 < A.length)
                    component(A, x+1, y);	
                if(x-1 >= 0)
                    component(A, x-1, y);	
                if(y+1 < A.length)
                    component(A, x, y+1);	
                if(y-1 >= 0)
                    component(A, x, y-1);	
            }
		}
	}
    static int DFSCount(int[][] A, int col, int row)
    {
        int c0=0, c1=0, c2=0, c3=0, c4=0;
        if(A != null)
        {
            if(A[col][row] == 0)
            {
                component(A, col, row);
                c0++;
            }
            else if(A[col][row] == 1)
            {
                A[col][row] = 2;
                if(col+1 < A.length)
                    c1 = DFSCount(A, col+1, row);
                if(col-1 >= 0)
                    c2 = DFSCount(A, col-1, row);
                if(row+1 < A.length)
                    c3 = DFSCount(A, col, row+1);
                if(row-1 >= 0)
                    c4 = DFSCount(A, col, row-1);
            }
        }
        return c0 + c1 + c2 + c3 + c4;
    }
	static int  count(int[][] A)
	{
        int s=0;
        if(A != null)
        {
            for(int i=0; i<A.length; i++)   
            {
                for(int j=0; j<A.length; j++)
                {
                    if(A[i][j] == 0)
                    {
                        component(A, i, j);
                        s += 1;
                    }
                }
            }
        }
        return s;
	}
}
public class daysInMonth 
{
    public static void main(String[] args)
    {
        System.out.println("determining the numbers of day in a month");

        int month = 2; 
        int year = 2100;
        for(int i=0; i < 12; i++)
        {
            month = i + 1;
            int days = daysInMonth(month, year);
            System.out.println("days="+days);
        }
        test_isLeapyear();
        test_daysInMonth();
    }
    public static boolean isLeapYear(int year)
    {
        boolean retBool = false;
        if(year % 4 == 0 && year % 100 != 0 || year % 400 == 0)
            retBool = true;
        return retBool;
    }
    public static int daysInMonth(int month, int year)
    {
        int days=0;
        if(month == 2)
        {
            days = 28 + (isLeapYear(year)? 1 : 0);
        }
        else 
        {
            days = 30 + ((month-1) % 7 % 2 == 0? 0 : 1);
        }
        return days;
    }
    public static void test_daysInMonth()
    {
        int[] leapYearArray = {
            2008,
            2012,
            2016,
            2020,
            2024,
            2028,
            2032
        };
        for(int i=0; i< leapYearArray.length; i++){

            int year = leapYearArray[i];
            for(int j=0; j<11; j++){
                int month = j+1;
                System.out.println("daysInMonth="+daysInMonth(month, year));
            }
            System.out.println("");
        }
    }
    public static void test_isLeapyear()
    {
        int[] leapYearArray = {
            2008,
            2012,
            2016,
            2020,
            2024,
            2028,
            2032
        };
        for(int year : leapYearArray)
        {
            boolean isleap = isLeapYear(year);
            System.out.println("isleap="+isleap);
        }
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class delete_node{
    public static void main(String[] args) {
//        test0();
//        test_deleteNode();
//        test_delete();
//        test_delete1();
//        test_delete2();
        //test_deleteList();
        test_rotateRight();
        test_rotateLeft();
    }

    public static void test0(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        Aron.end();
    }
    public static void test_delete(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(9);
        b1.insert(8);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        int n = 8;
        Node root = delete(b1.root, n);

        Ut.l();
        Aron.prettyPrint(b1.root, level, isLeaf);
        

        Aron.end();
    }

    public static void test_delete1(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(9);
        b1.insert(8);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        int n = 7;
        Node root = delete(b1.root, n);

        Ut.l();
        Aron.prettyPrint(b1.root, level, isLeaf);
        

        Aron.end();
    }

    public static void test_delete2(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(9);
        b1.insert(8);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        int n = 10;
        Node root = b1.root;
        Node node = delete(b1.root, n);
        if(b1.root.data == n)
            root = b1.root.left;

        Ut.l();
        Aron.prettyPrint(root, level, isLeaf);

        Aron.end();
    }

    public static void test_deleteList(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(9);
        b1.insert(8);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        int n = 10;
        Node root = deleteList(b1.root, n);
        Ut.l();
        Aron.prettyPrint(root, level, isLeaf);
        

        Aron.end();
    }

    public static void test_rotateRight(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(9);
        b1.insert(8);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);

        Node root = rotateRight(b1.root);
        Aron.prettyPrint(root, level, isLeaf);


        Aron.end();
    }
    public static void test_rotateLeft(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(8);
        b1.insert(9);
        b1.insert(10);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);

        Node root = rotateLeft(b1.root);
        Aron.prettyPrint(root, level, isLeaf);


        Aron.end();
    }
    public static Node rotateRight(Node curr){
        if(curr != null){
            if(curr.left != null && curr.left.left != null){
                Node parent = curr.left;
                parent.right = curr;
                curr.left = null;
                return parent;
            }
        }
        return null;
    }
    
    public static Node rotateLeft(Node curr){
        if(curr != null){
            if(curr.right != null && curr.right.right != null){
                Node parent = curr.right;
                parent.left = curr;
                curr.right = null;
                return parent;
            }
        }
        return null;
    }
    
    public static Node deleteList(Node curr, int n){
        if(curr != null){
            if(curr.data == n)
                return curr.left;
            else{
                delete(curr, n);
                return curr;
            }
        }
        return null;
    }

    public static Node delete(Node curr, int n){
        if(curr != null){
                if(curr.data == n)
                    return curr.left;
                else{
                    curr.left = delete(curr.left, n);
                    return curr;
                }
               
        }
        return null;
    }

    public static void deleteNode(Node curr){
        Node r = curr;
        while(r != null){
            Node left = r.left;
            Node right = r.right;
            if(left != null && right != null){
                while(left.left != null)
                    left = left.left;

                left.left = right;

                Print.pb("d=" + r.data);
                r = r.left;
            }else if(left != null){
                Print.pb("d=" + r.data);
                r = r.left;
            }else if(right != null){
                Print.pb("d=" + r.data);
                r = r.right;
            }else{
                Print.pb("d=" + r.data);
                r = null;
            }
        }
    }
    public static void test_deleteNode(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        deleteNode(b1.root);

        Aron.end();
    }
} 

public class findStringMatrix 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");

        int[][] array = {
            {0, 0},
            {0, 1}
        };
        int[] source = {0, 0};
        /*
        int[][] array = {
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},

            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        }
        */
        int count = 0;
        for(int row=0; row < array.length; row++){
            for(int col=0; col< array.length; col++){
               count = countString(array, source, row, col, 0); 
            }
        }
        System.out.println("count="+count);
    }
    public static int countString(int[][] array, int[] source, int row, int col, int sourceIndex)
    {
        if(col < array.length && row < array.length)
        {
            if(sourceIndex == source.length)
            {
                return 1;
            }
            else
            {
                if(array[row][col] == source[sourceIndex])
                {
                    int horizonal_right     = countString(array, source, row, col+1, sourceIndex+1);
                    int horizonal_left      = countString(array, source, row, col-1, sourceIndex+1);
                    int vertical_down       = countString(array, source, row+1, col, sourceIndex+1);
                    int vertical_up         = countString(array, source, row-1, col, sourceIndex+1);
                    int diagonal_main_up    = countString(array, source, row+1, col+1, sourceIndex+1);
                    int diagonal_main_down  = countString(array, source, row-1, col-1, sourceIndex+1);
                    int diagonal_minor_up   = countString(array, source, row-1, col+1, sourceIndex+1);
                    int diagonal_minor_down = countString(array, source, row+1, col-1, sourceIndex+1);
                    return horizonal_right + horizonal_left + vertical_down + vertical_up + diagonal_main_up + diagonal_main_down + diagonal_minor_up + diagonal_minor_down;
                }
            }
        }
        else
        {
            return 0;
        }
        return 0;
    }
}
import java.io.*;
import java.lang.String;
import java.lang.Math;
import java.util.*;
class flipbit 
{
	public static void main(String args[])
	{
		int num = 10;
		String numBin = Integer.toBinaryString(num);
		System.out.println("num=" + num);
		System.out.println("numBin=" + numBin);

		int n = flip(num);
		String nBin = Integer.toBinaryString(n);
		System.out.println("n=" + n);
		System.out.println("nBin=" + nBin);
	}
	public static int flip(int n)
	{
		int nbit = (int)Math.floor(Math.log(n)) + 1;
		return  ((int)Math.pow(2, nbit+1) - 1)^n;
	}
	
}
import java.io.*;
import java.lang.String;
import java.util.*;

public class fold{
    public static void main(String[] args) {
        System.out.println("Hello World!");
        System.out.println("foldr (-) 1 [2, 3, 4] = " + foldr(2));
        System.out.println("foldl (-) 1 [2, 3, 4] = " + foldl(4));
    }

    //[file = foldjava.html title=""
    // foldr (-) 1 [2, 3, 4]  output = 2 
    public static int foldr(int n){
        if(n == 4){
            return n - 1;
        }
        else{
            return n - foldr(n + 1);
        }
    }
    // foldl (-) 1 [2, 3, 4] output = -8 
    public static int foldl(int n){
        if(n == 2){
            return 1 - n;
        }else{
            return foldl(n-1) - n;
        }
    }
    //]
}
// getResource() for static class
import java.net.*;
public class getResource 
{
				public static void main(String[] args)
				{
								URL url = Hello.class.getClass().getResource("");
								System.out.println("url="+url);
								System.out.println("Hello World!");
				}
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class hash_try{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.io.*;

class MyHeap
{
	final int Max = 100;
	int[] Arr = new int[Max];
	int inx;
	int size;
	public MyHeap()
	{ inx = 0;}

	public void insert(int n)
	{
		if(inx < Max)
		{
			inx++;
			Arr[inx] = n;
			heapify(inx);
		}
	}
	public void remove()
	{
		if(inx == 1)
			inx--;
		else if(inx > 1)
		{
			int tmp = Arr[1];
			Arr[1] = Arr[inx];
			inx--;
			heapDown(1);
		}
	}
	public void heapDown(int index)
	{
		int leftchild = index*2;
		int rightchild = index*2 + 1;

		if(rightchild <= inx)
		{
			if(Arr[leftchild] < Arr[rightchild])
			{
				if(Arr[index] > Arr[leftchild])
				{ int tmp = Arr[index];
					Arr[index] = Arr[leftchild];
					Arr[leftchild] = tmp;
					heapDown(leftchild);
				}
			}
			else
			{
				if(Arr[index] > Arr[rightchild])
				{ int tmp = Arr[index];
					Arr[index] = Arr[rightchild];
					Arr[rightchild] = tmp;
					heapDown(rightchild);
				}
			}
		}
		else
		{
			if(leftchild <= inx)
			{
				if(Arr[index] > Arr[leftchild])
				{ int tmp = Arr[index];
					Arr[index] = Arr[leftchild];
					Arr[leftchild] = tmp;
					heapDown(leftchild);
				}
			}
		}
	}
	public void heapify(int index)
	{
		int parent = index/2;
		if(parent >= 1)
		{
			if(Arr[index] < Arr[parent])
			{
				int tmp = Arr[index];
				Arr[index] = Arr[parent];
				Arr[parent] = tmp;
				heapify(parent);
			}
		}
	}
	public void show()
	{
		for(int i=1; i<=inx; i++)
		{
			System.out.println("Arr[" + i + "]=" + Arr[i]);
		}	
	}
}

class heap 
{
	public static void main(String args[])
	{
		MyHeap h = new MyHeap();
		h.insert(100);
		h.insert(11);
		h.show();
		h.remove();
		System.out.println("cool");
		h.show();
		System.out.println("cool");
	}
}
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
 
public class hellofx extends Application {
    public static void main(String[] args) {
        launch(args);
    }
    
    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle("Hello World!");
        Button btn = new Button();
        btn.setText("Say 'Hello World'");
        btn.setOnAction(new EventHandler<ActionEvent>() {
 
            @Override
            public void handle(ActionEvent event) {
                System.out.println("Hello World!");

                FileChooser fileChooser = new FileChooser();
                fileChooser.setTitle("Open Resource File");
                fileChooser.showOpenDialog(stage);

            }
        });
        
        StackPane root = new StackPane();
        root.getChildren().add(btn);
        primaryStage.setScene(new Scene(root, 300, 250));
        primaryStage.show();
    }
}
import java.io.*;
import java.lang.*;
import java.util.*;
class infixTopostfix 
{
	public static void main(String args[])
	{
		System.out.println("cool");
		//tokenize("77+(12+4)x6+(9)");
		//String s = infixToprefix("(1+2)x3");
		//Vector<String> vet = infixToprefix("5x(6+2)-12/4");
		Vector<String> vet = infixToprefix("(1-4)x5");
		for(int i=0; i<vet.size(); i++)
			System.out.println("vet["+i+"]="+vet.get(i));
		int n = evaluate(vet);	
			System.out.println("s="+n);
	}
	public static Vector<String> infixToprefix(String str)
	{
		String p="";
		Vector<String> vet = null;
		Stack<String> st = new Stack<String>();
		ArrayList<String> list = tokenize(str);
		if( str != null)
		{ 
            vet = new Vector<String>();
			for(int i=0; i<list.size(); i++)
			{
				String s=list.get(i);
				System.out.println("["+s+"]");
				if( s.equals("("))
					st.push(s);
				else if( s.equals(")"))
				{ 
                    while(!st.empty() && !st.peek().equals("("))	
					{ //p += st.pop();  
						vet.add(st.pop());			
                    }
					if(!st.empty())
					{
						String str1 = st.pop();
						System.out.println("str1="+str1);
					}
				}
				else if( s.equals("+") || 
						s.equals("-") ||
						s.equals("x") ||
						s.equals("/") 
						)
				{
					if(st.empty() || st.peek().equals("("))	
						st.push(s);
					else 
					{
						while(!st.empty() && !st.peek().equals("(") && precedence(s) <= precedence(st.peek()))
							//p += st.pop();
							vet.add(st.pop());
						st.push(s);
					}
				}
				else //operand is found 
				{
					//p += s;
					vet.add(s);
				}
			}
			while(!st.empty())
				//p +=st.pop();
				vet.add(st.pop());
		}
		return vet;
	}	
	public static int eval(String s1, String ope, String s2)
	{
		int ret = 0;
		int n1 = Integer.parseInt(s1);
		int n2 = Integer.parseInt(s2);
		if( ope.equals("+"))
			ret = n1 + n2;
		else if( ope.equals("-"))
			ret = n1 - n2;
		else if(ope.equals("x"))
			ret = n1*n2;
		else if( ope.equals("/"))
			ret = n1/n2;
		else 
			System.out.println("Error operator:"+ope);
		return ret;
	}
	public static int evaluate(Vector<String> vet)
	{
		Stack<String> st = new Stack<String>();
		for(int i=0; i<vet.size(); i++)
		{
			String s=vet.get(i);
			if( s.equals("+") ||
					s.equals("-") ||
					s.equals("x") ||
					s.equals("/")) 
			{
				String A = st.pop();
				String B = st.pop();
				String value = eval(B, s, A) + "";
				st.push(value);
			}
			else
			{
				st.push(s);	
			}
		}	
		int ret = Integer.parseInt(st.pop());
		return ret;
	}
	public static int precedence(String ope)
	{ int ret = 1;
		if(ope.equals("+") || ope.equals("-"))
			ret = 1;
		else if(ope.equals("/") || ope.equals("x"))
			ret = 2;
		return ret;
	}
	public static ArrayList<String> tokenize(String str)
	{
		ArrayList<String> list = new ArrayList<String>();
		if( str != null)
		{
			char[] chArr =  str.toCharArray();	
			String s="";
			for(int i=0; i<chArr.length; i++)
			{
				if('0'<= chArr[i] && chArr[i] <= '9')
					 s += chArr[i];	
				else 
				{ if(!s.equals(""))
					{ list.add(s); s = "";}
					list.add(chArr[i]+"");
				}
			}
			if(!s.equals(""))
				list.add(s); s="";
		}
		for(int i=0; i<list.size(); i++)
		{
			System.out.println(list.get(i));
		}
		return list;
	}
}

import java.io.*;
import java.lang.String;
import java.util.*;
class intToBinHex 
{
	public static void main(String args[])
	{
		String bin = intToBinary(1);
		String hex = intToHex2(16);
		System.out.println("bin=" + bin);
		System.out.println("hex=" + hex);
	}
	public static String intToBinary(int num)
	{
		String s = "";
		if(num == 0)
		{
			s = "0";
		}
		else if(num > 0)
		{
			while(num > 0)
			{
				int mod = num%2;
						num = num/2;
						s = mod + s;
			}
		}
		return s;
	}
	public static String intToHex2(int num)
	{
		String s = "";
		char[][] map = { 
			{0, '0'},
			{1, '1'},
			{2, '2'},
			{3, '3'},
			{4, '4'},
			{5, '5'},
			{6, '6'},
			{7, '7'},
			{8, '8'},
			{9, '9'},
			{10, 'A'},
			{11, 'B'},
			{12, 'C'},
			{13, 'D'},
			{14, 'E'},
			{15, 'F'}
		};

		if( num == 0)
			s = map[0][1] + "";
		else if(num > 0)
		{
			while(num > 0)
			{
				int mod = num % 16;
						num = num/16;
						s = map[mod][1] + s;
			}
		}
		return s;
	}
	public static String intToHex(int num)
	{
		String s = "";
		Map<Integer, String>  map = new HashMap<Integer, String>();
		map.put(new Integer(0), "0");
		map.put(new Integer(1), "1");
		map.put(new Integer(2), "2");
		map.put(new Integer(3), "3");
		map.put(new Integer(4), "4");
		map.put(new Integer(5), "5");
		map.put(new Integer(6), "6");
		map.put(new Integer(7), "7");
		map.put(new Integer(8), "8");
		map.put(new Integer(9), "9");
		map.put(new Integer(10), "A");
		map.put(new Integer(11), "B");
		map.put(new Integer(12), "C");
		map.put(new Integer(13), "D");
		map.put(new Integer(14), "E");
		map.put(new Integer(15), "F");

		if(num == 0)
		{
			String hexMod = (String)map.get(new Integer(num));	
			s = hexMod + s;
		}
		else if(num > 0)
		{
			while(num > 0)
			{
				int mod = num%16;
						num = num/16;
						String hexMod = (String)map.get(new Integer(mod));	
						s = hexMod + s;
			}
		}
		return s;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class isBST {
    public static void main(String args[]) {
        test0();
        test1_isBSTDef();
        test2_isBSTDef();
        test3_isBSTDef();

        test11_isBST();
        test12_isBST();
    }
    
    static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);

        b1.insert(17);
        b1.insert(199);
        b1.insert(16);

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;

        Aron.inorder(b1.getRoot());

        Node[] prev = new Node[1];
        prev[0] = null;
        System.out.println(isBST2(b1.getRoot(), prev));
        System.out.println(isBST(b1.getRoot(), null));
        System.out.println(isBSTDef(b1.getRoot()));
        Aron.end();
    }
    static void test1_isBST(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        Aron.inorder(b1.root);
        Test.t(isBST(b1.root));

        Aron.end();
    }
    static void test11_isBST(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        Node prev = null;
        Aron.inorder(b1.root);
        Test.t(isBST(b1.root, prev));

        Aron.end();
    }
    static void test12_isBST(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(11);
        b1.insert(12);
        b1.insert(13);
        Node prev = null;
        Aron.inorder(b1.root);
        Test.t(isBST(b1.root, prev));

        Aron.end();
    }

    static void test1_isBSTDef(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        Aron.inorder(b1.root);
        Test.t(isBSTDef(b1.root));

        Aron.end();
    }
    static void test2_isBSTDef(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        Aron.inorder(b1.root);
        Test.t(isBSTDef(b1.root));

        Aron.end();
    }
    static void test3_isBSTDef(){
        Aron.beg();
        BST b1 = new BST();
        Aron.inorder(b1.root);
        Test.t(isBSTDef(b1.root));

        Aron.end();
    }
    public static void swap(int m, int n, Node root, Node[] first, Node[] second) {
        if(root != null) {
            swap(m, n, root.left, first, second);
            if(root.data == m) {
                first[0] = root;
            } else if(root.data == n) {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null) {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }
    //[ file=isbststatic.html title=""
    public static Node prev = null;
    public static boolean isBST(Node r) {
        if(r != null) {
            if(!isBST(r.left))
                return false;
            if(prev != null && prev.data >= r.data)
                return false;
            prev = r;
            if(!isBST(r.right))
                return false;
        }
        return true;
    }
    //]

    //[ file=isbst.html title=""
    public static boolean isBST(Node root, Node prev) {
        if( root != null) {
            if(!isBST(root.left, prev))
                return false;
            if(prev != null && prev.data >= root.data)
                return false;
            if(!isBST(root.right, root))
                return false;
        }
        return true;
    }
    //]

    //prev[0] = null
    public static boolean isBST2(Node root, Node[] prev) {
        if( root != null) {
            if(!isBST2(root.left, prev))
                return false;

            if(prev[0] != null && prev[0].data > root.data)
                return false;

            prev[0] = root;
            if(!isBST2(root.right, prev))
                return false;
        }
        return true;
    }
    
    //[ file=isbstdef.html title=""
    //
    // precondition node != null
    public static int max(Node node) {
        if(node.right != null)
            return max(node.right);
        else
            return node.data;
    }

    // precondition node != null
    public static int min(Node node) {
        if(node.left != null)
            return min(node.left);
        else
            return node.data;
    }

    // BST definition
    // 1) left subtree is BST
    // 2) right subtree is BST
    // 3) max(left substree) < parent.data && min(right subtree) > parent.data
    public static boolean isBSTDef(Node node) {
        if(node == null)
            return true;
        else {
            if(!isBSTDef(node.left))
                return false;

            if((node.left != null && max(node.left) >= node.data))
                return false;
            if(node.right != null && node.data >= min(node.right))
                return false;

            if(!isBSTDef(node.right))
                return false;
            
            return true;
        }
    }
    //]

}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class isBST 
{

	public static void main(String args[])
	{
		BST b1 = new BST();

		b1.Insert(10);
		//b1.Insert(5);
		//b1.Insert(15);
        
        inorder(b1.getRoot());
        /*
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
		b1.Insert(10);
        */

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        swap(5, 15, b1.getRoot(), first, second);
        
        inorder(b1.getRoot());
		
		System.out.println(isBSTDef(b1.getRoot()));
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
            }
            swap(m, n, root.right, first, second);
        }
    }

    //precondition node != null
    public static int max(Node node)
    {
        if(node.right != null)
            return max(node.right);
        else 
            return node.data;
    }

    //precondition node != null
    public static int min(Node node)
    {
        if(node.left != null)
            return min(node.left);
        else 
            return node.data;
    }

    //BST definition
    // 1) left subtree is BST
    // 2) right subtree is BST
    // 3) max(left substree) < parent.data && min(right subtree) > parent.data
    public static boolean isBSTDef(Node node)
    {
        if(node == null)
            return true;
        else
        {
            if(!isBSTDef(node.left))
                return false;
            if(!isBSTDef(node.right))
                return false;
            if( !((node.left == null || max(node.left) < node.data) &&
                    (node.right == null || min(node.right) > node.data)))
                return false;
            return true;
        }
    }
}
public class isPrime {
    public static void main(String[] args) {
        test1();
        test2();
    }
    public static void test1() {
        int n = 100;
        System.out.println("is Prime="+n+" ["+ prime(2, 100)+"]");
        n = 971;
        System.out.println("is Prime="+n + " [" + prime(2, 971)+"]");
        n = 11211117;
        System.out.println("is Prime="+n + " [" + prime(2, 11217)+"]");
        n = 11;
        System.out.println("is Prime="+n + " [" + prime(2, 11)+"]");
    }

    public static void test2() {
        System.out.println("test2()");
        System.out.println("p = 2 [" + isPrimeLoop(2) + "]");
        System.out.println("p = 11[" + isPrimeLoop(11) + "]");
        System.out.println("p = 20[" + isPrimeLoop(20) + "]");
        System.out.println("p = 30[" + isPrimeLoop(30) + "]");
        System.out.println("p = 121[" + isPrimeLoop(121) + "]");
        System.out.println("p = 122[" + isPrimeLoop(122) + "]");
        System.out.println("p = 123[" + isPrimeLoop(123) + "]");
        System.out.println("p = 124[" + isPrimeLoop(124) + "]");
        System.out.println("p = 127[" + isPrimeLoop(127) + "]");
    }

    //[file=checkprime.html title=""
    public static boolean prime(int d, int n) {
        if(n == 2)
            return true;
        else if(n % d == 0)
            return false;
        else if(d*d <= n)
            return prime(d+1, n);
        else
            return true;
    }
    public static boolean isPrimeLoop(int n) {
        if( n == 2)
            return true;
        for(int d=2; d*d <= n; d++) {
            if(n % d == 0)
                return false;
        }
        return true;
    }
    //]
}
import java.util.*;

class Point{
    int x;
    int y;
    int z;
    public Point(int x, int y, int z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}

public class landscape 
{
	public static void main(String[] args)
    {
        test_question1();
        test0_question21();
        test_question21();
        test_question22();
        test0_question3();
        test1_question3();
        test2_question3();
        test3_question3();
        test4_question3();
    }
    
    static void test_question1()
    {
        System.out.println("===================================================");
        System.out.println("Question(1) Find all the lakes in the landscape");
        System.out.println("test_question1()");
        int w = 10;
        int[][] F = {
            {0, 1},
            {1, 0}
        };
        System.out.println("w="+w);
        printArray2D(F);
        int col=0, row=0;
        List<List<Point>> listList = new ArrayList<List<Point>>(); 
        int count = countLake(F, listList, w);
        printListList(listList);
        System.out.println("Numbers of lake = "+listList.size());
        System.out.println();
    }

    static void test0_question21()
    {
        System.out.println("===================================================");
        System.out.println("Question(2.1) Find the lake with largest surface area");
        System.out.println("test0_question21()");
        final int w=0;
        int[][] G = {   {2, 9, 1, 4},
                        {9, 9, 9, 9},
                        {9, 1, 0, 5},
                        {8, 3, 2, 4}
                    };

        System.out.println("w="+w);
        printArray2D(G);
        //Threshold
        int max = maxArea(G, w);
        System.out.println("Max area=["+max+"]");
        System.out.println();
    }

    static void test_question21()
    {
        System.out.println("===================================================");
        System.out.println("Question(2.1) Find the lake with largest surface area");
        System.out.println("test_question21()");
        final int w=5;
        int[][] G = {   {2, 9, 1, 4},
                        {9, 9, 9, 9},
                        {9, 1, 0, 5},
                        {8, 3, 2, 4}
                    };

        System.out.println("w="+w);
        printArray2D(G);
        //Threshold
        int max = maxArea(G, w);
        System.out.println("Max area=["+max+"]");
        System.out.println();
    }

	static void printListList(List<List<Point>> listList)
    {
        System.out.println("lake:(x, y, z)");
        int count = 1;
        for(List<Point> list:listList)
        {
            System.out.print("lake:"+count+"=");
            for(Point t:list)
            {
                System.out.print("("+t.x+" "+" "+t.y+" "+t.z+")");
            }
            count++;
            System.out.println();
        }
    }

    static void test_question22()
    {
        System.out.println("===================================================");
        System.out.println("test_question22");
        System.out.println("Questions(2.2) find the lake with largest volumn of water");
        //Threshold
        final int w=5;
        System.out.println("w="+w+"");

        int[][] G = {   {2, 9, 1, 4},
                        {9, 9, 9, 9},
                        {9, 1, 9, 5},
                        {4, 3, 9, 4}
                    };
        printArray2D(G);
        
        int max = maxVolumn(G, w);
        System.out.println("Max volumn=["+max+"]");
    }

    //Count the numbers of point(each lake) in the landscape
	static int landscapeLake(int[][] land, int x, int y, List<Point> lake, int w)
	{
		if(land != null && land[0] != null)
		{
            if(land[x][y] >= 0 && land[x][y] < w)
            {
                int up=0, down=0, right=0, left=0;
                if(lake != null)
                    lake.add(new Point(x, y, land[x][y]));

                land[x][y] = -1;

                if(x+1 < land.length)
                    up = landscapeLake(land, x+1, y, lake, w);	
                if(x-1 >= 0)
                    down = landscapeLake(land, x-1, y, lake, w);	
                if(y+1 < land.length)
                    right = landscapeLake(land, x, y+1, lake, w);	
                if(y-1 >= 0)
                    left = landscapeLake(land, x, y-1, lake, w);	

                return right + left + down + up + 1;
            }
		}
        return 0;
	}

    //Calculate the maximum area of a lake
    static int maxArea(int[][] land, int w)
    {
        int max=0;
        if(land != null && land[0] != null)
        {
            for(int i=0; i<land.length; i++)   
            {
                for(int j=0; j<land[0].length; j++)
                {
                    if(land[i][j] < w)
                    {
                        int a = area(land, i, j, w);
                        if(a > max) 
                            max = a;
                    }
                }
            }
        }
        return max;
    }

    //Calculate the maximum volumn of a lake
    static int maxVolumn(int[][] land, int w)
    {
        int max=0;
        if(land != null && land[0] != null)
        {
            for(int i=0; i<land.length; i++)   
            {
                for(int j=0; j<land[0].length; j++)
                {
                    if(land[i][j] < w)
                    {
                        int v = volumn(land, i, j, w);
                        if(v > max) 
                            max = v;
                    }
                }
            }
        }
        return max;
    }

    //Calculate the volumn of a lake
    static int volumn(int[][] land, int x, int y, int w)
	{
		if(land != null && land[0] != null)
		{
            if(land[x][y] >= 0 && land[x][y] < w)
            {
                int wl = land[x][y];
                land[x][y] = -1;
                int up=0, down=0, right=0, left=0;
                if(x+1 < land.length)
                    up = volumn(land, x+1, y, w);	
                if(x-1 >= 0)
                    down = volumn(land, x-1, y, w);	
                if(y+1 < land[0].length)
                    right = volumn(land, x, y+1, w);	
                if(y-1 >= 0)
                    left = volumn(land, x, y-1, w);	

                return right + left + down + up + wl;
            }
		}
        return 0;
	}

    //Calculate the area of a lake
    static int area(int[][] land, int x, int y,  int w)
	{
		if(land != null && land[0] != null)
		{
            if(land[x][y] >= 0 && land[x][y] < w)
            {
                land[x][y] = -1;
                int up=0, down=0, right=0, left=0;
                if(x+1 < land.length)
                    up = area(land, x+1, y, w);	
                if(x-1 >= 0)
                    down = area(land, x-1, y, w);	
                if(y+1 < land[0].length)
                    right = area(land, x, y+1, w);	
                if(y-1 >= 0)
                    left = area(land, x, y-1, w);	

                return right + left + down + up + 1;
            }
		}
        return 0;
	}

    static void test0_question3()
    {
        System.out.println("===================================================");
        System.out.println("test0_question3()");
        System.out.println("The shortest motorable path between points A and B");
        int G = 10;
        int x = 0;
        int y = 0;
        int bx = 0;
        int by = 1;
        System.out.println("The threshold of gradient G="+G);
        System.out.println("A=("+x+","+y+")  B=("+bx+","+by+")");

        int[][] A = {{3}
                    };
        
        printArray2D(A);

        int prev_x = -1;
        int prev_y = -1;
        
        int[][] path = new int[50][3];    
        List<Point> shortestPath= new ArrayList<Point>();   
        int[] min = {Integer.MAX_VALUE};
        int depth = 0;
        motorable(A, x, y, prev_x, prev_y, bx, by, G, path, shortestPath, depth, min);

        System.out.println();
        System.out.println("The shortest path: point[x, y z]");
        for(Point t: shortestPath)
            System.out.print("["+t.x+","+t.y+","+t.z+"]");
        System.out.println();
    }

    static void test1_question3()
    {
        System.out.println("===================================================");
        System.out.println("test1_question3()");
        System.out.println("The shortest motorable path between points A and B");
        int G = 10;
        int x = 0;
        int y = 0;
        int bx = 0;
        int by = 1;
        System.out.println("The threshold of gradient G="+G);
        System.out.println("A=("+x+","+y+")  B=("+bx+","+by+")");

        int[][] A = {{3, 5}
                    };
        
        printArray2D(A);

        int prev_x = -1;
        int prev_y = -1;
        
        int[][] path = new int[50][3];    
        List<Point> shortestPath= new ArrayList<Point>();   
        int[] min = {Integer.MAX_VALUE};
        int depth = 0;
        motorable(A, x, y, prev_x, prev_y, bx, by, G, path, shortestPath, depth, min);

        System.out.println();
        System.out.println("The shortest path: point[x, y z]");
        for(Point t: shortestPath)
            System.out.print("["+t.x+","+t.y+","+t.z+"]");
        System.out.println();
    }
    static void test2_question3()
    {
        System.out.println("===================================================");
        System.out.println("test2_question3()");
        System.out.println("The shortest motorable path between points A and B");
        int G = 10;
        int x = 0;
        int y = 0;
        int bx = 1;
        int by = 1;
        System.out.println("The threshold of gradient G="+G);
        System.out.println("A=("+x+","+y+")  B=("+bx+","+by+")");
        int[][] A = {   {3, 5, 4},
                        {7, 1, 3},
                        {6, 2, 1}
                    };
        printArray2D(A);

        int prev_x = -1;
        int prev_y = -1;
        
        int[][] path = new int[50][3];    
        List<Point> shortestPath= new ArrayList<Point>();   
        int[] min = {Integer.MAX_VALUE};
        int depth = 0;
        motorable(A, x, y, prev_x, prev_y, bx, by, G, path, shortestPath, depth, min);

        System.out.println();
        System.out.println("The shortest path: point[x, y, z]");
        System.out.print("path:");
        for(Point t: shortestPath)
            System.out.print("["+t.x+","+t.y+","+t.z+"]");
        System.out.println();

    }

    static void test3_question3()
    {
        System.out.println("===================================================");
        System.out.println("test3_question3()");
        System.out.println("The shortest motorable path between points A and B");
        int G = 5;
        int x = 0;
        int y = 0;
        int bx = 2;
        int by = 2;
        System.out.println("The threshold of gradient G="+G);
        System.out.println("A=("+x+","+y+")  B=("+bx+","+by+")");

        int[][] A = {   {3, 5, 1, 3},
                        {7, 1, 4, 1},
                        {4, 1, 2, 1},
                        {3, 2, 4, 2}
                    };

        printArray2D(A);

        int prev_x = -1;
        int prev_y = -1;
        
        int[][] path = new int[50][3];    
        List<Point> shortestPath= new ArrayList<Point>();   
        int[] min = {Integer.MAX_VALUE};
        int depth = 0;
        motorable(A, x, y, prev_x, prev_y, bx, by, G, path, shortestPath, depth, min);

        System.out.println();
        System.out.println("The shortest path: point[x, y z]");
        System.out.print("path:");
        for(Point t: shortestPath)
            System.out.print("["+t.x+","+t.y+","+t.z+"]");
        System.out.println();

    }

    static void test4_question3()
    {
        System.out.println("===================================================");
        System.out.println("test4_question3()");
        System.out.println("The shortest motorable path between points A and B");
        int G = 5;
        int x = 0;
        int y = 0;
        int bx = 10;
        int by = 10;
        System.out.println("The threshold of gradient G="+G);
        System.out.println("A=("+x+","+y+")  B=("+bx+","+by+")");

        int[][] A = {   {3, 5, 1, 3},
                        {7, 1, 4, 1},
                        {4, 1, 2, 1},
                        {3, 2, 4, 2}
                    };

        printArray2D(A);

        int prev_x = -1;
        int prev_y = -1;
        
        int[][] path = new int[50][3];    
        List<Point> shortestPath= new ArrayList<Point>();   
        int[] min = {Integer.MAX_VALUE};
        int depth = 0;
        motorable(A, x, y, prev_x, prev_y, bx, by, G, path, shortestPath, depth, min);

        System.out.println();
        System.out.println("The shortest path: point[x, y z]");
        System.out.print("path:");
        for(Point t: shortestPath)
            System.out.print("["+t.x+","+t.y+","+t.z+"]");
        System.out.println();

    }

    // Initialize: prev_x = -1, prev_y = -1
    // G is the threshold of gradient 
    // land[prev_x][prev_y] is the z value of  previous point
    // land[x][y] is the z value of current point
    // A=(x, y) B=(bx, by)
    // depth is the numbers of points in a path
    // min is the minimum of gradients for all the paths
    static void motorable(int[][] land, int x, int y, 
                        int prev_x, int prev_y, 
                        int bx, int by, int G, int[][] path, List<Point> shortestPath,int depth, int[] min)
	{
		if(land != null)
		{
            if(prev_x >= 0 && prev_y >= 0)
            {
                int gradient = Math.abs(land[x][y] - land[prev_x][prev_y]);
                if(gradient < G)
                {
                    if(x == bx && y == by)
                    {
                        path[depth][0] = x;
                        path[depth][1] = y;
                        path[depth][2] = land[x][y];

                        System.out.print("path:");
                        for(int i=0; i<=depth; i++)
                            System.out.print("["+path[i][0]+","+path[i][1]+","+path[i][2]+"]");
                        System.out.println();

                        int s=0;
                        for(int i=1; i<=depth; i++)
                           s += Math.abs(path[i-1][2] - path[i][2]); 

                        if(s < min[0])
                        {
                            min[0] = s;
                            shortestPath.clear();
                            for(int i=0; i<=depth; i++)
                            {
                                shortestPath.add(new Point(path[i][0], path[i][1], path[i][2]));
                            }
                        }
                    }
                    else
                    {
                        if(y+1 < land[0].length)
                        {
                            path[depth][0] = x;
                            path[depth][1] = y;
                            path[depth][2] = land[x][y];
                            motorable(land, x, y+1, x, y, bx, by, G, path, shortestPath, depth+1, min);
                        }
                        if(x+1 < land.length)
                        {
                            path[depth][0] = x;
                            path[depth][1] = y;
                            path[depth][2] = land[x][y];
                            motorable(land, x+1, y, x, y, bx, by, G, path, shortestPath, depth+1, min);
                        }
                    }
                }
            }
            else
            {
                if(y+1 < land[0].length)
                {
                    path[depth][0] = x;
                    path[depth][1] = y;
                    path[depth][2] = land[x][y];
                    motorable(land, x, y+1, x, y, bx, by, G, path, shortestPath, depth+1, min);
                }
                if(x+1 < land.length)
                {
                    path[depth][0] = x;
                    path[depth][1] = y;
                    path[depth][2] = land[x][y];
                    motorable(land, x+1, y, x, y, bx, by, G, path, shortestPath, depth+1, min);
                }
            }
		}
	}

    static int countLake(int[][] land, List<List<Point>> listList, int w)
	{
        int s=0;
        if(land != null)
        {
            for(int i=0; i<land.length; i++)   
            {
                for(int j=0; j<land.length; j++)
                {
                    if(land[i][j] >= 0 && land[i][j] < w)
                    {
                        List<Point> listPoint = new ArrayList<Point>();
                        landscapeLake(land, i, j, listPoint, w);
                        listList.add(listPoint);
                        s += 1;
                    }
                }
            }
        }
        return s;
	}

    public static void printArray2D(int[][] arr)
    {
        if(arr != null)
        {
            for(int c=0; c<arr.length; c++)
            {
                for(int r=0; r<arr[0].length; r++)
                {
                    System.out.print("["+arr[c][r]+"]");
                }
                System.out.println();
            }
        }
        System.out.println();
    }
}
import java.util.*;

class Triple{
    int x;
    int y;
    int z;
    public Triple(int x, int y, int z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}

public class landscape 
{
	public static void main(String[] args)
    {
	    test0();
	    test1();
	    test2();
	    test3();
	    test4();
	    test5_maxArea();
	    test6_maxVolumn();
        test1_motorable();
        
        test2_motorable();
        /*
        test3_motorable();
        */
    }
    static void test0()
    {
        System.out.println("test1()");

        int[][] E = {{11}};
        int col=0, row=0;
        List<List<Triple>> listList = new ArrayList<List<Triple>>(); 
        int w = 10;
        int count = countComponent(E, listList, w);
        System.out.println("count=["+count+"]");
    }
    static void test1()
    {
        System.out.println("test1()");

        int[][] E = {
            {11, 0},
            {0, 11}
        };
        int col=0, row=0;
        List<List<Triple>> listList = new ArrayList<List<Triple>>(); 
        int w = 10;
        int count = countComponent(E, listList, w);
        System.out.println("count=["+count+"]");
    }

    static void test2()
    {
        System.out.println("test2()");
         int[][] F = {
            {0, 1},
            {1, 0}
        };
        int col=0, row=0;
        int w = 10;
        List<List<Triple>> listList = new ArrayList<List<Triple>>(); 
        int count = countComponent(F, listList, w);
        System.out.println("count=["+count+"]");
        printListList(listList);
    }

    static void test3()
    {
        System.out.println("test3()");
        int[][] H = {   {1, 1, 6, 1},
                        {1, 1, 4, 9},
                        {4, 3, 1, 1},
                        {0, 7, 1, 1}
                    };
        int col=0, row=0;
        int w = 2;
        List<List<Triple>> listList = new ArrayList<List<Triple>>(); 
        int count = countComponent(H, listList, w);
        System.out.println("count=["+count+"]");
        printListList(listList);
    }

	static void printListList(List<List<Triple>> listList)
    {
        System.out.println("lake:(x, y, z)");
        int count = 1;
        for(List<Triple> list:listList)
        {
            System.out.print("lake:"+count+"=");
            for(Triple t:list)
            {
                System.out.print("("+t.x+" "+" "+t.y+" "+t.z+")");
            }
            count++;
            System.out.println();
        }
    }
	static void test4()
    {
        System.out.println("test4()");
        int[][] G = {   {0, 1, 1, 0},
                        {9, 3, 6, 9},
                        {2, 8, 0, 1},
                        {0, 0, 0, 0}
                    };
        int col=0, row=0;
        int w = 4;
        List<List<Triple>> listList = new ArrayList<List<Triple>>(); 
        int count = countComponent(G, listList, w);
        System.out.println("count=["+count+"]");
    }
			
	static void test5_maxArea()
    {
        System.out.println("test5_maxArea()");
        int[][] G = {   {2, 9, 1, 4},
                        {9, 9, 9, 9},
                        {9, 1, 0, 5},
                        {8, 3, 2, 4}
                    };

        //Threshold
        final int w=5;

        int max = maxArea(G, w);
        System.out.println("max=["+max+"]");

    }

    static void test6_maxVolumn()
    {
        System.out.println("test6_maxVolumn()");
        int[][] G = {   {2, 9, 1, 4},
                        {9, 9, 9, 9},
                        {9, 1, 9, 5},
                        {4, 3, 9, 4}
                    };

        //Threshold
        final int w=5;

        int max = maxVolumn(G, w);
        System.out.println("max=["+max+"]");

    }

	static int component(int[][] A, int x, int y, List<Triple> lake, int w)
	{
		if(A != null && A[0] != null)
		{
            if(A[x][y] >= 0 && A[x][y] < w)
            {
                int up=0, down=0, right=0, left=0;
                if(lake != null)
                    lake.add(new Triple(x, y, A[x][y]));

                A[x][y] = -1;

                if(x+1 < A.length)
                    up = component(A, x+1, y, lake, w);	
                if(x-1 >= 0)
                    down = component(A, x-1, y, lake, w);	
                if(y+1 < A.length)
                    right = component(A, x, y+1, lake, w);	
                if(y-1 >= 0)
                    left = component(A, x, y-1, lake, w);	

                return right + left + down + up + 1;
            }
		}
        return 0;
	}

    static void test1_area()
    {
        final int w=5;
        System.out.println("test1_area()");
        int[][] G = {   {2, 1, 1, 3},
                        {1, 1, 0, 1},
                        {4, 1, 0, 1},
                        {3, 2, 4, 2}
                    };
        int max = maxArea(G, w);
        System.out.println("max area=["+max+"]");

    }
    static int maxArea(int[][] A, int w)
    {
        int max=0;
        if(A != null && A[0] != null)
        {
            for(int i=0; i<A.length; i++)   
            {
                for(int j=0; j<A[0].length; j++)
                {
                    if(A[i][j] < w)
                    {
                        int a = area(A, i, j, w);
                        if(a > max) 
                            max = a;
                    }
                }
            }
        }
        return max;
    }

    static int maxVolumn(int[][] A, int w)
    {
        int max=0;
        if(A != null && A[0] != null)
        {
            for(int i=0; i<A.length; i++)   
            {
                for(int j=0; j<A[0].length; j++)
                {
                    if(A[i][j] < w)
                    {
                        int v = volumn(A, i, j, w);
                        if(v > max) 
                            max = v;
                    }
                }
            }
        }
        return max;
    }

    //Calculate the volumn of lake
    static int volumn(int[][] A, int x, int y, int w)
	{
		if(A != null && A[0] != null)
		{
            if(A[x][y] >= 0 && A[x][y] < w)
            {
                int wl = A[x][y];
                A[x][y] = -1;
                int up=0, down=0, right=0, left=0;
                if(x+1 < A.length)
                    up = volumn(A, x+1, y, w);	
                if(x-1 >= 0)
                    down = volumn(A, x-1, y, w);	
                if(y+1 < A[0].length)
                    right = volumn(A, x, y+1, w);	
                if(y-1 >= 0)
                    left = volumn(A, x, y-1, w);	

                return right + left + down + up + wl;
            }
		}
        return 0;
	}

    //Calculate the area of lake
    static int area(int[][] A, int x, int y,  int w)
	{
		if(A != null && A[0] != null)
		{
            if(A[x][y] >= 0 && A[x][y] < w)
            {
                A[x][y] = -1;
                int up=0, down=0, right=0, left=0;
                if(x+1 < A.length)
                    up = area(A, x+1, y, w);	
                if(x-1 >= 0)
                    down = area(A, x-1, y, w);	
                if(y+1 < A[0].length)
                    right = area(A, x, y+1, w);	
                if(y-1 >= 0)
                    left = area(A, x, y-1, w);	

                return right + left + down + up + 1;
            }
		}
        return 0;
	}

    static void test3_motorable()
    {
        System.out.println("test3_motorable()");
        int[][] A = {{3, 5}
                    };
        
        int prev_x = -1;
        int prev_y = -1;
        int x = 0;
        int y = 0;
        int bx = 0;
        int by = 1;
        int G = 10;
        int[][] path = new int[50][3];    
        List<Triple> shortestPath= new ArrayList<Triple>();   
        int[] min = {Integer.MAX_VALUE};
        int depth = 0;
        int minGradient = motorable(A, x, y, prev_x, prev_y, bx, by, G, path, shortestPath, depth, min);
        System.out.println("minGradient=["+minGradient+"]");
        for(Triple t: shortestPath)
        {
            System.out.print("["+t.x+","+t.y+","+t.z+"]");
        }
        System.out.println();
    }
    static void test2_motorable()
    {
        System.out.println("test2_motorable()");
        int[][] A = {   {3, 5, 4},
                        {7, 1, 3},
                        {6, 2, 1}
                    };
        
        int prev_x = -1;
        int prev_y = -1;
        int x = 0;
        int y = 0;
        int bx = 1;
        int by = 1;
        int G = 10;
        int[][] path = new int[50][3];    
        List<Triple> shortestPath= new ArrayList<Triple>();   
        int[] min = {Integer.MAX_VALUE};
        int depth = 0;
        int minGradient = motorable(A, x, y, prev_x, prev_y, bx, by, G, path, shortestPath, depth, min);

        System.out.println("minGradient=["+minGradient+"]");
        for(Triple t: shortestPath)
        {
            System.out.print("["+t.x+","+t.y+","+t.z+"]");
        }
        System.out.println();

    }
    static void test1_motorable()
    {
        System.out.println("test1_motorable()");
        int[][] A = {   {3, 5, 1, 3},
                        {7, 1, 4, 1},
                        {4, 1, 2, 1},
                        {3, 2, 4, 2}
                    };
        
        int prev_x = -1;
        int prev_y = -1;
        int x = 0;
        int y = 0;
        int bx = 1;
        int by = 1;
        int G = 5;
        int[][] path = new int[50][3];    
        List<Triple> shortestPath= new ArrayList<Triple>();   
        int[] min = {Integer.MAX_VALUE};
        int depth = 0;
        int minGradient = motorable(A, x, y, prev_x, prev_y, bx, by, G, path, shortestPath, depth, min);
        System.out.println("minGradient=["+minGradient+"]");
        for(Triple t: shortestPath)
        {
            System.out.print("["+t.x+","+t.y+","+t.z+"]");
        }
        System.out.println();
    }

    // Initialize: prev_x = -1, prev_y = -1
    // G is the threshold of gradient 
    // A[prev_x][prev_y] is the z value of  previous point
    // A[x][y] is the z value of current point
    static int motorable(int[][] A, int x, int y, 
                        int prev_x, int prev_y, 
                        int bx, int by, int G, int[][] path, List<Triple> shortestPath,int depth, int[] min)
	{
		if(A != null)
		{
            int gradient = 0;
            if(prev_x >= 0 && prev_y >= 0)
            {
                gradient = Math.abs(A[x][y] - A[prev_x][prev_y]);
                if(gradient < G)
                {
                    if(x == bx && y == by)
                    {
                        path[depth][0] = x;
                        path[depth][1] = y;
                        path[depth][2] = A[x][y];

                        for(int i=0; i<=depth; i++)
                            System.out.print("["+path[i][0]+","+path[i][1]+","+path[i][2]+"]");

                        int s=0;
                        for(int i=1; i<=depth; i++)
                           s += Math.abs(path[i-1][2] - path[i][2]); 

                        if(s < min[0])
                        {
                            min[0] = s;
                            shortestPath.clear();
                            for(int i=0; i<=depth; i++)
                            {
                                shortestPath.add(new Triple(path[i][0], path[i][1], path[i][2]));
                            }
                        }
                        System.out.println();
                        return gradient;
                    }
                    else
                    {
                        int down=Integer.MAX_VALUE, right=Integer.MAX_VALUE;
                        if(y+1 < A[0].length)
                        {
                            path[depth][0] = x;
                            path[depth][1] = y;
                            path[depth][2] = A[x][y];
                            right = motorable(A, x, y+1, x, y, bx, by, G, path, shortestPath, depth+1, min) + gradient;
                        }
                        if(x+1 < A.length)
                        {
                            path[depth][0] = x;
                            path[depth][1] = y;
                            path[depth][2] = A[x][y];
                            down = motorable(A, x+1, y, x, y, bx, by, G, path, shortestPath, depth+1, min) + gradient;
                        }
                        return Math.min(right, down);
                    }
                }
            }
            else
            {
                int down=Integer.MAX_VALUE, right=Integer.MAX_VALUE;
                if(y+1 < A[0].length)
                {
                    path[depth][0] = x;
                    path[depth][1] = y;
                    path[depth][2] = A[x][y];
                    right = motorable(A, x, y+1, x, y, bx, by, G, path, shortestPath, depth+1, min) + gradient;
                }
                if(x+1 < A.length)
                {
                    path[depth][0] = x;
                    path[depth][1] = y;
                    path[depth][2] = A[x][y];
                    down = motorable(A, x+1, y, x, y, bx, by, G, path, shortestPath, depth+1, min) + gradient;
                }
                return Math.min(right, down);
            }
		}
        return 0;
	}

    static int countComponent(int[][] A, List<List<Triple>> listList, int w)
	{
        int s=0;
        if(A != null)
        {
            for(int i=0; i<A.length; i++)   
            {
                for(int j=0; j<A.length; j++)
                {
                    if(A[i][j] >= 0 && A[i][j] < w)
                    {
                        List<Triple> lake = new ArrayList<Triple>();
                        component(A, i, j, lake, w);
                        listList.add(lake);
                        s += 1;
                    }
                }
            }
        }
        return s;
	}
}
import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;

// nest list 
public class listList
{
    public static void main(String[] args)
    {
        System.out.println("nest List list of list");
        List<List<String>> listlist = new ArrayList<List<String>>();

        for(int i=0; i<3; i++)
        {
            List<String> list = new ArrayList<String>();
            for(int j=0; j<4; j++)
            {
                list.add("["+j+"]"); 
            }
            listlist.add(list);
        }

        for(List<String> strList : listlist)
        {
            int indexlist = listlist.indexOf(strList);
            System.out.println("indexlist=" + indexlist);
            for(String str: strList)
            {
                int index = strList.indexOf(str);
                System.out.println("index="+index);
            }
            System.out.println("");
        }
    }
}
public class longestComponent {
    //[file=longestcomponent.html title=""
    static int component(int[][] A, int x, int y) {
        if(A != null && A[0] != null && 0 <= x && x < A.length && 0 <= y &&
                y < A[0].length && A[x][y] == 1) {
            A[x][y] = 2;
            int up    = component(A,   x+1,   y   ); 
            int down  = component(A,   x-1,   y   ); 
            int right = component(A,   x,     y+1 ); 
            int left  = component(A,   x,     y-1 ); 
            return right + left + down + up + 1;
        }
        return 0;
    }
    static int  longest(int[][] A) {
        int max = 0;
        if(A != null) {
            for(int i=0; i<A.length; i++)   {
                for(int j=0; j<A[0].length; j++) {
                    int count = component(A, i, j);
                    if(count > max)
                        max = count;
                }
            }
        }
        return max;
    }
    //]

    static void test0() {
        System.out.println("---------------------------------\n");
        int[][] A = null;
        int count = longest(A);
        System.out.println("longest="+count);
        System.out.println("---------------------------------\n");
    }
    static void test1() {
        System.out.println("---------------------------------\n");
        int[][] B = {};
        int count = longest(B);
        System.out.println("longest="+count);
        System.out.println("---------------------------------\n");
    }
    static void test2() {
        System.out.println("---------------------------------\n");
        int[][] C = {{0}};
        int count = longest(C);
        System.out.println("longest="+count);
        System.out.println("---------------------------------\n");
    }

    static void test3() {
        System.out.println("---------------------------------\n");
        int[][] D = {{1}};
        int count = longest(D);
        System.out.println("longest="+count);
        System.out.println("---------------------------------\n");
    }
    static void test4() {
        System.out.println("---------------------------------\n");
        int[][] E = {
            {0, 0},
            {0, 0}
        };
        int count = longest(E);
        System.out.println("longest="+count);

        System.out.println("---------------------------------\n");
    }
    static void test5() {
        System.out.println("---------------------------------\n");
        int[][] F = {
            {1, 0},
            {1, 1}
        };
        int count = longest(F);
        System.out.println("longest="+count);
        System.out.println("---------------------------------\n");
    }

    static void test6() {
        System.out.println("---------------------------------\n");
        int[][] H = {   {0, 1, 1, 1},
            {0, 1, 0, 1},
            {1, 0, 0, 1},
            {0, 1, 1, 0}
        };
        int count = longest(H);
        System.out.println("longest="+count);
        System.out.println("---------------------------------\n");
    }

    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
}
public class longestPalindromGood{

    public static void main(String[] args) {
        mytest_1();
        mytest_2();
        mytest_3();
        mytest_4();
        mytest_5();
        mytest_6();
        mytest_7();
    }

    public static void mytest_1(){
        longestPalindrome("a");
    }

    public static void mytest_2(){
        longestPalindrome("aa");
    }

    public static void mytest_3(){
        longestPalindrome("ab");
    }

    public static void mytest_4(){
        longestPalindrome("aba");
    }

    public static void mytest_5(){
        longestPalindrome("abba");
    }

    public static void mytest_6(){
        longestPalindrome("abbaab");
    }

    public static void mytest_7(){
        longestPalindrome("abbaabcc");
    }

    public static void longestPalindrome(String str){
        String newStr = addChar(str);
        int len = newStr.length();

        int[] p = new int[newStr.length()];

            int maxlen = 0;
            int center = 0;
            for (int i = 0; i < len; i++) {

                int lReflection = 2 * center - i;
                int left = center - maxlen;
                int right = center + maxlen;
                if (center - maxlen < lReflection && lReflection < center) {
                    // contain the
                    if (left < lReflection - p[lReflection] && lReflection + p[lReflection] < center) {
                        p[i] = p[lReflection];
                    } else {
                        int dist = right - i < i - left ? right - i : i - left;
                        while (i - dist >= 0 && i + dist <= len - 1 && newStr.charAt(i + dist) == newStr.charAt(i - dist)) {
                            if (dist >= maxlen) {
                                maxlen = dist;
                                p[i] = dist;
                                center = i;
                            }
                            p[i] = dist;
                            dist++;
                        }
                    }
                } else {
                    int k = 1;
                    while (i + k <= len - 1 && i - k >= 0 && newStr.charAt(i - k) == newStr.charAt(i + k)) {
                        p[i] = k;
                        if (k >= maxlen) {
                            maxlen = k;
                            center = i;
                        }
                        k++;
                    }
                }
            }

        for (int i = 0; i < len; i++) {
            System.out.println("p[" + i + "]=" + p[i] + "=[" + newStr.charAt(i) + "]");
        }
        System.out.println("");
    }

    public static String addChar(String str){
        String newStr = "";
        if(str != null) {
            int len = str.length();
            for (int i = 0; i < len; i++) {
                if (i < len - 1)
                    newStr += str.charAt(i) + "#";
                else
                    newStr += str.charAt(i);
            }
            System.out.println(newStr);
        }
        return newStr;
    }
}
import java.io.*;
import java.lang.*;
import java.util.*;
class matchparenthesis 
{
	public static void main(String args[])
	{
			System.out.println(valid("([()]{})"));
	}
		
	public static boolean match(String lv, String rv)
	{
		boolean ret = false;
		if( lv.equals("(") && rv.equals(")"))
			ret = true;
		else if( lv.equals("[") && rv.equals("]"))
			ret = true;
		else if( lv.equals("{") && rv.equals("}"))
			ret = true;
		return ret;
	}

	public static boolean valid(String str)
	{
		Stack<String> st = null;
		boolean ret = true;
		if( str != null)
		{ st = new Stack<String>();
			for(int i=0; i<str.length() && ret; i++)
			{
				String ch = Character.toString(str.charAt(i));
				System.out.println("ch="+ch);
				if(ch.equals("(") || ch.equals("[") || ch.equals("{"))
					st.push(ch);
				else
				{ String p = st.pop();
					if(!match(p, ch))
						ret = false;
				}
			}
		}
		if(!st.empty())
			ret = false;
		return ret;
	}
}

import java.io.*;
import java.lang.String;
import java.lang.Math;
import java.util.*;
class mergesort 
{
	public static void main(String args[])
	{
		//int[] Arr = {0, 3, 7, 2, 100, 9, 6};
		int[] Arr = {4};
		int left=0;
		int right=Arr.length-1;
		int mid=(left+right)/2;
		mergesort(Arr, left, right);

		for(int i=0; i<Arr.length; i++)
		{ 
			System.out.println("Arr[" + i + "]=" + Arr[i]);
		}
	}
	public static void mergesort(int[] Arr, int left, int right)
	{
		if(left < right)
		{
			int mid = (left + right)/2;
			mergesort(Arr, left, mid);
			mergesort(Arr, mid+1, right);
			merge(Arr, left, mid, right);
		}
	}
	public static void merge(int[] Arr, int left, int mid, int right)
	{
		if(Arr != null && Arr.length > 1)
		{
			int len = right - left + 1;
			int[] A = new int[len];

			int i=left;
			int j=mid+1;
			int k=0;
			while(i<=mid && j<=right)
			{
				if(Arr[i] < Arr[j])
				{ A[k]=Arr[i]; i++;}
				else 
				{ A[k]=Arr[j]; j++;}
				k++;
			}
			while(i<=mid)
			{	A[k]=Arr[i];i++;k++;}
			while(j<=right)
			{ A[k]=Arr[j];j++;k++;}

			for(int x=0; x<right-left+1; x++)
			{ Arr[left+x]=A[x]; }
		}
	}
	
}
import java.io.*;
import java.lang.String;
import java.util.*;
class minValueShiftArray 
{
	public static void main(String args[])
	{
		int[] Arr={3, 4, 5, 1, 2};
		int left = 0, right = Arr.length-1;
		int ret = Min(Arr, left, right);
		System.out.println("ret=" + ret);
	}
	public static int Min(int[] Arr, int left, int right)
	{
		int ret=0;
		if( Arr != null)
		{
			if( left == right) //only one element
				ret = Arr[left];
			else if( left+1 == right) // base case: two elements
				ret = (Arr[left]<Arr[right]?Arr[left]:Arr[right]);
			else if( Arr[left] < Arr[right]) // did not shift any position
				ret = Arr[left];
			else  //recursive case
			{
				int mid = (left + right)/2;
				if( Arr[left] > Arr[mid])
					ret = Min(Arr, left, mid);
				else 
					ret = Min(Arr, mid, right);
			}
		}
		else
		{
			System.exit(0);
		}
		return ret;
	}
}
public class mul 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
}
import java.io.*;
class multipleTable 
{
	public static void main(String args[])
	{
		multiple(10);
	}
	public static void multiple(int num)
	{
		for(int i=1; i<num; i++)
		{
			for(int j=1; j<num; j++)
			{
				System.out.print(String.format("%4d", i*j));
			}
			System.out.println();
		}
	}
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// multiply number
public class multtry{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        int [] arr1 = {9, 9};
        int [] arr2 = {2};
        int[] arr = mult(arr1, arr2);
        Aron.printArray(arr);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        int [] arr1 = {9, 9};
        int [] arr2 = {9};
        int[] arr = mult(arr1, arr2);
        Aron.printArray(arr);
        Aron.end();
    }
    public static int[] mult(int[] arr1, int[] arr2){
        int[] array = null;
        if(arr1 != null && arr2 != null){
            int len1 = arr1.length;
            int len2 = arr2.length;
            int len = len1 + len2;
            int[][] arr = new int[len1][len];
            for(int i = len1-1; i>= 0 ; i--){
                int c = 0;
                int j=0;
                for(j=len2-1; j>=0; j--){
                    int s = arr1[i]*arr2[j];
                        arr[i][i+j+1] = (s + c) % 10;
                        c = (s + c) / 10;
                }
                arr[i][i+j+1] = c;
            }

            array = new int[len];
            int c = 0;
            for(int i=len-1; i >=0; i--){

                int s = 0;
                for(int j=0; j<len1; j++){
                    s += arr[j][i];
                }
                array[i] = (s + c) % 10;
                c = (s + c) / 10;
            }
        }
        return array;
    }
} 

import java.io.*;

class queue<T>
{
	class Node 
	{
		Node next;
		Node prev;
		T data;
		public Node(T d)
		{ data = d;}
	}

	Node head;
	Node tail;
	int limit;
	int size;
	public queue()
	{
		limit = 10;
		size=0;
	}
	public queue(int size)
	{ head = tail = null; limit=size;}
	public boolean isEmpty()
	{ return head == null;}
	public int size()
	{return size;}
	public T dequeue()
	{ T ret = null;
		if(!isEmpty())
		{ Node tmp = head;
			ret = head.data;
			if(head == tail)
			{ head.next = head.prev = null;
				head = tail = null;
			}
			else 
			{ head = head.next;
				tmp.next = tmp.prev = null;
			}
			size--;
		}
		return ret;
	}
	public void enqueue(T data)
	{
		Node no = new Node(data); 
		if(size() < limit)
		{
			if(isEmpty())
				head = tail = no;
			else 
			{ tail.next = no;
				no.prev = tail;
				tail = no;
			}
			size++;
		}
	}
}

class bqueue 
{
	queue<String> q;
	int limit;
	public bqueue(int size)
	{ 
		limit = size;
		q = new queue<String>(size);}

	public synchronized String dequeue()
		throws InterruptedException
	{
		if(q.size() == 0)
			wait();
		else if(q.size() == limit)
			notifyAll();
		return q.dequeue();
	}
	public synchronized void enqueue(String str)
		throws InterruptedException
	{
		if(q.size() == limit)
			wait();			
		else if(q.size() == 0)
			notifyAll();	
		q.enqueue(str);
	}
}
class myqueue 
{
	public static void main(String args[])
	{
		queue<String> q = new queue<String>();

		q.enqueue("dog");
		q.enqueue("cat");
		q.enqueue("cow");

		while(!q.isEmpty())
		{
			System.out.println(q.dequeue());
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

public class mytry9999{
public static void main(String[] args) {
}
static void test0(){
Aron.beg();
Aron.end();
}
}

import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;

// nest list 
public class nestList
{
    public static void main(String[] args)
    {
        System.out.println("nest List");
        List<List<String>> listlist = new ArrayList<List<String>>();

        for(int i=0; i<3; i++)
        {
            List<String> list = new ArrayList<String>();
            for(int j=0; j<4; j++)
            {
                list.add("["+j+"]"); 
            }
            listlist.add(list);
        }

        for(List<String> l : listlist)
        {
            for(String str: l)
            {
                System.out.print(str);
            }
            System.out.println("");
        }
    }
}
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

// nest map
public class nestMap
{
    public static void main(String[] args)
    {
        System.out.println("nestMap!");
        Map<String, Object> map = new HashMap<String, Object>();
        Map<String, Object> innerMap = new HashMap<String, Object>();
        map.put("0",innerMap);
    }
}
import java.util.List;
import java.util.LinkedList;
class Node{
   int data;
    Node left;
    Node right;   
    public Node(int data)
    {
        this.data = data;
        left = right = null;
    }
}

public class preorderToBST 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        List<Integer> list = new LinkedList<Integer>();
        List<Integer> left = new LinkedList<Integer>();
        List<Integer> right = new LinkedList<Integer>();
        list.add(10);
        list.add(5);
        list.add(1);
        list.add(7);
        list.add(15);
        list.add(12);
        list.add(20);
        Node root = merge(list);
        inorder(root);
    }
    public static Node merge(List<Integer> list)
    {
        Node root = null;
        if(list != null && list.size() > 0)
        {
            List<Integer> left = new LinkedList<Integer>();
            List<Integer> right = new LinkedList<Integer>();
            root = new Node(list.get(0));
            split(list, left, right);
            root.left = merge(left);
            root.right = merge(right);
        }
        return root;
    }
    public static void split(List<Integer> list, List<Integer> left, List<Integer> right)
    {
        if(list != null && list.size() > 0)
        {
            int rootInt = list.get(0);
            for(int i=1; i<list.size(); i++)
            {
                if(list.get(i) < rootInt)
                {
                   left.add(list.get(i)); 
                }
                else 
                {
                    right.add(list.get(i));
                }
            }
        } 
    }
    public static void inorder(Node root)
    {
        if(root != null)
        {
            inorder(root.left);
            System.out.print("["+root.data+"]");
            inorder(root.right);
        }
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class prime_try{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    public static void test0(){
        Aron.beg();

        List<Integer> list = printPrime(1); 
        Aron.printList(list);
        Test.t(list.get(0) == 2);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        List<Integer> list = printPrime(5); 
        Aron.printList(list);
        Test.t(list.get(0) == 2);
        Test.t(list.get(1) == 3);
        Test.t(list.get(2) == 5);
        Test.t(list.get(3) == 7);
        Test.t(list.get(4) == 11);

        Aron.end();
    }
    
    static void test2(){
        Aron.beg();
        
        List<Integer> list = printAllPrime(5); 
        Aron.printList(list);
        Test.t(list.get(0) == 2);
        Test.t(list.get(1) == 3);
        Test.t(list.get(2) == 5);

        Aron.end();
    } 

    public static List<Integer> printPrime(int n){
        List<Integer> list = new ArrayList<Integer>(); 
        if(n > 0){
            list.add(2);
            int count = 1;
            int num = 3;
            while(count < n){

                boolean isPrime = true;
                for(int i=0; i<list.size(); i++){
                    if(num % list.get(i) == 0)
                        isPrime = false;
                }
                if(isPrime){
                    list.add(num);
                    count++;
                }
                num++;
            }
        }
        return list;
    }

    public static List<Integer> printAllPrime(int n){
        List<Integer> list = new ArrayList<Integer>(); 
        if(n >= 2){
            list.add(2);
            for(int i=3; i<=n; i++){
                boolean isPrime = true;
                for(int j=0; j<list.size() && isPrime; j++){
                    if(i % list.get(j) == 0)
                        isPrime = false;
                }
                if(isPrime)
                    list.add(i);
            }
        }
        return list;
    }
} 

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
 

//standard input
public class printStdIn
{
	public static void main (String args[]) 
    {
        try
        {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String input;
     
            while((input=br.readLine())!=null)
            {
                System.out.println(input);
            }
        }
        catch(IOException io)
        {
            io.printStackTrace();
        }	
  }
}

import java.io.*;
import java.lang.String;
import classfile.*;

class Node{
    Node prev;
    Node next;
    Node rand;
    int data;
    public Node() {
        prev = next = rand = null;
        data=0;
    }
    public Node(int n) {
        prev = next = rand = null;
        data = n;
    }
}

class DLL {
    Node head;
    Node tail;
    public DLL() {
        head = tail = null;
    }
    public Node gethead() {
        return head;
    }
    public void append(Node no) {
        if(head == null) {
            head = no;
            tail = head;
        } else {
            tail.next = no;
            no.prev = tail;;
            tail = tail.next;
        }
    }
    public void addfront(Node no) {
        if(head == null) {
            head = no;
            tail = head;
        } else {
            head.prev = no;
            no.next = head;
            head = no;
        }
    }
    public void addNext(Node front, Node no) {
        if(front != null) {
            if(front.next == null) {
                append(no);
            } else {
                Node cur = no;
                Node prev = front;
                Node next = front.next;

                cur.prev = prev;
                cur.next = next;
                prev.next = cur;
                next.prev = cur;
            }
        }
    }
    public void Remove(Node no) {
        if(no != null) {
            Node cur = head;
            while(cur != no) cur=cur.next;

            if(cur != null) {
                if(cur.prev == null) {
                    System.out.println ("here1");
                    if(cur.next != null) {
                        Node prev = cur;
                        cur = cur.next;
                        head = cur;
                        cur.prev = null;
                        prev.next = null;
                    } else {
                        head = tail = null;
                    }
                } else {
                    System.out.println ("here2");
                    if(cur.next != null) {
                        Node prev = cur.prev;
                        Node next = cur.next;
                        prev.next = next;
                        next.prev = prev;
                        cur.next = null;
                        cur.prev = null;
                    } else {
                        tail = cur.prev;
                        tail.next = null;
                        cur.prev = null;
                    }
                }
            } else
                System.out.println("error");
        }
    }

    public void show() {
        Node cur = head;
        while(cur != null) {
            System.out.println ("original cur.data=" + cur.data + "ran:"+cur.rand.data);
            cur = cur.next;
        }
    }

    public void show1() {
        Node cur = tail;
        while(cur != null) {
            System.out.println ("rev cur=" + cur.data + "ran:"+cur.rand.data);
            cur = cur.prev;
        }
    }
}

class randomNode{
    public static void main(String args[]) {
        DLL dll = new DLL();

        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);

        //dll.addNext(p3, new Node(7));

        p1.rand = p3;
        p2.rand = p2;
        p3.rand = p1;
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);

        dll.show();

        Node head = copyRandom(dll.gethead());
        Aron.printSLL(head);
        //show2(head);
    }
    public static void show2(Node head) {
        Node cur = head;
        while(cur != null) {
            Print.pbl(cur.data + " random " + cur.rand.data);
            cur = cur.next;
        }
    }
    public static Node copyRandom(Node head) {
        Node cur = head;
        Node next= null;
        Node copycur = null;
        Node copynext = null;
        Node copyhead = null;

        //make copy current node and add to next
        while(cur != null) {
            Node copy = new Node();
            copy.data = cur.data;

            next = cur.next;
            if(next != null) {
                cur.next = copy;
                copy.next = next;
                cur = next;
                next = cur.next;
            } else {
                cur.next = copy;
                cur = next;
            }
        }

        cur = head;
        copyhead = copycur = cur.next;
        while(cur != null) {
            copycur.rand = cur.rand.next; //wire the random node
            cur = cur.next;
            if(cur != null)
                cur = cur.next;

            copycur = copycur.next;
            if(copycur != null)
                copycur = copycur.next;
        }

        cur = head;
        copyhead = copycur = cur.next;
        while(cur != null) {
            next = copycur.next;
            if( next != null) {
                copynext = next.next;
                cur.next = next;
                copycur.next = copynext;
                copynext.prev = copycur;
                cur = next;
                copycur = copynext;
            } else {
                cur.next=null;
                cur = next;
            }
        }
        return copyhead;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class readDirectory 
{
	public static void main(String args[])
	{
		File dir = new File("/home");
		String fname[] = dir.list();
		for(int i=0; i<fname.length; i++)
		{
			System.out.println(fname[i]);
		}

	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

//read file
class readFile {

    public static void main(String args[]) {
        readFile("/tmp/file33/file.txt");
    }
    public static void readFile(String fileName) {
        try {
            // searchkey: read file line by line
            BufferedReader in = new BufferedReader(new FileReader(fileName));

            String str;
            while((str = in.readLine()) != null) {
                System.out.println(str);
            }
            in.close();
        } catch(IOException io) {
            io.printStackTrace();
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class repeatingChar 
{
	public static void main(String args[])
	{
		boolean ret = checkRepeating("abcdb");
		System.out.println(ret);
	}
	public static boolean checkRepeating(String str)
	{
		boolean ret = false;
		if( str != null)
		{
			int len = str.length();
			int check = 0;
			int bit = 0;
			for(int i=0; i<len && !ret; i++) {
				int nleft = str.charAt(i) - 'a' + 1;
				check = 1<<nleft;
				if( (check & bit) > 0 ){
					ret = true;
				}
				else {
					bit = check | bit;
				}
			}
		}
		return ret;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public boolean Find(int n)
	{
		Node cur = root;
		boolean ret = false;
		if(cur != null)
		{
			if(n < cur.data)
				cur = cur.left;
			else if(n > cur.data)
				cur = cur.right;
			else
				ret = true;
		}
		return ret;
	}
	public boolean findSum(Node r, int n)
	{
		boolean ret = false;
		if(r == null)
		{ 
			if(n == 0)
				ret = true;
		}
		else if(r != null)
		{
			boolean bl = findSum(r.left, n - r.data);
			boolean br = findSum(r.right, n - r.data);
			ret = (bl || br);
		}
		return ret;
	}
	
	public void LevelOrder()
	{
		Node cur = root;
		Queue<Node> Q1 = new LinkedList<Node>();
		Queue<Node> Q2 = new LinkedList<Node>();
		Q1.offer(cur);
		while(Q1.peek() != null || Q2.peek() != null)
		{
			while(Q1.peek() != null)
			{
				Node top = Q1.poll();
				System.out.print(top.data + " ");
				if(top.left != null)
					Q2.offer(top.left);
				if(top.right != null)
					Q2.offer(top.right);
			}
			System.out.println();
			while(Q2.peek() != null)
			{
				Node top = Q2.poll();
				
				System.out.print(top.data + " ");
				if(top.left != null)
					Q1.offer(top.left);
				if(top.right != null)
					Q1.offer(top.right);
			}
			System.out.println();
		}
	}
	public Node getRoot()
	{ return root;}
}

class  restructBinTree
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();

		b1.Insert(10);
		b1.Insert(5);
		
		b1.Insert(1);
		b1.Insert(7);
		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(20);
		int[] Arr = new int[100];
		try
		{
			FileWriter fstream = new FileWriter("bin1.txt");
			BufferedWriter out = new BufferedWriter(fstream);
			writeBinTree(b1.getRoot(), out);
			out.close();
		}
		catch(Exception e)
		{
			System.out.println("error" + e.getMessage());
		}

		String[] strArr=null;
		int[] inx=null;
		try
		{
		  BufferedReader in = new BufferedReader(new FileReader("/home/aron/try/bin1.txt"));	
			if(in == null)
			{
				System.out.println("in="+in);
			}
			else
			{
				System.out.println("out?");
			}
			String str = in.readLine();
			in.close();
			System.out.println("str="+str);

			strArr = str.split(" ");
			for(int i=0; i<strArr.length; i++)
				System.out.println(strArr[i]);
			inx = new int[1];
			inx[0] = 0;
			
			
		}
		catch(Exception e)
		{
			System.err.println("Error" + e.getMessage());
		}

		Node myroot = readBinTree(strArr, inx);
		if(myroot == null)
		{
			System.out.println("myroot="+myroot);
		}
		Inorder(myroot);

		//b.Inorder(r);

		/*			
		System.out.println();
		b.LevelOrder();
		System.out.println();

		System.out.println(equalBinaryTree(b.getRoot(), b1.getRoot()));
		System.out.println(isBST(b1.getRoot()));
		*/
	}
	public static boolean isBST(Node r)
	{

		if(r == null)
			return true;
		else
		{
			if(!isBST(r.left))
				return false;
			if(prev != null && prev.data >= r.data)
				return false;
			prev = r;
			if(!isBST(r.right))
				return false;
		}
		return true;
	}
	
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
	public static void writeBinTree(Node r, BufferedWriter out)
	{
		try
		{
			if( r != null)
			{ 
				out.write(r.data+" ");		
				writeBinTree(r.left, out);
				writeBinTree(r.right, out);
			}
			else 
				out.write("#"+" ");		
		}
		catch(Exception e)
		{
		}
	}
	public static Node readBinTree(String[] Arr, int[] i)
	{
		Node root = null;

		if(Arr != null)
		{ int len = Arr.length;	
			if(i[0]<len)
			{
				if(!Arr[i[0]].equals("#"))
				{
					root = new Node(Integer.parseInt(Arr[i[0]]));
					i[0]++;
					root.left = readBinTree(Arr, i);							
					i[0]++;
					root.right= readBinTree(Arr, i);							
				}
			}
		}
		return root;
	}
}
import java.io.*;

class reverseString 
{
	public static void main(String args[])
	{
		String cool="abcd";
		String str = reverse(cool);
		System.out.println("str=" + str);
		String str1 = reverse2(cool);
		System.out.println("str1=" + str1);

	}
	//using StringBuffer
	public static String reverse(String str)
	{
		StringBuffer sb = null;
		if(str != null)
		{
			sb = new StringBuffer(str);
			int len= str.length();
			for(int i=0; i<len/2; i++)
			{
				char c=sb.charAt(i);
				sb.setCharAt(i, sb.charAt(len-1-i));
				sb.setCharAt(len-1-i, c);
			}
		}
		return sb.toString();
	}

	//using char[] 
	public static String reverse2(String str)
	{
	 	String ret=null;	
		if(str != null)
		{
			int len= str.length();
		  char[] charArr = str.toCharArray();	
			for(int i=0; i<len/2; i++)
			{
				char c = charArr[i];
				charArr[i]=charArr[len-1-i];
				charArr[len-1-i]=c;
			}
			ret = new String(charArr);
		}
		return ret;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class rotate90 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
		rotateclockwise90(A);

		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

		rotatecounterclockwise90(A);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
	}
	//rotate right 90
	public static int[][] rotateclockwise90(int[][] A)
	{
		if(A != null)
		{
			int nRow = A.length;
			int nCol = A[0].length;
			for(int k=0; k<nRow/2; k++)
				for(int i=k; i<nRow-1-k; i++)
				{
					int tmp = A[k][i];
					A[k][i] = A[nRow-1-i][k];
					A[nRow-1-i][k] = A[nRow-1-k][nRow-1-i];
					A[nRow-1-k][nRow-1-i] = A[i][nRow-1-k];
					A[i][nRow-1-k] = tmp;
				}
		}
		return A;
	}
	//rotate left 90
	public static int[][] rotatecounterclockwise90(int[][] A)
	{
		if( A != null)
		{
			int nRow = A.length;
			int nCol = A[0].length;
			for(int k=0; k<nRow/2; k++)
			{
				for(int i=k; i<nRow-1-k; i++)
				{
					int tmp = A[k][nRow-1-i];
					A[k][nRow-1-i] = A[nRow-1-i][nRow-1-k];
					A[nRow-1-i][nRow-1-k]=A[nRow-1-k][i];
					A[nRow-1-k][i]=A[i][k];
					A[i][k]=tmp;
				}
			}
		}
		return A;
	}
}
import java.io.*;
class setbit 
{
	public static void main(String args[])
	{
		int num = 100;
		String n = Integer.toBinaryString(num);
		System.out.println(num+"=" + n);

		isSetBit(100, 2);
		
	}
	public static void isSetBit(int num, int k)
	{
		int bit = 1<<k;
		if((bit & num) > 0)
			System.out.println("set bit in " + k);
		else 
			System.out.println("does not set bit in " + k);
	}
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class spiral2{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1,   2,   3},
            { 4,   5,   6},
            { 7,   8,  9},
            { 10,  11,  12},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);

        Aron.end();
    }

    public static void test1(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1,   2,   3},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);

        Aron.end();
    }

    public static void test2(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1,   2,   3},
            { 4,   5,   6},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        
        int[][] arr2d = {
            { 1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);

        Aron.end();
    }
    public static void spiral(int[][] arr){
        if(arr != null){
            int h = arr.length;
            int w = arr[0].length;

            for(int k=0; k<h; k++){
                
                if(h - 2*k == 1){
                    for(int i=k; i<w-k; i++)
                        Print.pb(arr[k][i]);

                    break;
                }else if(w - 2*k == 1){
                    for(int i=k; i<h-k; i++)
                        Print.pb(arr[i][k]);

                    break;
                }else{

                    for(int i=k; i<w-1-k; i++)
                        Print.pb(arr[k][i]); 

                    for(int i=k; i<h-1-k; i++)
                        Print.pb(arr[i][w-1-k]);

                    for(int i=k; i<w-1-k; i++)
                        Print.pb(arr[h-1-k][w-1-i]);

                    for(int i=k; i<h-1-k; i++)
                        Print.pb(arr[h-1-i][k]);
                }
            }
        }
    }
} 

import java.io.*;
import java.util.Vector;
import java.lang.String;
/*
 * remove whitespace, and concatenate words to line and each line had less than or equal to 10 characters and each word can't been split 
 *
*/ 
class splitword 
{
	public static void main(String args[])
	{
		String str = "what are you going to do that? well. I have no idea!";
		Vector<String> vet = splitword(str);
		for(int i=0; i<vet.size(); i++)
			System.out.println("["+vet.get(i)+"]");
		
	}
	public static Vector<String> splitword(String str)
	{
	 	Vector<String> vet = new Vector<String>();	
		if( str != null && str.length() > 0)
		{
			int len = str.length();
			String s="";
			String line="";
			int sum=0;
			for(int i=0; i<len-1; i++)
			{
				if(str.charAt(i) != ' ' && str.charAt(i+1) ==' ') {
					s += str.charAt(i)+"";
					vet.add(s);	
					if(sum + s.length() <= 10) {
						line += s;
						sum += s.length();
					}
					else {
						line += "\n"+s;
						sum = s.length();
					}
					s="";
				}
				else if(str.charAt(i) != ' ' && str.charAt(i+1) != ' ')
					s += str.charAt(i)+"";
			}
			if(str.charAt(len-1) != ' ')
			{
				s += str.charAt(len-1);
				if(sum + s.length() <=10) {
					line += s;
					sum += s.length();
				}
				vet.add(s);	
			}
			System.out.println("line="+line);
		}
	
		return vet;
	}
}
import java.io.*;

class staircasewalk
{
	public static void main(String args[])
	{
		System.out.println("cool");

		int[][] Arr = new int[4][3];
		int ret = staircase1(Arr);

		int nRow = 4, nCol=3;
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
				System.out.print(Arr[i][j]+" ");
			System.out.println();
		}
	}
	// go right and go down
	public static int staircase(int[][] Arr)
	{
		int ret=0;
		if( Arr != null)
		{
			int nRow = Arr.length;
			int nCol = Arr[0].length;
			for(int i=0; i<nRow; i++)
				Arr[i][0]=1;	
			for(int j=0; j<nCol; j++)
				Arr[0][j]=1;	

			for(int i=1; i<nRow; i++)
				for(int j=1; j<nCol; j++)
				{
						if(i == 2 && j == 1) // object in [2][1]
							Arr[i][j]=0;
						else 
							Arr[i][j] = Arr[i-1][j] + Arr[i][j-1];
				}

			ret = Arr[nRow-1][nCol-1];
		}
		return ret;
	}

	//go right, go down and diagonal
	public static int staircase1(int[][] Arr)
	{
		int ret=0;
		if( Arr != null)
		{
			int nRow = Arr.length;
			int nCol = Arr[0].length;
			for(int i=0; i<nRow; i++)
				Arr[i][0]=1;	
			for(int j=0; j<nCol; j++)
				Arr[0][j]=1;	

			for(int i=1; i<nRow; i++)
				for(int j=1; j<nCol; j++)
				{
						if(i == 2 && j == 1) // object in [2][1]
							Arr[i][j]=0;
						else 
							Arr[i][j] = Arr[i-1][j] + Arr[i][j-1] + Arr[i-1][j-1];
				}

			ret = Arr[nRow-1][nCol-1];
		}
		return ret;
	}
}
import java.io.*;
import java.lang.*;
import java.util.*;

class turl
{
	int count;
	int maxurl;
	Map<Integer, String> charMap = new HashMap<Integer, String>();
	Map<String, String> urlMap = new HashMap<String, String>();
	Map<String, String> biurlMap = new HashMap<String, String>();

	public turl(int max)
	{ maxurl = max;
		count = 0;	

		for(int i=0; i<26; i++)
		{ char ch = (char)((int)'a' + i);
			charMap.put(i, Character.toString(ch));
		}
	}
	public String generate(String url)
	{
		String ret="";
		int c = count;
		if(!urlMap.containsKey(url))
		{
			String code="";
			if( c == 0)
				code="a";
			else 
				while(c > 0)
				{
					int m = c%26;
					c = c/26;
					String s = charMap.get(m);
					code = s + code;
				}
			urlMap.put(url, code);
			biurlMap.put(code, url);
			if(count < maxurl);
			count++;
			ret = code;
		}
		else 
			ret = urlMap.get(url);
		return ret;
	}
	public String geturl(String code)
	{
		return biurlMap.get(code);	
	}
}
class tinyurl 
{
	public static void main(String args[])
	{
			String s="";
			turl t = new turl(26*26);
			Random r = new Random();
			for(int j=0; j<26*26; j++) 
			{
				s="";
				for(int i=0; i < 10; i++)
				{
					int ran = r.nextInt(10);
					s += Integer.toString(ran);
				}
				String code = t.generate(s);
				System.out.println("code="+code + "->"+s);
			}
	}
}

import java.util.*;
import java.io.*;
import classfile.*;

int findMaxIndex(int[] arr, int lo, int li) {
    int mid = (lo + hi)/2;
    if(arr[lo] < arr[mid])
        return findMaxIndex(arr, mid, hi);
    else
        return findMaxIndex(arr, lo, mid);
}

public class try43 {
    public static void main(String[] args) {
        test0();
        List<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();

        test1();
    }
    public static void test0() {
        Aron.beg();
        // cool
        // This is Binary Search Tree, the runtime is O(log n)
        // deletion, lookup and insection are all O(log n)
        // deletion, lookup and insection are all O(log n)
        // quick sort is O(nlog n)
        // merge sort is O(nlog n)
        // quick sort is different than merge sort
        // Binary Search Tree[BST]
        // Serialization is cool
        // serialize
        // implements
        // extends
        // Could you give me an update on the test result?
        // merge sort is O(nlog n)

        Map<String, String> map = new HashMap<String, String>();
        for(Map.Entry<String, String> entry : map.entrySet()) {
            System.out.println("[" + entry.getKey() + " , " + entry.getValue() + "]");
        }

        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
            { 13,  14,  15, 16},
        };
        int height = arr2d.length;
        int width = arr2d[0].length;

        Aron.end();

    }
    public static void test1() {
        Aron.beg();

        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

public class tryDD{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class try_44 {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();

        try {
            FileInputStream fstream = new FileInputStream("./text/file99.txt");
            // Get the object of DataInputStream
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String strLine;
            //Read File Line By Line
            while ((strLine = br.readLine()) != null) {
                // Print the content on the console
                Print.pbl(strLine);
            }
            //Close the input stream
            in.close();
        } catch (Exception e) {
            //Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }

        Aron.end();
    }
    public static void test1() {
        Aron.beg();

        String file = "./text/file99.txt";
        try(BufferedReader br = new BufferedReader(new FileReader(file))){
            for(String line; (line = br.readLine()) != null;){
                System.out.println("[" + line + "]");
            }
        }catch(IOException io){
        }

        Aron.end();
    }
}

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class try_Generandom{
    public static void main(String[] args) {
        test0();
    }
    public static void test0(){
        Aron.beg();

        String fName = "/Users/cat/myfile/github/java/text/random.txt";
        List<Integer> list = Aron.random(1000);
        List<String> slist = new ArrayList<String>(); 
        for(Integer n : list)
            slist.add(n + " ");

        Aron.writeFile(fName, slist);

        Aron.end();
    }
} 

import java.util.stream.*;
import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;

//
import classfile.*; 

public class try_fileAttribute{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        String file = "/Users/cat/myfile/github/java";
        Path path = Paths.get(file);
        BasicFileAttributes attr = Files.readAttributes(file, BasicFileAttributes.class);

        System.out.println("creationTime: " + attr.creationTime());
        System.out.println("lastAccessTime: " + attr.lastAccessTime());
        System.out.println("lastModifiedTime: " + attr.lastModifiedTime());

        System.out.println("isDirectory: " + attr.isDirectory());
        System.out.println("isOther: " + attr.isOther());
        System.out.println("isRegularFile: " + attr.isRegularFile());
        System.out.println("isSymbolicLink: " + attr.isSymbolicLink());
        System.out.println("size: " + attr.size());

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;

import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
//
import classfile.*; 

public class try_fileatt{
	public static void main(String[] args) throws IOException {

         String fName = "/Users/cat/myfile/github/java";
         List<String> list = Aron.getCurrentFiles(fName); 

         for(String s : list){
             Path file = Paths.get(s);

             Print.pbl("name=" + s);
             BasicFileAttributes basicAttr = Files.readAttributes(file, BasicFileAttributes.class);
             FileTime creationTime = basicAttr.creationTime();
             System.out.println(creationTime);

             FileTime lastAccessTime = basicAttr.lastAccessTime();
             System.out.println(lastAccessTime);
             FileTime lastModifiedTime = basicAttr.lastModifiedTime();
             System.out.println(lastModifiedTime);
            
             Ut.l();
         }
	}
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;
import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
//
import classfile.*; 


public class try_search{
    public static void main(String[] args) {
        test0();
    }

    public static  void FileSearch(List<String> list, String pattern){
        Map<String, String> map = new HashMap<>();
        Pattern pat = Pattern.compile(pattern);

        for(String s : list){
            Matcher match = pat.matcher(s);
            if(match.find()){
                Print.pbl(s);
                break;
            }
        }
    }

    public static void test0(){
        Aron.beg();
        
        // immutable list
        List<String> list = Arrays.asList("cat", "dog", "cow");

        FileSearch(list, "at");
        FileSearch(list, "cow");
        
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class trya1 {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
}

public static class Point implements Comparable<Point> {
    public double x;
    public double y;

    public Point(final double x, final double y) {
        this.x = x;
        this.y = y;
    }
    
    public double getDist(){
    	return x*x+y*y;
    }

	public int compareTo(Point o) {
		int c = Double.compare(getDist(), o.getDist());
		if(c == 0){
			c = Double.compare(x, o.x);
			if(c == 0){
				c = Double.compare(y, o.y);
			}
		}
		
		return c;
	}

	public String toString() {
		return "[" + x + "," + y + "]";
	}
}

public static Point[] kCloest(final Point points[], final int k) {
    //max heap
    final PriorityQueue<Point> kQueue = new PriorityQueue<>(k, Collections.reverseOrder());

    for (int i = 0; i < points.length; i++) {
        if (kQueue.size() < k) {
        	kQueue.add(points[i]);
        } else if (points[i].getDist() < kQueue.peek().getDist()) {
            kQueue.remove();
            kQueue.add(points[i]);
        }
    }

    return kQueue.toArray(new Point[k]);
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class tryn_nonconsecutive{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    public static void test0(){
        Aron.beg();
        Integer[] arr = {3, 4, 2};
        int width = arr.length; 
        int max = getMax(arr);
        Print.pbl("max=" + max);
        Test.t(max == 5);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Integer[] arr = {3};
        int width = arr.length; 
        int max = getMax(arr);
        Print.pbl("max=" + max);
        Test.t(max == 3);

        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        Integer[] arr = {3, 4, -1, 5, 2};
        int width = arr.length; 
        int max = getMax(arr);
        Print.pbl("max=" + max);
        Test.t(max == 9);

        Aron.end();
    }
    // 3, 4, 2
    public static int getMax(Integer[] arr){
        int pmax = 0;
        int max= Math.max(pmax, arr[0]); 
        for(int i=1; i<arr.length; i++){
            int m1 = Math.max(pmax + arr[i], arr[i]); // s_k is not in S
            int m2 = Math.max(max, arr[i]);  // s_k not in s
            pmax = max;
            max = Math.max(m1, m2);
        }
        return max;
    }
} 

import java.io.*;
class wordcount 
{
	public static void main(String args[])
	{
		String str="a";
		int c = WordCount(str);
		System.out.println("c=" + c);

	}
	public static int WordCount(String str)
	{
		int c = 0;
		if(str != null)
		{
			if(str.length() == 1)
			{
				if(str.charAt(0) !=' ')
					c=1;
			}
			else
			{
				for(int i=1; i<str.length(); i++)
				{
					if(str.charAt(i-1) != ' ' && str.charAt(i) == ' ')
						c++;
				}
				if(str.charAt(str.length() - 1) != ' ')
					c++;
			}

		}	
		return c;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class writeFile 
{
	public static void main(String args[]) {
        writeToFile();
	}
    public static void writeToFile(){
    	try {
            // searchkey: write to file, write file, write to text file, open file to write
			FileWriter fstream = new FileWriter("out.txt");
			BufferedWriter out = new BufferedWriter(fstream);
			out.write("hello java");
			out.close();
		}
		catch(Exception e) {
		}
    }
}
import java.util.concurrent.locks.*;
import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
//
import classfile.*; 

class BoundedBuffer {
    final Lock lock = new ReentrantLock();
    final Condition notFull  = lock.newCondition();
    final Condition notEmpty = lock.newCondition();

    final Object[] items = new Object[100];
    int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                notFull.await();
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}



// conditional variable with Lock, ReentrantLock, Conditon
// signal whether one variable is available or not
class ConditionVar{
    private int contents;
    private boolean available = false;
    private Lock aLock = new ReentrantLock();
    private Condition condVar = aLock.newCondition();

    public int get(int who) {
        aLock.lock();
        try {
            while (available == false) {
                try {
                    condVar.await();
                } catch (InterruptedException e) { }
            }
            available = false;
            System.out.println("Consumer " + who + " got: " + contents);
            condVar.signalAll();
        }
        finally {
            aLock.unlock();
            return contents;
        }
    }


    public void put(int who, int value) {
        aLock.lock();
        try {
            while (available == true) {
                try {
                    condVar.await();
                } catch (InterruptedException e) { }
            }
            contents = value;
            available = true;
            System.out.println("Producer " + who + " put: " +
                               contents);
            condVar.signalAll();
        }
        finally {
            aLock.unlock();
        }
    }
}

class ConditionalVariable{
    public static void main(String args[]) {
        test0();
    }
    static void test0(){
        Aron.beg();
        ConditionVar cv = new ConditionVar();
        int c = cv.get(1);
        Print.pbl("c=" + c);
        cv.put(2, 20);
        int c1 = cv.get(1);
        Print.pbl("c1=" + c1);

        Aron.end();
    }
}
import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Queue; 
import java.util.LinkedList; 
import java.util.concurrent.atomic.AtomicInteger;

import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
//
import classfile.*; 

 
// consumer producer
// consumer and producer, consumer producer problem,
// multiple therad consumer producer 
class MyProducer extends Thread {
    static final int MAXQUEUE = 2;
    private Queue queue = new LinkedList();
    Logger LOGGER;
 
    public MyProducer(Logger LOGGER){
        this.LOGGER = LOGGER;
    }

    @Override
    public void run() {
        try {
            while (true) {
//                Print.pbl("put msglen[" + queue.size() + "]");
                putMessage();
                //sleep(5000);
            }
        } catch (InterruptedException e) {
        }
    }
 
    private synchronized void putMessage() throws InterruptedException {
        while (queue.size() == MAXQUEUE) {
            wait(1000);
        }
        queue.add(new java.util.Date().toString());
//        System.out.println("Put message");
        notify();
        //Later, when the necessary event happens, the thread that is running it calls notify() from a block synchronized on the same object.
    }
    public synchronized String getMessage() throws InterruptedException {
        notify();
        Aron.threadInfo(this);
        Ut.l();

        while (queue.size() == 0) {
            wait(1000);//By executing wait() from a synchronized block, a thread gives up its hold on the lock and goes to sleep.
        }
        String msg = (String) queue.poll();
        
        Print.pbl("msglen[" + queue.size() + "] msg=" + msg);
        return msg ;
    }
}
 
class MyConsumer extends Thread {
    MyProducer producer;
    Logger LOGGER;
    MyConsumer(Logger LOGGER, MyProducer p) {
        this.LOGGER = LOGGER;
        producer = p;
    }
    MyConsumer(MyProducer p) {
        producer = p;
    }
 
    @Override
    public void run() {
        try {
            while (true) {
                String message = producer.getMessage();
                Print.pbl("getmsg[" + message + "]");
                LOGGER.info("getmsg=" + message); 
                Thread.sleep(100);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ConsumerProducer{
    public static void main(String[] args) {
        Logger LOGGER = Aron.logInit(MyProducer.class.getName(), "/Users/cat/myfile/github/java/text/Logging3.txt");

        MyProducer producer = new MyProducer(LOGGER);
        producer.start();
        
        for(int i=0; i<2; i++){
            new MyConsumer(LOGGER, producer).start();
        } 
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class RunnableThread implements Runnable {
    public void run() {
        for(int i=0; i<5; i++) {
            System.out.println("ID=["+Thread.currentThread().getName()+"]i="+i);
            try {
                Thread.sleep(3000);
            } catch(InterruptedException e) {}
        }
    }
}


class FirstThread {
    public static void main(String args[]) {
        for(int i=0; i<4; i++) {
            Thread t1 = new Thread(new RunnableThread());
            t1.start();
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

//[file=nonsynthread.html title=""
public class HelloThread implements Runnable{
    public int num;
    public HelloThread(int num){
        this.num = num;
    }
    public void run(){
        for(int i=0; i<10; i++){
            this.num += 1;
            System.out.println("num=[" + num + "]");
        }
    }

    public static void main(String[] args) {
        Thread[] array = new Thread[10];
        for(int i=0; i<10; i++){
            array[i] = new Thread(new HelloThread(1)); 
            array[i].start();
        }
    }
}
//]
import classfile.*;

//[ file=jointhread.html title=""
class TestJoin extends Thread{
    public void run(){
        for(int i=0; i<5; i++){
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("[id=" + getId() + " name=" + getName() + "]["+i+"]");
        }
    }
}

public class JoinThread {
    public static void main(String[] args) {
        test1();
    }
    static void test1(){
        Aron.beg();
        TestJoin t1 = new TestJoin();
        TestJoin t2 = new TestJoin();
        TestJoin t3 = new TestJoin();

        t1.start();
        try{
            t1.join(1500);
        }catch(Exception e){
        }

        t2.start();
        t3.start();

        Aron.end();
    }
}
//]
import java.io.*;
import java.lang.String;
import java.util.*;

// simple thread example
// runnable example, Runnable example
class RunnableThread implements Runnable {
    Thread runner;

    public RunnableThread() {
    }
    public RunnableThread(String name) {
        runner = new Thread(this, name);
        System.out.println(runner.getName());
        runner.start();
    }
    public void run() {
        for(int i=0; i<100; i++) {
            System.out.println(Thread.currentThread()+"i="+i);
            try {
                Thread.sleep(1000);
            } catch(InterruptedException e) {
                System.out.println(Thread.currentThread());
            }
        }
    }
}

class MyThread {
    public static void main(String args[]) {
        System.out.println("n2=");

        Thread thread1 = new Thread(new RunnableThread(), "thread1");
        Thread thread2 = new Thread(new RunnableThread(), "thread2");

        thread1.start();
        thread2.start();

        try {
            Thread.currentThread().sleep(1000);
        } catch(InterruptedException e) {
        }
        System.out.println(Thread.currentThread());
    }
}
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;

import java.util.concurrent.locks.ReentrantLock;

// reentrantlock example, ReentrantLock example,
// what are the difference between ReentrantLock and synchronized
public class ReentrantLockExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        final ReentrantLock lock = new ReentrantLock();

        class Worker implements Runnable {
            private String name;
            Worker(String name) {
                this.name = name;
            }

            @Override
            public void run() {
                lock.lock();
                try {
                    if (lock.isHeldByCurrentThread())
                        System.out.printf("Thread %s has entered its critical section.%n", name);
                    System.out.printf("Thread %s is performing work for 2 seconds.%n", name);
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException ie) {
                        ie.printStackTrace();
                    }
                    System.out.printf("Thread %s has finished working.%n", name);
                }
                finally {
                    lock.unlock();
                }
            }
        }

        
        for(int i=0; i<10; i++){
            executor.execute(new Worker(i + ""));
        } 

        try {
            executor.awaitTermination(20, TimeUnit.SECONDS);
        } catch (InterruptedException ie) {
            ie.printStackTrace();
        }
        executor.shutdownNow();
    }
}

import classfile.*;
import java.lang.management.ManagementFactory;

//[ file=synthread.html title=""
class Account{
    int balance = 0;
    public Account(){
    }

    public synchronized void deposit(int n){
    //public void deposit(int n){
        for(int i=0; i<3; i++) {
            balance += n;
            System.out.println("acc=[" + balance + "]");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public synchronized void addNode(){
//    public void addNode(){
        SingleLinkedList sll = new SingleLinkedList();
        for(int i=0; i<5; i++){
            sll.append(i);

            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } 
        Aron.printSLL(sll.head);
    }
}

class SimpleThread implements Runnable{
    Account acc;
    public SimpleThread(Account acc){
        this.acc = acc;
    }
    public void run(){
        acc.deposit(1);
        //acc.addNode();
    }
}

class TestJoin extends Thread{
    public void run(){
        for(int i=0; i<5; i++){
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("[id=" + getId() + " name=" + getName() + "]["+i+"]");
        }
    }
}

public class SynchThreadExample{
    public static void main(String[] args) {
        //test0();
        test1();
    }

    static void test0(){
        Account acc = new Account();
        for (int i = 0; i < 10; i++) {
            Thread t = new Thread(new SimpleThread(acc));
            t.start();
        }
    }
    static void test1(){
        Account acc = new Account();
        for (int i = 0; i < 4; i++) {
            Thread t = new Thread(new SimpleThread(acc));
            t.start();
        }
    }
}
//]

//public class ExampleClass {
//class LongRunningThread extends Thread {
//    private int n;
//    public LongRunningThread(int n) {
//        this.n = n;
//    }
//    public void run() {
//        ArrayList l = new ArrayList();
//        for (int i = 0; i < n; i++) {
//            l.add(new Object());
//        }
//        long time = ManagementFactory.getThreadMXBean().getThreadCpuTime(this.getId());
//        System.out.println("Long running thread " + this.getId() + " execution time: " + time);
//    }
//}
//
//class MyThread extends Thread {
//    int n;
//    public MyThread(int n) {
//        this.n = n;
//    }
//    public void run() {
//        ArrayList l = new ArrayList();
//        for (int i = 0; i < n; i++) {
//            l.add(new Object());
//        }
//        long time = ManagementFactory.getThreadMXBean().getThreadCpuTime(this.getId());
//        System.out.println("My thread " + this.getId() + " execution time: " + time);
//    }
//}
//
//public static void main(String [] args) {
//        System.out.println("Cpu time supported? " + ManagementFactory.getThreadMXBean().isThreadCpuTimeSupported());
//    System.out.println("Cpu time enabled? " + ManagementFactory.getThreadMXBean().isThreadCpuTimeEnabled());
//    for (int i = 1; i < 10; ++i) {
//        new LongRunningThread(i*1000000).start();
//    }
//
//    for (int i = 1; i < 10; ++i) {
//        new MyThread(i*100).start();
//    }
//}
//
//
//Output:
//Cpu time supported? true
//Cpu time enabled? true
//My thread 18 execution time: 0
//My thread 26 execution time: 0
//My thread 20 execution time: 0
//My thread 22 execution time: 0
//My thread 24 execution time: 0
//My thread 21 execution time: 0
//My thread 25 execution time: 0
//My thread 19 execution time: 0
//My thread 23 execution time: 0
//Long running thread 9 execution time: 15600100
//Long running thread 10 execution time: 15600100
//Long running thread 11 execution time: 46800300
//Long running thread 12 execution time: 31200200
//Long running thread 14 execution time: 78000500
//Long running thread 13 execution time: 78000500
//Long running thread 17 execution time: 124800800
//Long running thread 15 execution time: 140400900
//Long running thread 16 execution time: 109200700
import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue; 
import java.util.LinkedList; 
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
import java.io.IOException;

import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import classfile.*;

 
// concurrent, thread, atomic integer, atomicinteger  atomic modulo, 
// mod atomic integer
class AtomicModulo{
    public AtomicInteger n = new AtomicInteger(0);
    int len;
    public AtomicModulo(int len){
        this.len = len;
    }
    public int modulo(){
        return n.incrementAndGet() % len;
    }
    public int get(){
        return n.get();
    }
}

class HelloThread implements Runnable {
    private final static Logger LOGGER = Aron.logInit(HelloThread.class.getName(), "/Users/cat/myfile/github/java/text/atomic1.txt");
    static private FileHandler fileTxt;
    static private SimpleFormatter formatterTxt;
    private static Object obj = new Object();

    static long ti = System.currentTimeMillis();

    private AtomicModulo atom;
    public HelloThread(AtomicModulo atom){
        this.atom = atom;
    }
    public void run(){
        doWork();
    }
    
    public void doWork(){
      while(true){
          synchronized(obj){
              int num = atom.n.incrementAndGet();
              Print.pbl("mod=" + (num % atom.len) + " n=" + num + " id=" + Thread.currentThread().getId());
              LOGGER.info("mod=" + (num % atom.len) + " n=" + num + " id=" + Thread.currentThread().getId()); 

              long tf = System.currentTimeMillis();
              long diff = tf - ti;
              Print.pbl("Finish. Total time:" + diff + " init time:" + ti); 
              if(diff > 20000)
                  break;
          }

          try{
              Thread.sleep(100); 
          }catch(InterruptedException e) {}

      }
    }
}

public class Thread_AtomicModulo{
    public static void main(String[] args) {
        test0();
    }
    
    static void test0(){
        Aron.beg();

        Print.pbl("Thread_AtomicModulo.java");
        int len = 2;
        AtomicModulo am = new AtomicModulo(len);
        for(int i=0; i<3; i++){
            Thread t = new Thread(new HelloThread(am));
            t.start();
        } 

        Aron.end();
    }
    
    static void test1(){
        Aron.beg();
        

        Aron.end();
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.util.Date;
import java.io.*;
import java.util.stream.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicInteger;
import classfile.*;


class Message{
    String msg;
    public Message(String msg){
        this.msg = msg;
    }
    public String getMsg(){
        return msg;
    }
    public void setMsg(String msg){
        this.msg = msg;
    }
}

class Producer implements Runnable{
    Queue<String> queue; 
    int num = 0;
    public Producer(Queue<String> q){
        queue = q;
    }
    public void run(){
        try{
            while(true){
                add();
            }
        }catch(InterruptedException e){
            e.printStackTrace();
        }
    }
    public synchronized void add() throws InterruptedException{
        Aron.threadInfo();

        while(queue.size() >= 20){
            wait();
        }

        num++;
        Print.pbl("add msg=" + num);
        queue.add(num + "");
        notify();
    }
    public synchronized String get() throws InterruptedException{
        notify();
        while(queue.size() == 0){
            wait();
        }
        String s = queue.poll();
        Print.pbl("kkget msg=" + s);
        return s;
    }
}

class Consumer implements Runnable{
    Producer producer;
    public Consumer(Producer producer){
        this.producer = producer;
    }
    public void run(){
        try{
            Aron.threadInfo();
            while(true){
                String s = producer.get();
                //Print.pbl("get msg=" + s);
                Thread.sleep(2000);
            }
        }catch(InterruptedException e){
        }
    }
    public synchronized void remove(){
        Aron.threadInfo();
    }
}


class Waiter implements Runnable{
    Message mq;
    public Waiter(Message mq){
        this.mq = mq;
    }
    public void run(){
        synchronized(mq){
            try{
                Aron.threadInfo();
                mq.wait(); 
                Print.pbl("Waiter end");
            }
            catch(InterruptedException interruptedException){
                interruptedException.printStackTrace();
            }
        }
    }
}

class Notifier implements Runnable{
    Message mq;
    public Notifier(Message mq){
        this.mq = mq;
    }
    public void run(){
        try{
            Aron.threadInfo();

            Thread.sleep(3000);
        }catch(InterruptedException interruptedException){
            interruptedException.printStackTrace();
        }
        synchronized(mq){
            Print.pbl("Notifier is notifying waiting thread to wake up at=" + new Date());

            mq.notify();
        }
    }
}

class LevelPrint {
    Node r;
    public LevelPrint(Node r) {
        this.r = r;
    }
    public void print() {
        if( r != null) {
            Queue<Node> q = new LinkedList<Node>();
            q.add(r);
            while(!q.isEmpty()) {
                Node n = q.poll();
                Print.pbl(n.data);
                if(n.left != null)
                    q.add(n.left);
                if(n.right != null)
                    q.add(n.right);
            }
        }
    }
}

class ThreadLevelPrint implements Runnable {
    Node r;
    public ThreadLevelPrint(Node r) {
        this.r = r;
    }
    public void run() {
        Ut.l();
        if( r != null) {
            Queue<Node> q = new LinkedList<Node>();
            if(r != null)
                q.add(r);
                while(!q.isEmpty()) {
                    Node n = q.poll();
                    Print.pbl("t=" + n.data);
                    if(n.left != null) {
                        q.add(n.left);
                    }

                    if(n.right != null) {
                        q.add(n.right);
                    }
                }
        }
        Ut.l();
    }
}

class AtomicCount {
    private AtomicInteger num = new AtomicInteger(0);
    public AtomicCount() {
    }
    public void add() {
        int n = num.getAndIncrement();
        Print.pbl("n=" + n);
    }
    public int get() {
        return num.get();
    }

    public void print() {
        Print.pbl("num=" + num.get());
        int n = num.getAndIncrement();
        Print.pbl("num.getAndIncrement()=" + n);
        int newValue = num.getAndSet(10);
        Print.pbl("newValue=" + newValue);

        for(int i=0; i<3; i++) {
            int n1 = num.getAndIncrement();
            Print.pbl("n1=" + n1);
        }

    }
}

class AtomicCountThread implements Runnable {
    AtomicCount ac;
    public AtomicCountThread(AtomicCount ac) {
        this.ac = ac;
    }
    public void run() {
        ac.add();
    }
}


class MyLock {
    private boolean isLocked = false;
    public synchronized boolean lock() {
        if(!isLocked) {
            isLocked = true;
            return isLocked;
        }
        return false;
    }
    public synchronized void unlock() {
        isLocked = false;
        notify();
    }
}

class LockThread extends Thread{
    MyLock lock;
    public LockThread(MyLock lock){
        this.lock = lock;
    }
//    public void run(){
//        if(lock.lock()){
//            for(int i=0; i<30; i++){
//                Print.pbl("thread id=" + Thread.currentThread().getId() + "-> i=" + i);
//            } 
//            lock.unlock();
//        }
//    }
    public synchronized void run(){
        for(int i=0; i<10; i++){
            Print.pbl("thread id=" + Thread.currentThread().getId() + "-> i=" + i);
        } 
    }
}

class DeleteLinkedList {
    public SingleLinkedList sll;
//    public SingleLinkedList sll = new SingleLinkedList();
    int count = 0;
    public DeleteLinkedList() {
        sll = new SingleLinkedList();
    }
//    public synchronized void add(){
    public void add() {
        synchronized(this) {
            count++;
            sll.add(new Node(count));
        }
    }
}

class ConcurrentQueue {
    // ConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();
    Queue<Node> queue = new LinkedList<Node>();
    MyLock lock = new MyLock();
    //ConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();
    int sum = 0;
    public void add() {
        if(lock.lock()) {
            sum++;
            queue.add(new Node(sum));
        }
    }
//    public synchronized void add(){
//        sum++;
//        queue.add(new Node(sum));
//    }
    public void remove() {
        queue.poll();
    }
    public void print() {
        while(!queue.isEmpty()) {
            Node n = (Node)queue.poll();
            Print.pbl(n.data);
        }
    }
}

class QueueThread implements Runnable {
    ConcurrentQueue queue;
    public QueueThread(ConcurrentQueue q) {
        queue = q;
    }
    public void run() {
        queue.add();
    }
}


// simple thread example, thread simple
class Account {
    int sum = 0;
    Node root;
    Queue<Node> queue = new LinkedList<Node>();
    int max = 10;
    public Account() {
    }
    public Account(Node root) {
        this.root = root;
    }
    public synchronized void increase(int n) {
        sum += n;
        Print.pbl("sum=" + sum);
    }

    public synchronized void printLevel() {
        Node curr = root;
        Queue<Node> q = new LinkedList<Node>();
        if(curr != null) {
            q.add(curr);
            while(q.size() > 0) {
                Node node = q.remove();
                Print.pbl("q.data=" + node.data);
                if(node.left != null)
                    q.add(node.left);
                if(node.right != null)
                    q.add(node.right);
            }
        }
    }

    public void doWork() {
        Random r = new Random();
        Random ran = new Random();
        int n = r.nextInt(100);

//        Print.pbl("random=" + n);
        if(n % 2 == 0) {
            add(new Node(ran.nextInt(100)));
        } else
            remove();
    }


    public synchronized void add(Node n) {
        if(queue.size() < max) {
            Print.pbl("add=" + n.data);
            queue.add(n);
        } else
            Print.pbl("queue is full");
    }
    public synchronized void remove() {
        if(queue.size() > 0) {
            Node n = queue.remove();
            Print.pbl("remove=" + n.data);
            Print.pbl("sleep 3000");

            try {
                Thread.sleep(1000);
            } catch(InterruptedException e) {}
        } else
            Print.pbl("queue is empty");
    }
}

class ThreadLinkedList implements Runnable {
    DeleteLinkedList dll;
    public ThreadLinkedList(DeleteLinkedList dll) {
        this.dll = dll;
    }
    public void run() {
        dll.add();
    }
}

class MyThread implements Runnable {
    Account acc;
    public MyThread(Account acc) {
        this.acc = acc;
    }
    public void run() {
//        acc.increase(1);
//        acc.printLevel();
        acc.doWork();
        Ut.l();
    }
}

public class Thread_example {
    public static void main(String[] args) {
//        test0();
//        test1();
//        test2();
//        test3();
//        test4();
//        test5();
//        test6();
//        test7();
//        test8();
//        test9();
//          test10();
//          test11();
          test12();
    }
    public static void test0() {
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root);

        Account acc = new Account(b1.root);
        for(int i=0; i<10; i++) {
            Thread t = new Thread(new MyThread(acc));
            t.start();
        }

        Aron.end();
    }
    public static void test1() {
        Aron.beg();

        Account acc = new Account();
        for(int i=0; i<100; i++) {
            Thread t = new Thread(new MyThread(acc));
            t.start();
        }
        Aron.end();
    }
    public static void test2() {
        Aron.beg();

        DeleteLinkedList dll = new DeleteLinkedList();
        for(int i=0; i<1000; i++) {
            Thread t = new Thread(new ThreadLinkedList(dll));
            t.start();
        }

        dll.sll.print();

        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        ConcurrentQueue queue = new ConcurrentQueue();

        for(int i=0; i<50; i++) {
            Thread t = new Thread(new QueueThread(queue));
            t.start();
        }

        queue.print();

        Aron.end();
    }
    public static void test4() {
        Aron.beg();
        AtomicCount count = new AtomicCount();
        count.print();
    }

    public static void test5() {
        Aron.beg();
        AtomicCount ac = new AtomicCount();
        for(int i=0; i<10; i++) {
            Thread t = new Thread(new AtomicCountThread(ac));
            t.start();
        }
    }

    public static void test6() {
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root);

        LevelPrint lp = new LevelPrint(b1.root);
        lp.print();

        Aron.end();
    }

    public static void test7() {
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);

        int NUM = 10;
        List<Integer> list = Aron.randomUnique(NUM);
        for(Integer n : list) {
            b1.insert(n + 30);
        }

        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root);

        LevelPrint lp = new LevelPrint(b1.root);
        lp.print();

        Ut.l();
        Print.pbl(b1.root.data);
        Thread t1 = new Thread(new ThreadLevelPrint(b1.root.left));
        t1.start();

        Thread t2 = new Thread(new ThreadLevelPrint(b1.root.right));
        t2.start();
        Ut.l();

        Aron.end();
    }

    static void test8() {
        Aron.beg();

        List<Integer> list = Aron.random(10);
        Aron.printList(list);

        Aron.end();
    }
    static void test9() {
        Aron.beg();

        List<Integer> list = Aron.randomUnique(10);
        Aron.printList(list);

        Aron.end();
    }
    static void test10() {
        Aron.beg();

        MyLock lock = new MyLock();
        for(int i=0; i<3; i++){
            LockThread lt = new LockThread(lock);
            lt.start();
        } 
        
        Aron.end();
    }

    static void test11() {
        Aron.beg();
        Message mq = new Message("my msg");
        Thread t1 = new Thread(new Waiter(mq), "Waiter Thread");
        t1.start();

        Thread t2 = new Thread(new Notifier(mq), "Notifier Thread");
        t2.start();

//        Aron.threadInfo();

        Aron.end();
    }
    
    static void test12() {
        Aron.beg();
        Queue<String> queue = new LinkedList<String>(); 
        queue.add("first");
        queue.add("second");

        Producer p = new Producer(queue);
        Thread pt = new Thread(p);
        pt.start();

        Thread t = new Thread(new Consumer(p));
        t.start();

        Thread t1 = new Thread(new Consumer(p));
        t1.start();

        Aron.end();
    }
    
}

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
//
import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
//
import classfile.*; 


// future example, threadpool, threadpoolservice, 
class FactorialCalculator implements Callable<Integer> {
    private Integer number;
    public FactorialCalculator(Integer number) {
        this.number = number;
    }

    @Override
    public Integer call() throws Exception {
        int result = 1;
        if ((number == 0) || (number == 1)) {
            result = 1;
        } else {
            for (int i = 2; i <= number; i++) {
                result *= i;
                TimeUnit.MILLISECONDS.sleep(200);
            }
        }
        System.out.println("Result for number - " + number + " -> " + result);
        return result;
    }
}

public class ThreadPoolExample {
    public static void main(String[] args) {
        test0();
    }
    
    static void test0(){
        Aron.beg();
        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);
        List<Future<Integer>> resultList = new ArrayList<>();

        Random random = new Random();

        for (int i=0; i<10; i++) {
            Integer number = random.nextInt(10);
            FactorialCalculator calculator  = new FactorialCalculator(number);
            Future<Integer> result = executor.submit(calculator);
            resultList.add(result);
        }

        for(Future<Integer> future : resultList) {
            try {
                System.out.println("Future result is - " + " - " + future.get() + "; And Task done is " + future.isDone());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
        //shut down the executor service now
        executor.shutdown();
        Aron.end();
    }
}
import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
//
import classfile.*; 

// wait and notify example
public class WaitNotifyExample{
        //private final static Logger LOGGER = Logger.getLogger(WaitNotifyExample.class.getName());
        private final static Logger LOGGER = logInit(WaitNotifyExample.class.getName());
        static private SimpleFormatter formatterTxt = new SimpleFormatter();
        static FileHandler fileTxt;

        public static Logger logInit(String name){
            Logger LOGGER = Logger.getLogger(name);
            try{
                fileTxt = new FileHandler("../text/Logging3.txt");
            }catch(IOException e){
                e.printStackTrace();
            } 

            LOGGER.setLevel(Level.INFO);
            LOGGER.addHandler(fileTxt);
            fileTxt.setFormatter(formatterTxt);
            return LOGGER;
        }
        public static void main(String[] args){

//        try{
//            fileTxt = new FileHandler("../text/Logging3.txt");
//        }catch(IOException e){
//            e.printStackTrace();
//        } 
//
//        LOGGER.setLevel(Level.INFO);
//        LOGGER.addHandler(fileTxt);
//        fileTxt.setFormatter(formatterTxt);

        ThreadB b = new ThreadB(LOGGER);
        b.start();
 
        //Aron.threadInfo(b);
        synchronized(b){
            try{
                System.out.println("Waiting for b to complete...");
                
                LOGGER.info("logging it"); 
                LOGGER.info(Aron.threadInfo(b)); 
                
                b.wait();
                Print.pbl("get notified");
                Aron.threadInfo(b);
            }catch(InterruptedException e){
                e.printStackTrace();
            }
 
            System.out.println("Total is: " + b.total);
        }
//        if(fileTxt != null)
//            fileTxt.close();
    }
}
 
class ThreadB extends Thread{
    int total;
    Logger LOGGER;
    public ThreadB(){}
    public ThreadB(Logger LOGGER){
        this.LOGGER = LOGGER;
    }
    @Override
    public void run(){
        synchronized(this){
            for(int i=0; i<5; i++){
//                Aron.threadInfo(this);
                LOGGER.info(Aron.threadInfo(this)); 
                try{
                    Thread.sleep(1000);  // sleep two seconds
                }catch(InterruptedException e){
                    e.printStackTrace();
                } 

                total += i;
            }
            notify();
//            Aron.threadInfo(this);
        }
    }
}
